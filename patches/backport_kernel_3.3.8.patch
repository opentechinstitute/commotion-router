Index: target/linux/iop32x/Makefile
===================================================================
--- target/linux/iop32x/Makefile	(revision 31639)
+++ target/linux/iop32x/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/orion/Makefile
===================================================================
--- target/linux/orion/Makefile	(revision 31639)
+++ target/linux/orion/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS=-Os -pipe -march=armv5te -mtune=xscale -fno-caller-saves
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=3.0.18
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/pxa/Makefile
===================================================================
--- target/linux/pxa/Makefile	(revision 31639)
+++ target/linux/pxa/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/ar7/Makefile
===================================================================
--- target/linux/ar7/Makefile	(revision 31639)
+++ target/linux/ar7/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs jffs2 atm
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/kirkwood/Makefile
===================================================================
--- target/linux/kirkwood/Makefile	(revision 31639)
+++ target/linux/kirkwood/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=targz usb jffs2
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/rb532/Makefile
===================================================================
--- target/linux/rb532/Makefile	(revision 31639)
+++ target/linux/rb532/Makefile	(working copy)
@@ -11,7 +11,7 @@
 BOARDNAME:=Mikrotik RouterBoard 532
 FEATURES:=jffs2 pci targz broken
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 DEFAULT_PACKAGES += wpad-mini kmod-madwifi kmod-input-rb532
Index: target/linux/avr32/Makefile
===================================================================
--- target/linux/avr32/Makefile	(revision 31639)
+++ target/linux/avr32/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/adm8668/Makefile
===================================================================
--- target/linux/adm8668/Makefile	(revision 31639)
+++ target/linux/adm8668/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 DEFAULT_PACKAGES += wpad-mini kmod-rt61-pci
Index: target/linux/ixp4xx/Makefile
===================================================================
--- target/linux/ixp4xx/Makefile	(revision 31639)
+++ target/linux/ixp4xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 SUBTARGETS=generic harddisk
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/cobalt/Makefile
===================================================================
--- target/linux/cobalt/Makefile	(revision 31639)
+++ target/linux/cobalt/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-O2 -pipe -mtune=r5000 -fno-caller-saves
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/au1000/Makefile
===================================================================
--- target/linux/au1000/Makefile	(revision 31639)
+++ target/linux/au1000/Makefile	(working copy)
@@ -13,7 +13,7 @@
 SUBTARGETS=au1500 au1550
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 DEFAULT_PACKAGES += wpad-mini yamonenv
Index: target/linux/cns21xx/Makefile
===================================================================
--- target/linux/cns21xx/Makefile	(revision 31639)
+++ target/linux/cns21xx/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs broken
 CFLAGS:=-Os -pipe -march=armv4 -mtune=fa526 -fno-caller-saves
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/adm5120/Makefile
===================================================================
--- target/linux/adm5120/Makefile	(revision 31639)
+++ target/linux/adm5120/Makefile	(working copy)
@@ -9,7 +9,7 @@
 
 BOARD:=adm5120
 BOARDNAME:=Infineon/ADMtek ADM5120
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 SUBTARGETS:=router_le router_be rb1xx
 INITRAMFS_EXTRA_FILES:=
 
Index: target/linux/mpc83xx/Makefile
===================================================================
--- target/linux/mpc83xx/Makefile	(revision 31639)
+++ target/linux/mpc83xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 FEATURES:=squashfs targz
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/brcm63xx/Makefile
===================================================================
--- target/linux/brcm63xx/Makefile	(revision 31639)
+++ target/linux/brcm63xx/Makefile	(working copy)
@@ -10,7 +10,7 @@
 BOARD:=brcm63xx
 BOARDNAME:=Broadcom BCM63xx
 FEATURES:=squashfs jffs2 usb atm pci pcmcia
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
 include $(INCLUDE_DIR)/target.mk
Index: target/linux/mpc85xx/Makefile
===================================================================
--- target/linux/mpc85xx/Makefile	(revision 31639)
+++ target/linux/mpc85xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 FEATURES:=spe_fpu ramdisk
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.38.8
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/brcm47xx/Makefile
===================================================================
--- target/linux/brcm47xx/Makefile	(revision 31639)
+++ target/linux/brcm47xx/Makefile	(working copy)
@@ -11,7 +11,7 @@
 BOARDNAME:=Broadcom BCM947xx/953xx
 FEATURES:=squashfs usb pcmcia
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 DEFAULT_PACKAGES += wpad-mini kmod-switch kmod-diag nvram
Index: target/linux/realview/Makefile
===================================================================
--- target/linux/realview/Makefile	(revision 31639)
+++ target/linux/realview/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=armv6k -mtune=mpcore -mfloat-abi=softfp -mfpu=vfp -fno-caller-saves
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.0.18
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/amazon/Makefile
===================================================================
--- target/linux/amazon/Makefile	(revision 31639)
+++ target/linux/amazon/Makefile	(working copy)
@@ -10,7 +10,7 @@
 BOARD:=amazon
 BOARDNAME:=Infineon Amazon
 FEATURES:=squashfs jffs2 broken
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/x86/config-3.3
===================================================================
--- target/linux/x86/config-3.3	(revision 31639)
+++ target/linux/x86/config-3.3	(working copy)
@@ -6,8 +6,9 @@
 # CONFIG_ALIM1535_WDT is not set
 # CONFIG_ALIX is not set
 CONFIG_AMD_NB=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
 CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
-# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
 CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
 CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_ARCH_HAS_CPU_RELAX=y
@@ -16,8 +17,6 @@
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-ecx -fcall-saved-edx"
 CONFIG_ARCH_MAY_HAVE_PC_FDC=y
-# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
-CONFIG_ARCH_POPULATES_NODE_MAP=y
 # CONFIG_ARCH_RANDOM is not set
 CONFIG_ARCH_SELECT_MEMORY_MODEL=y
 CONFIG_ARCH_SPARSEMEM_ENABLE=y
@@ -41,8 +40,6 @@
 CONFIG_CLKEVT_I8253=y
 CONFIG_CLKSRC_I8253=y
 CONFIG_CLOCKSOURCE_WATCHDOG=y
-CONFIG_CMPXCHG_DOUBLE=y
-CONFIG_CMPXCHG_LOCAL=y
 CONFIG_COMPAT_VDSO=y
 # CONFIG_CPU5_WDT is not set
 CONFIG_CPU_FREQ=y
@@ -92,7 +89,6 @@
 CONFIG_FIRMWARE_IN_KERNEL=y
 CONFIG_FIRMWARE_MEMMAP=y
 CONFIG_FIX_EARLYCON_MEM=y
-# CONFIG_FRAME_POINTER is not set
 CONFIG_FS_MBCACHE=y
 CONFIG_GENERIC_BUG=y
 CONFIG_GENERIC_CLOCKEVENTS=y
@@ -104,19 +100,22 @@
 CONFIG_GENERIC_IOMAP=y
 CONFIG_GENERIC_IRQ_SHOW=y
 CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_PCI_IOMAP=y
 # CONFIG_GENERIC_TIME_VSYSCALL is not set
-# CONFIG_GEOS is not set
 # CONFIG_GOOGLE_FIRMWARE is not set
 # CONFIG_HANGCHECK_TIMER is not set
 CONFIG_HAS_DMA=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
 CONFIG_HAVE_AOUT=y
 CONFIG_HAVE_ARCH_JUMP_LABEL=y
 CONFIG_HAVE_ARCH_KGDB=y
 CONFIG_HAVE_ARCH_KMEMCHECK=y
 CONFIG_HAVE_ARCH_TRACEHOOK=y
 CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
 CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_HAVE_DMA_ATTRS=y
@@ -141,6 +140,7 @@
 CONFIG_HAVE_KVM=y
 CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
 CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
 CONFIG_HAVE_MMIOTRACE_SUPPORT=y
 CONFIG_HAVE_OPROFILE=y
@@ -197,7 +197,6 @@
 CONFIG_KALLSYMS=y
 CONFIG_KEXEC=y
 CONFIG_KTIME_SCALAR=y
-# CONFIG_LEDS_GPIO is not set
 # CONFIG_M386 is not set
 CONFIG_M486=y
 # CONFIG_M586 is not set
@@ -220,7 +219,6 @@
 # CONFIG_MK6 is not set
 # CONFIG_MK7 is not set
 # CONFIG_MK8 is not set
-# CONFIG_MLX4_CORE is not set
 # CONFIG_MPENTIUM4 is not set
 # CONFIG_MPENTIUMII is not set
 # CONFIG_MPENTIUMIII is not set
@@ -242,22 +240,18 @@
 CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
 CONFIG_NEED_SG_DMA_LENGTH=y
 # CONFIG_NET_NS is not set
-# CONFIG_NET5501 is not set
 CONFIG_NOHIGHMEM=y
 CONFIG_NO_BOOTMEM=y
 CONFIG_NR_CPUS=1
 # CONFIG_NSC_GPIO is not set
 CONFIG_NVRAM=y
 # CONFIG_OLPC is not set
+CONFIG_OPROFILE_NMI_TIMER=y
 # CONFIG_OPTIMIZE_INLINING is not set
 CONFIG_OUTPUT_FORMAT="elf32-i386"
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_PAGE_OFFSET=0xC0000000
 # CONFIG_PARAVIRT_GUEST is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_VIA is not set
 # CONFIG_PC8736x_GPIO is not set
 # CONFIG_PC87413_WDT is not set
 CONFIG_PCI=y
@@ -276,16 +270,13 @@
 CONFIG_PHYSICAL_ALIGN=0x100000
 CONFIG_PHYSICAL_START=0x1000000
 CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
 # CONFIG_PREEMPT_RCU is not set
 # CONFIG_PROCESSOR_SELECT is not set
 CONFIG_PROC_PAGE_MONITOR=y
 # CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
-# CONFIG_QUOTACTL is not set
 CONFIG_RD_BZIP2=y
 CONFIG_RD_GZIP=y
 # CONFIG_RELOCATABLE is not set
-CONFIG_RTC=y
 CONFIG_RTC_CLASS=y
 # CONFIG_RWSEM_GENERIC_SPINLOCK is not set
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
@@ -297,7 +288,6 @@
 # CONFIG_SC520_WDT is not set
 # CONFIG_SCHED_HRTICK is not set
 CONFIG_SCSI=y
-# CONFIG_SCSI_ISCI is not set
 CONFIG_SCx200=y
 CONFIG_SCx200HR_TIMER=y
 # CONFIG_SCx200_GPIO is not set
@@ -307,8 +297,6 @@
 # CONFIG_SERIO_CT82C710 is not set
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_LIBPS2=y
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_RAW is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SLAB is not set
 CONFIG_SLUB=y
@@ -331,7 +319,6 @@
 # CONFIG_VIA_WDT is not set
 CONFIG_VM86=y
 # CONFIG_VMWARE_BALLOON is not set
-# CONFIG_VMWARE_PVSCSI is not set
 CONFIG_VM_EVENT_COUNTERS=y
 # CONFIG_W83697UG_WDT is not set
 # CONFIG_WAFER_WDT is not set
Index: target/linux/x86/generic/config-3.3
===================================================================
--- target/linux/x86/generic/config-3.3	(revision 0)
+++ target/linux/x86/generic/config-3.3	(revision 0)
@@ -0,0 +1,187 @@
+# CONFIG_3C515 is not set
+# CONFIG_AC3200 is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_AC=y
+# CONFIG_ACPI_ASUS is not set
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BLACKLIST_YEAR=0
+CONFIG_ACPI_BUTTON=y
+# CONFIG_ACPI_CMPC is not set
+# CONFIG_ACPI_CONTAINER is not set
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_DOCK is not set
+# CONFIG_ACPI_EC_DEBUGFS is not set
+# CONFIG_ACPI_FAN is not set
+# CONFIG_ACPI_PCI_SLOT is not set
+CONFIG_ACPI_PROCESSOR=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+# CONFIG_ACPI_PROCFS is not set
+# CONFIG_ACPI_PROCFS_POWER is not set
+# CONFIG_ACPI_PROC_EVENT is not set
+# CONFIG_ACPI_SBS is not set
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_TOSHIBA is not set
+CONFIG_ACPI_VIDEO=y
+# CONFIG_ACPI_WMI is not set
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_AMD is not set
+# CONFIG_AGP_AMD64 is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_APRICOT is not set
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_AT1700 is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_APPLE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_BACKLIGHT_PROGEAR is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BLK_DEV_XD is not set
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DEPCA is not set
+CONFIG_DMI=y
+# CONFIG_DMIID is not set
+# CONFIG_DMI_SYSFS is not set
+CONFIG_DRM=y
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+CONFIG_DRM_I915_KMS=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_VMWGFX is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_EFI is not set
+# CONFIG_EISA is not set
+# CONFIG_EL1 is not set
+# CONFIG_EL16 is not set
+# CONFIG_EL2 is not set
+# CONFIG_EL3 is not set
+# CONFIG_ELPLUS is not set
+CONFIG_FB=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_VESA is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x16=y
+CONFIG_FONT_8x8=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_GEOS is not set
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+# CONFIG_HP_ACCEL is not set
+CONFIG_HW_CONSOLE=y
+CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INTEL_IDLE=y
+# CONFIG_INTEL_IPS is not set
+# CONFIG_INTEL_MENLOW is not set
+CONFIG_ISA=y
+CONFIG_ISAPNP=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_LANCE is not set
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+# CONFIG_MDA_CONSOLE is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_MOUSE_BCM5974 is not set
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_NLS=y
+CONFIG_NO_HZ=y
+# CONFIG_PANASONIC_LAPTOP is not set
+CONFIG_PATA_AMD=y
+CONFIG_PATA_LEGACY=y
+CONFIG_PATA_MPIIX=y
+CONFIG_PATA_OLDPIIX=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_SC1200=y
+CONFIG_PATA_VIA=y
+CONFIG_PCIEAER=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+CONFIG_PCI_MMCONFIG=y
+# CONFIG_PCWATCHDOG is not set
+CONFIG_PNP=y
+CONFIG_PNPACPI=y
+# CONFIG_PNPBIOS is not set
+CONFIG_PNP_DEBUG_MESSAGES=y
+CONFIG_SATA_AHCI=y
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SCx200_ACB is not set
+CONFIG_SERIAL_8250_PNP=y
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_TOPSTAR_LAPTOP is not set
+# CONFIG_TOSHIBA_BT_RFKILL is not set
+CONFIG_USB=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_VGA_CONSOLE=y
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_WDT is not set
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_PM_TIMER=y
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_XO15_EBOOK is not set
Index: target/linux/x86/generic/config-default
===================================================================
--- target/linux/x86/generic/config-default	(revision 31639)
+++ target/linux/x86/generic/config-default	(working copy)
@@ -1,113 +0,0 @@
-# CONFIG_3C515 is not set
-# CONFIG_AC3200 is not set
-CONFIG_ACPI=y
-# CONFIG_ACPI_AC is not set
-# CONFIG_ACPI_ASUS is not set
-# CONFIG_ACPI_BATTERY is not set
-CONFIG_ACPI_BLACKLIST_YEAR=0
-# CONFIG_ACPI_BUTTON is not set
-# CONFIG_ACPI_CMPC is not set
-# CONFIG_ACPI_CONTAINER is not set
-# CONFIG_ACPI_CUSTOM_DSDT is not set
-# CONFIG_ACPI_DEBUG is not set
-# CONFIG_ACPI_DOCK is not set
-# CONFIG_ACPI_EC_DEBUGFS is not set
-# CONFIG_ACPI_FAN is not set
-# CONFIG_ACPI_PCI_SLOT is not set
-CONFIG_ACPI_PROCESSOR=y
-# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
-# CONFIG_ACPI_PROCFS is not set
-# CONFIG_ACPI_PROCFS_POWER is not set
-# CONFIG_ACPI_PROC_EVENT is not set
-# CONFIG_ACPI_QUICKSTART is not set
-# CONFIG_ACPI_SBS is not set
-CONFIG_ACPI_THERMAL=y
-# CONFIG_ACPI_WMI is not set
-# CONFIG_APRICOT is not set
-# CONFIG_ASUS_LAPTOP is not set
-# CONFIG_AT1700 is not set
-# CONFIG_BLK_DEV_XD is not set
-CONFIG_CONSOLE_TRANSLATIONS=y
-# CONFIG_CS89x0 is not set
-# CONFIG_DEPCA is not set
-# CONFIG_DMAR is not set
-CONFIG_DMI=y
-# CONFIG_DMIID is not set
-# CONFIG_DMI_SYSFS is not set
-CONFIG_DUMMY_CONSOLE=y
-# CONFIG_EFI is not set
-# CONFIG_EISA is not set
-# CONFIG_EL1 is not set
-# CONFIG_EL16 is not set
-# CONFIG_EL2 is not set
-# CONFIG_EL3 is not set
-# CONFIG_ELPLUS is not set
-CONFIG_HID=y
-CONFIG_HID_SUPPORT=y
-CONFIG_HPET=y
-CONFIG_HPET_MMAP=y
-# CONFIG_HP_ACCEL is not set
-CONFIG_HW_CONSOLE=y
-CONFIG_INPUT=y
-CONFIG_INPUT_KEYBOARD=y
-CONFIG_INPUT_MOUSE=y
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INTEL_IPS is not set
-# CONFIG_INTEL_MENLOW is not set
-CONFIG_ISA=y
-CONFIG_ISAPNP=y
-CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_LANCE is not set
-# CONFIG_LEDS_CLEVO_MAIL is not set
-# CONFIG_MDA_CONSOLE is not set
-# CONFIG_MIXCOMWD is not set
-# CONFIG_MOUSE_BCM5974 is not set
-CONFIG_MOUSE_PS2=y
-CONFIG_MOUSE_PS2_ALPS=y
-# CONFIG_MOUSE_PS2_ELANTECH is not set
-CONFIG_MOUSE_PS2_LIFEBOOK=y
-CONFIG_MOUSE_PS2_LOGIPS2PP=y
-CONFIG_MOUSE_PS2_SYNAPTICS=y
-# CONFIG_MOUSE_PS2_TOUCHKIT is not set
-CONFIG_MOUSE_PS2_TRACKPOINT=y
-# CONFIG_MOUSE_SERIAL is not set
-# CONFIG_MOUSE_VSXXXAA is not set
-# CONFIG_NET_VENDOR_RACAL is not set
-# CONFIG_NET_VENDOR_SMC is not set
-CONFIG_NLS=y
-CONFIG_PATA_AMD=y
-CONFIG_PATA_LEGACY=y
-CONFIG_PATA_MPIIX=y
-CONFIG_PATA_OLDPIIX=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_PATA_SC1200=y
-CONFIG_PATA_VIA=y
-CONFIG_PCIEAER=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCI_IOAPIC=y
-CONFIG_PCI_LABEL=y
-CONFIG_PCI_MMCONFIG=y
-# CONFIG_PCWATCHDOG is not set
-CONFIG_PNP=y
-CONFIG_PNPACPI=y
-# CONFIG_PNPBIOS is not set
-CONFIG_PNP_DEBUG_MESSAGES=y
-CONFIG_SERIAL_8250_PNP=y
-# CONFIG_THINKPAD_ACPI is not set
-# CONFIG_TOPSTAR_LAPTOP is not set
-# CONFIG_TOSHIBA_BT_RFKILL is not set
-# CONFIG_VGACON_SOFT_SCROLLBACK is not set
-CONFIG_VGA_CONSOLE=y
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
-# CONFIG_WDT is not set
-# CONFIG_X86_ACPI_CPUFREQ is not set
-# CONFIG_X86_LONGHAUL is not set
-# CONFIG_X86_PCC_CPUFREQ is not set
-CONFIG_X86_PM_TIMER=y
-# CONFIG_X86_POWERNOW_K8 is not set
-# CONFIG_XO15_EBOOK is not set
Index: target/linux/x86/Makefile
===================================================================
--- target/linux/x86/Makefile	(revision 31639)
+++ target/linux/x86/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs jffs2 ext4 vdi vmdk pcmcia targz
 SUBTARGETS=generic olpc xen_domu ep80579 net5501 kvm_guest geos alix2 thincan
 
-LINUX_VERSION:=2.6.39.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/xburst/Makefile
===================================================================
--- target/linux/xburst/Makefile	(revision 31639)
+++ target/linux/xburst/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=jffs2 targz ubifs audio
 SUBTARGETS:=qi_lb60 n516 n526 id800wt
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 DEVICE_TYPE=other
 
Index: target/linux/lantiq/Makefile
===================================================================
--- target/linux/lantiq/Makefile	(revision 31639)
+++ target/linux/lantiq/Makefile	(working copy)
@@ -12,7 +12,7 @@
 FEATURES:=squashfs jffs2
 DEFAULT_SUBTARGET:=danube
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 CFLAGS=-Os -pipe -mips32r2 -mtune=mips32r2 -fno-caller-saves
 
Index: target/linux/ar71xx/Makefile
===================================================================
--- target/linux/ar71xx/Makefile	(revision 31639)
+++ target/linux/ar71xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -mips32r2 -mtune=mips32r2 -fno-caller-saves
 SUBTARGETS:=generic nand
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/ramips/Makefile
===================================================================
--- target/linux/ramips/Makefile	(revision 31639)
+++ target/linux/ramips/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -mips32r2 -mtune=mips32r2 -fno-caller-saves
 FEATURES:=squashfs
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 DEFAULT_PACKAGES+=\
Index: target/linux/uml/Makefile
===================================================================
--- target/linux/uml/Makefile	(revision 31639)
+++ target/linux/uml/Makefile	(working copy)
@@ -23,7 +23,7 @@
 FEATURES:=ext4 audio
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/malta/Makefile
===================================================================
--- target/linux/malta/Makefile	(revision 31639)
+++ target/linux/malta/Makefile	(working copy)
@@ -13,7 +13,7 @@
 INITRAMFS_EXTRA_FILES:=
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/sibyte/Makefile
===================================================================
--- target/linux/sibyte/Makefile	(revision 31639)
+++ target/linux/sibyte/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=sb1 -fno-caller-saves
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/ep93xx/Makefile
===================================================================
--- target/linux/ep93xx/Makefile	(revision 31639)
+++ target/linux/ep93xx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=armv4t -fno-caller-saves
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/atheros/Makefile
===================================================================
--- target/linux/atheros/Makefile	(revision 31639)
+++ target/linux/atheros/Makefile	(working copy)
@@ -11,7 +11,7 @@
 BOARDNAME:=Atheros AR231x/AR5312
 FEATURES:=squashfs jffs2
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/mpc52xx/Makefile
===================================================================
--- target/linux/mpc52xx/Makefile	(revision 31639)
+++ target/linux/mpc52xx/Makefile	(working copy)
@@ -12,7 +12,7 @@
 CFLAGS:=-Os -pipe -fno-caller-saves -mcpu=603e
 FEATURES:=targz ext4
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/rdc/Makefile
===================================================================
--- target/linux/rdc/Makefile	(revision 31639)
+++ target/linux/rdc/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=i486 -mtune=i486 -fno-caller-saves
 MAINTAINER:=Florian Fainelli <florian@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/gemini/Makefile
===================================================================
--- target/linux/gemini/Makefile	(revision 31639)
+++ target/linux/gemini/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=armv4 -mtune=fa526 -fno-caller-saves
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.37.6
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/generic/patches-3.3/721-phy_packets.patch
===================================================================
--- target/linux/generic/patches-3.3/721-phy_packets.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/721-phy_packets.patch	(working copy)
@@ -79,7 +79,7 @@
  	help
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -2246,9 +2246,19 @@ int dev_hard_start_xmit(struct sk_buff *
+@@ -2267,9 +2267,19 @@ int dev_hard_start_xmit(struct sk_buff *
  			}
  		}
  
@@ -102,7 +102,7 @@
  		if (rc == NETDEV_TX_OK)
  			txq_trans_update(txq);
  		return rc;
-@@ -2268,9 +2278,19 @@ gso:
+@@ -2289,9 +2299,19 @@ gso:
  		if (dev->priv_flags & IFF_XMIT_DST_RELEASE)
  			skb_dst_drop(nskb);
  
Index: target/linux/generic/patches-3.3/654-avoid_skb_cow_realloc.patch
===================================================================
--- target/linux/generic/patches-3.3/654-avoid_skb_cow_realloc.patch	(revision 0)
+++ target/linux/generic/patches-3.3/654-avoid_skb_cow_realloc.patch	(revision 0)
@@ -0,0 +1,21 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -1850,12 +1850,15 @@ static inline int skb_clone_writable(con
+ static inline int __skb_cow(struct sk_buff *skb, unsigned int headroom,
+ 			    int cloned)
+ {
++	unsigned int alloc_headroom = headroom;
+ 	int delta = 0;
+ 
+ 	if (headroom < NET_SKB_PAD)
+-		headroom = NET_SKB_PAD;
+-	if (headroom > skb_headroom(skb))
+-		delta = headroom - skb_headroom(skb);
++		alloc_headroom = NET_SKB_PAD;
++	if (headroom > skb_headroom(skb) ||
++	    (cloned && alloc_headroom > skb_headroom(skb))) {
++		delta = alloc_headroom - skb_headroom(skb);
++	}
+ 
+ 	if (delta || cloned)
+ 		return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD), 0,
Index: target/linux/generic/patches-3.3/049-codel-refine-one-condition-to-avoid-a-nul-rec_inv_sqrt.patch
===================================================================
--- target/linux/generic/patches-3.3/049-codel-refine-one-condition-to-avoid-a-nul-rec_inv_sqrt.patch	(revision 0)
+++ target/linux/generic/patches-3.3/049-codel-refine-one-condition-to-avoid-a-nul-rec_inv_sqrt.patch	(revision 0)
@@ -0,0 +1,52 @@
+From b8fc328668a74e1314a19266755a54abd875e5a6 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Sun, 29 Jul 2012 20:52:21 +0000
+Subject: [PATCH] codel: refine one condition to avoid a nul rec_inv_sqrt
+
+commit 2359a47671fc4fb0fe5e9945f76c2cb10792c0f8 upstream.
+
+One condition before codel_Newton_step() was not good if
+we never left the dropping state for a flow. As a result
+rec_inv_sqrt was 0, instead of the ~0 initial value.
+
+codel control law was then set to a very aggressive mode, dropping
+many packets before reaching 'target' and recovering from this problem.
+
+To keep codel_vars_init() as efficient as possible, refine
+the condition to make sure rec_inv_sqrt initial value is correct
+
+Many thanks to Anton Mich for discovering the issue and suggesting
+a fix.
+
+Reported-by: Anton Mich <lp2s1h@gmail.com>
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/codel.h |    8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/include/net/codel.h
++++ b/include/net/codel.h
+@@ -305,6 +305,8 @@ static struct sk_buff *codel_dequeue(str
+ 			}
+ 		}
+ 	} else if (drop) {
++		u32 delta;
++
+ 		if (params->ecn && INET_ECN_set_ce(skb)) {
+ 			stats->ecn_mark++;
+ 		} else {
+@@ -320,9 +322,11 @@ static struct sk_buff *codel_dequeue(str
+ 		 * assume that the drop rate that controlled the queue on the
+ 		 * last cycle is a good starting point to control it now.
+ 		 */
+-		if (codel_time_before(now - vars->drop_next,
++		delta = vars->count - vars->lastcount;
++		if (delta > 1 &&
++		    codel_time_before(now - vars->drop_next,
+ 				      16 * params->interval)) {
+-			vars->count = (vars->count - vars->lastcount) | 1;
++			vars->count = delta;
+ 			/* we dont care if rec_inv_sqrt approximation
+ 			 * is not very precise :
+ 			 * Next Newton steps will correct it quadratically.
Index: target/linux/generic/patches-3.3/727-phy-rtl8367.patch
===================================================================
--- target/linux/generic/patches-3.3/727-phy-rtl8367.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/727-phy-rtl8367.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -185,6 +185,10 @@ config RTL8366RB_PHY
+@@ -190,6 +190,10 @@ config RTL8366RB_PHY
  	tristate "Driver for the Realtek RTL8366RB switch"
  	select SWCONFIG
  
@@ -8,9 +8,9 @@
 +	tristate "Driver for the Realtek RTL8367R/M switches"
 +	select SWCONFIG
 +
- config RTL8366S_PHY_DEBUG_FS
- 	bool "RTL8366 switch driver DEBUG_FS support"
- 	depends on RTL8366S_PHY || RTL8366RB_PHY
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
 --- a/drivers/net/phy/Makefile
 +++ b/drivers/net/phy/Makefile
 @@ -25,6 +25,7 @@ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
Index: target/linux/generic/patches-3.3/992-mpcore_wdt_fix_watchdog_counter_loading.patch
===================================================================
--- target/linux/generic/patches-3.3/992-mpcore_wdt_fix_watchdog_counter_loading.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/992-mpcore_wdt_fix_watchdog_counter_loading.patch	(working copy)
@@ -51,7 +51,7 @@
 +EXPORT_SYMBOL_GPL(twd_timer_get_rate);
 --- a/drivers/watchdog/mpcore_wdt.c
 +++ b/drivers/watchdog/mpcore_wdt.c
-@@ -99,9 +99,7 @@ static void mpcore_wdt_keepalive(struct 
+@@ -99,9 +99,7 @@ static void mpcore_wdt_keepalive(struct
  
  	spin_lock(&wdt_lock);
  	/* Assume prescale is set to 256 */
Index: target/linux/generic/patches-3.3/080-prot-release-cb.patch
===================================================================
--- target/linux/generic/patches-3.3/080-prot-release-cb.patch	(revision 0)
+++ target/linux/generic/patches-3.3/080-prot-release-cb.patch	(revision 0)
@@ -0,0 +1,27 @@
+This was added in commit 46d3ceabd8d98ed0ad10f20c595ca784e34786c5 (tcp: 
+TCP Small Queues) but we need it for pppoatm too.
+
+--- a/include/net/sock.h
++++ b/include/net/sock.h
+@@ -858,6 +858,8 @@ struct proto {
+ 	int			(*backlog_rcv) (struct sock *sk,
+ 						struct sk_buff *skb);
+ 
++	void		(*release_cb)(struct sock *sk);
++
+ 	/* Keeping track of sk's, looking them up, and port selection methods. */
+ 	void			(*hash)(struct sock *sk);
+ 	void			(*unhash)(struct sock *sk);
+--- a/net/core/sock.c
++++ b/net/core/sock.c
+@@ -2159,6 +2159,10 @@ void release_sock(struct sock *sk)
+ 	spin_lock_bh(&sk->sk_lock.slock);
+ 	if (sk->sk_backlog.tail)
+ 		__release_sock(sk);
++
++	if (sk->sk_prot->release_cb)
++		sk->sk_prot->release_cb(sk);
++
+ 	sk->sk_lock.owned = 0;
+ 	if (waitqueue_active(&sk->sk_lock.wq))
+ 		wake_up(&sk->sk_lock.wq);
Index: target/linux/generic/patches-3.3/025-bcma_backport.patch
===================================================================
--- target/linux/generic/patches-3.3/025-bcma_backport.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/025-bcma_backport.patch	(working copy)
@@ -9,9 +9,47 @@
  	help
  	  PCI core hostmode operation (external PCI bus).
  
+@@ -46,6 +46,15 @@ config BCMA_DRIVER_MIPS
+ 
+ 	  If unsure, say N
+ 
++config BCMA_DRIVER_GMAC_CMN
++	bool "BCMA Broadcom GBIT MAC COMMON core driver"
++	depends on BCMA
++	help
++	  Driver for the Broadcom GBIT MAC COMMON core attached to Broadcom
++	  specific Advanced Microcontroller Bus.
++
++	  If unsure, say N
++
+ config BCMA_DEBUG
+ 	bool "BCMA debugging"
+ 	depends on BCMA
+--- a/drivers/bcma/Makefile
++++ b/drivers/bcma/Makefile
+@@ -3,6 +3,7 @@ bcma-y					+= driver_chipcommon.o driver
+ bcma-y					+= driver_pci.o
+ bcma-$(CONFIG_BCMA_DRIVER_PCI_HOSTMODE)	+= driver_pci_host.o
+ bcma-$(CONFIG_BCMA_DRIVER_MIPS)		+= driver_mips.o
++bcma-$(CONFIG_BCMA_DRIVER_GMAC_CMN)	+= driver_gmac_cmn.o
+ bcma-$(CONFIG_BCMA_HOST_PCI)		+= host_pci.o
+ bcma-$(CONFIG_BCMA_HOST_SOC)		+= host_soc.o
+ obj-$(CONFIG_BCMA)			+= bcma.o
 --- a/drivers/bcma/bcma_private.h
 +++ b/drivers/bcma/bcma_private.h
-@@ -13,7 +13,7 @@
+@@ -10,10 +10,19 @@
+ 
+ #define BCMA_CORE_SIZE		0x1000
+ 
++#define bcma_err(bus, fmt, ...) \
++	pr_err("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
++#define bcma_warn(bus, fmt, ...) \
++	pr_warn("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
++#define bcma_info(bus, fmt, ...) \
++	pr_info("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
++#define bcma_debug(bus, fmt, ...) \
++	pr_debug("bus%d: " fmt, (bus)->num, ##__VA_ARGS__)
++
  struct bcma_bus;
  
  /* main.c */
@@ -20,7 +58,7 @@
  void bcma_bus_unregister(struct bcma_bus *bus);
  int __init bcma_bus_early_register(struct bcma_bus *bus,
  				   struct bcma_device *core_cc,
-@@ -48,8 +48,12 @@ extern int __init bcma_host_pci_init(voi
+@@ -48,8 +57,12 @@ extern int __init bcma_host_pci_init(voi
  extern void __exit bcma_host_pci_exit(void);
  #endif /* CONFIG_BCMA_HOST_PCI */
  
@@ -34,16 +72,677 @@
  #endif /* CONFIG_BCMA_DRIVER_PCI_HOSTMODE */
  
  #endif
+--- a/drivers/bcma/core.c
++++ b/drivers/bcma/core.c
+@@ -30,6 +30,7 @@ void bcma_core_disable(struct bcma_devic
+ 	udelay(10);
+ 
+ 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
++	bcma_aread32(core, BCMA_RESET_CTL);
+ 	udelay(1);
+ }
+ EXPORT_SYMBOL_GPL(bcma_core_disable);
+@@ -74,10 +75,10 @@ void bcma_core_set_clockmode(struct bcma
+ 			udelay(10);
+ 		}
+ 		if (i)
+-			pr_err("HT force timeout\n");
++			bcma_err(core->bus, "HT force timeout\n");
+ 		break;
+ 	case BCMA_CLKMODE_DYNAMIC:
+-		pr_warn("Dynamic clockmode not supported yet!\n");
++		bcma_set32(core, BCMA_CLKCTLST, ~BCMA_CLKCTLST_FORCEHT);
+ 		break;
+ 	}
+ }
+@@ -101,9 +102,9 @@ void bcma_core_pll_ctl(struct bcma_devic
+ 			udelay(10);
+ 		}
+ 		if (i)
+-			pr_err("PLL enable timeout\n");
++			bcma_err(core->bus, "PLL enable timeout\n");
+ 	} else {
+-		pr_warn("Disabling PLL not supported yet!\n");
++		bcma_warn(core->bus, "Disabling PLL not supported yet!\n");
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);
+@@ -119,8 +120,8 @@ u32 bcma_core_dma_translation(struct bcm
+ 		else
+ 			return BCMA_DMA_TRANSLATION_DMA32_CMT;
+ 	default:
+-		pr_err("DMA translation unknown for host %d\n",
+-		       core->bus->hosttype);
++		bcma_err(core->bus, "DMA translation unknown for host %d\n",
++			 core->bus->hosttype);
+ 	}
+ 	return BCMA_DMA_TRANSLATION_NONE;
+ }
+--- a/drivers/bcma/driver_chipcommon.c
++++ b/drivers/bcma/driver_chipcommon.c
+@@ -44,7 +44,7 @@ void bcma_core_chipcommon_init(struct bc
+ 	if (cc->capabilities & BCMA_CC_CAP_PMU)
+ 		bcma_pmu_init(cc);
+ 	if (cc->capabilities & BCMA_CC_CAP_PCTL)
+-		pr_err("Power control not implemented!\n");
++		bcma_err(cc->core->bus, "Power control not implemented!\n");
+ 
+ 	if (cc->core->id.rev >= 16) {
+ 		if (cc->core->bus->sprom.leddc_on_time &&
+@@ -137,8 +137,7 @@ void bcma_chipco_serial_init(struct bcma
+ 				       | BCMA_CC_CORECTL_UARTCLKEN);
+ 		}
+ 	} else {
+-		pr_err("serial not supported on this device ccrev: 0x%x\n",
+-		       ccrev);
++		bcma_err(cc->core->bus, "serial not supported on this device ccrev: 0x%x\n", ccrev);
+ 		return;
+ 	}
+ 
 --- a/drivers/bcma/driver_chipcommon_pmu.c
 +++ b/drivers/bcma/driver_chipcommon_pmu.c
-@@ -80,6 +80,7 @@ static void bcma_pmu_resources_init(stru
+@@ -3,7 +3,8 @@
+  * ChipCommon Power Management Unit driver
+  *
+  * Copyright 2009, Michael Buesch <m@bues.ch>
+- * Copyright 2007, Broadcom Corporation
++ * Copyright 2007, 2011, Broadcom Corporation
++ * Copyright 2011, 2012, Hauke Mehrtens <hauke@hauke-m.de>
+  *
+  * Licensed under the GNU/GPL. See COPYING for details.
+  */
+@@ -54,38 +55,19 @@ void bcma_chipco_regctl_maskset(struct b
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_regctl_maskset);
+ 
+-static void bcma_pmu_pll_init(struct bcma_drv_cc *cc)
+-{
+-	struct bcma_bus *bus = cc->core->bus;
+-
+-	switch (bus->chipinfo.id) {
+-	case 0x4313:
+-	case 0x4331:
+-	case 43224:
+-	case 43225:
+-		break;
+-	default:
+-		pr_err("PLL init unknown for device 0x%04X\n",
+-			bus->chipinfo.id);
+-	}
+-}
+-
+ static void bcma_pmu_resources_init(struct bcma_drv_cc *cc)
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+ 	u32 min_msk = 0, max_msk = 0;
+ 
+ 	switch (bus->chipinfo.id) {
+-	case 0x4313:
++	case BCMA_CHIP_ID_BCM4313:
  		min_msk = 0x200D;
  		max_msk = 0xFFFF;
  		break;
-+	case 0x4331:
- 	case 43224:
- 	case 43225:
+-	case 43224:
+-	case 43225:
+-		break;
+ 	default:
+-		pr_err("PMU resource config unknown for device 0x%04X\n",
+-			bus->chipinfo.id);
++		bcma_debug(bus, "PMU resource config unknown or not needed for device 0x%04X\n",
++			   bus->chipinfo.id);
+ 	}
+ 
+ 	/* Set the resource masks. */
+@@ -93,22 +75,9 @@ static void bcma_pmu_resources_init(stru
+ 		bcma_cc_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);
+ 	if (max_msk)
+ 		bcma_cc_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);
+-}
+-
+-void bcma_pmu_swreg_init(struct bcma_drv_cc *cc)
+-{
+-	struct bcma_bus *bus = cc->core->bus;
+ 
+-	switch (bus->chipinfo.id) {
+-	case 0x4313:
+-	case 0x4331:
+-	case 43224:
+-	case 43225:
+-		break;
+-	default:
+-		pr_err("PMU switch/regulators init unknown for device "
+-			"0x%04X\n", bus->chipinfo.id);
+-	}
++	/* Add some delay; allow resources to come up and settle. */
++	mdelay(2);
+ }
+ 
+ /* Disable to allow reading SPROM. Don't know the adventages of enabling it. */
+@@ -122,8 +91,11 @@ void bcma_chipco_bcm4331_ext_pa_lines_ct
+ 		val |= BCMA_CHIPCTL_4331_EXTPA_EN;
+ 		if (bus->chipinfo.pkg == 9 || bus->chipinfo.pkg == 11)
+ 			val |= BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;
++		else if (bus->chipinfo.rev > 0)
++			val |= BCMA_CHIPCTL_4331_EXTPA_EN2;
+ 	} else {
+ 		val &= ~BCMA_CHIPCTL_4331_EXTPA_EN;
++		val &= ~BCMA_CHIPCTL_4331_EXTPA_EN2;
+ 		val &= ~BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;
+ 	}
+ 	bcma_cc_write32(cc, BCMA_CC_CHIPCTL, val);
+@@ -134,26 +106,38 @@ void bcma_pmu_workarounds(struct bcma_dr
+ 	struct bcma_bus *bus = cc->core->bus;
+ 
+ 	switch (bus->chipinfo.id) {
+-	case 0x4313:
+-		bcma_chipco_chipctl_maskset(cc, 0, ~0, 0x7);
++	case BCMA_CHIP_ID_BCM4313:
++		/* enable 12 mA drive strenth for 4313 and set chipControl
++		   register bit 1 */
++		bcma_chipco_chipctl_maskset(cc, 0,
++					    BCMA_CCTRL_4313_12MA_LED_DRIVE,
++					    BCMA_CCTRL_4313_12MA_LED_DRIVE);
  		break;
+-	case 0x4331:
+-		/* BCM4331 workaround is SPROM-related, we put it in sprom.c */
++	case BCMA_CHIP_ID_BCM4331:
++	case BCMA_CHIP_ID_BCM43431:
++		/* Ext PA lines must be enabled for tx on BCM4331 */
++		bcma_chipco_bcm4331_ext_pa_lines_ctl(cc, true);
+ 		break;
+-	case 43224:
++	case BCMA_CHIP_ID_BCM43224:
++	case BCMA_CHIP_ID_BCM43421:
++		/* enable 12 mA drive strenth for 43224 and set chipControl
++		   register bit 15 */
+ 		if (bus->chipinfo.rev == 0) {
+-			pr_err("Workarounds for 43224 rev 0 not fully "
+-				"implemented\n");
+-			bcma_chipco_chipctl_maskset(cc, 0, ~0, 0x00F000F0);
++			bcma_cc_maskset32(cc, BCMA_CC_CHIPCTL,
++					  BCMA_CCTRL_43224_GPIO_TOGGLE,
++					  BCMA_CCTRL_43224_GPIO_TOGGLE);
++			bcma_chipco_chipctl_maskset(cc, 0,
++						    BCMA_CCTRL_43224A0_12MA_LED_DRIVE,
++						    BCMA_CCTRL_43224A0_12MA_LED_DRIVE);
+ 		} else {
+-			bcma_chipco_chipctl_maskset(cc, 0, ~0, 0xF0);
++			bcma_chipco_chipctl_maskset(cc, 0,
++						    BCMA_CCTRL_43224B0_12MA_LED_DRIVE,
++						    BCMA_CCTRL_43224B0_12MA_LED_DRIVE);
+ 		}
+ 		break;
+-	case 43225:
+-		break;
+ 	default:
+-		pr_err("Workarounds unknown for device 0x%04X\n",
+-			bus->chipinfo.id);
++		bcma_debug(bus, "Workarounds unknown or not needed for device 0x%04X\n",
++			   bus->chipinfo.id);
+ 	}
+ }
+ 
+@@ -164,8 +148,8 @@ void bcma_pmu_init(struct bcma_drv_cc *c
+ 	pmucap = bcma_cc_read32(cc, BCMA_CC_PMU_CAP);
+ 	cc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);
+ 
+-	pr_debug("Found rev %u PMU (capabilities 0x%08X)\n", cc->pmu.rev,
+-		 pmucap);
++	bcma_debug(cc->core->bus, "Found rev %u PMU (capabilities 0x%08X)\n",
++		   cc->pmu.rev, pmucap);
+ 
+ 	if (cc->pmu.rev == 1)
+ 		bcma_cc_mask32(cc, BCMA_CC_PMU_CTL,
+@@ -174,12 +158,7 @@ void bcma_pmu_init(struct bcma_drv_cc *c
+ 		bcma_cc_set32(cc, BCMA_CC_PMU_CTL,
+ 			     BCMA_CC_PMU_CTL_NOILPONW);
+ 
+-	if (cc->core->id.id == 0x4329 && cc->core->id.rev == 2)
+-		pr_err("Fix for 4329b0 bad LPOM state not implemented!\n");
+-
+-	bcma_pmu_pll_init(cc);
+ 	bcma_pmu_resources_init(cc);
+-	bcma_pmu_swreg_init(cc);
+ 	bcma_pmu_workarounds(cc);
+ }
+ 
+@@ -188,23 +167,22 @@ u32 bcma_pmu_alp_clock(struct bcma_drv_c
+ 	struct bcma_bus *bus = cc->core->bus;
+ 
+ 	switch (bus->chipinfo.id) {
+-	case 0x4716:
+-	case 0x4748:
+-	case 47162:
+-	case 0x4313:
+-	case 0x5357:
+-	case 0x4749:
+-	case 53572:
++	case BCMA_CHIP_ID_BCM4716:
++	case BCMA_CHIP_ID_BCM4748:
++	case BCMA_CHIP_ID_BCM47162:
++	case BCMA_CHIP_ID_BCM4313:
++	case BCMA_CHIP_ID_BCM5357:
++	case BCMA_CHIP_ID_BCM4749:
++	case BCMA_CHIP_ID_BCM53572:
+ 		/* always 20Mhz */
+ 		return 20000 * 1000;
+-	case 0x5356:
+-	case 0x5300:
++	case BCMA_CHIP_ID_BCM5356:
++	case BCMA_CHIP_ID_BCM4706:
+ 		/* always 25Mhz */
+ 		return 25000 * 1000;
+ 	default:
+-		pr_warn("No ALP clock specified for %04X device, "
+-			"pmu rev. %d, using default %d Hz\n",
+-			bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);
++		bcma_warn(bus, "No ALP clock specified for %04X device, pmu rev. %d, using default %d Hz\n",
++			  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);
+ 	}
+ 	return BCMA_CC_PMU_ALP_CLOCK;
+ }
+@@ -221,7 +199,8 @@ static u32 bcma_pmu_clock(struct bcma_dr
+ 
+ 	BUG_ON(!m || m > 4);
+ 
+-	if (bus->chipinfo.id == 0x5357 || bus->chipinfo.id == 0x4749) {
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
++	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) {
+ 		/* Detect failure in clock setting */
+ 		tmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);
+ 		if (tmp & 0x40000)
+@@ -247,33 +226,62 @@ static u32 bcma_pmu_clock(struct bcma_dr
+ 	return (fc / div) * 1000000;
+ }
+ 
++static u32 bcma_pmu_clock_bcm4706(struct bcma_drv_cc *cc, u32 pll0, u32 m)
++{
++	u32 tmp, ndiv, p1div, p2div;
++	u32 clock;
++
++	BUG_ON(!m || m > 4);
++
++	/* Get N, P1 and P2 dividers to determine CPU clock */
++	tmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PMU6_4706_PROCPLL_OFF);
++	ndiv = (tmp & BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK)
++		>> BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT;
++	p1div = (tmp & BCMA_CC_PMU6_4706_PROC_P1DIV_MASK)
++		>> BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT;
++	p2div = (tmp & BCMA_CC_PMU6_4706_PROC_P2DIV_MASK)
++		>> BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT;
++
++	tmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);
++	if (tmp & BCMA_CC_CHIPST_4706_PKG_OPTION)
++		/* Low cost bonding: Fixed reference clock 25MHz and m = 4 */
++		clock = (25000000 / 4) * ndiv * p2div / p1div;
++	else
++		/* Fixed reference clock 25MHz and m = 2 */
++		clock = (25000000 / 2) * ndiv * p2div / p1div;
++
++	if (m == BCMA_CC_PMU5_MAINPLL_SSB)
++		clock = clock / 4;
++
++	return clock;
++}
++
+ /* query bus clock frequency for PMU-enabled chipcommon */
+ u32 bcma_pmu_get_clockcontrol(struct bcma_drv_cc *cc)
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+ 
+ 	switch (bus->chipinfo.id) {
+-	case 0x4716:
+-	case 0x4748:
+-	case 47162:
++	case BCMA_CHIP_ID_BCM4716:
++	case BCMA_CHIP_ID_BCM4748:
++	case BCMA_CHIP_ID_BCM47162:
+ 		return bcma_pmu_clock(cc, BCMA_CC_PMU4716_MAINPLL_PLL0,
+ 				      BCMA_CC_PMU5_MAINPLL_SSB);
+-	case 0x5356:
++	case BCMA_CHIP_ID_BCM5356:
+ 		return bcma_pmu_clock(cc, BCMA_CC_PMU5356_MAINPLL_PLL0,
+ 				      BCMA_CC_PMU5_MAINPLL_SSB);
+-	case 0x5357:
+-	case 0x4749:
++	case BCMA_CHIP_ID_BCM5357:
++	case BCMA_CHIP_ID_BCM4749:
+ 		return bcma_pmu_clock(cc, BCMA_CC_PMU5357_MAINPLL_PLL0,
+ 				      BCMA_CC_PMU5_MAINPLL_SSB);
+-	case 0x5300:
+-		return bcma_pmu_clock(cc, BCMA_CC_PMU4706_MAINPLL_PLL0,
+-				      BCMA_CC_PMU5_MAINPLL_SSB);
+-	case 53572:
++	case BCMA_CHIP_ID_BCM4706:
++		return bcma_pmu_clock_bcm4706(cc, BCMA_CC_PMU4706_MAINPLL_PLL0,
++					      BCMA_CC_PMU5_MAINPLL_SSB);
++	case BCMA_CHIP_ID_BCM53572:
+ 		return 75000000;
+ 	default:
+-		pr_warn("No backplane clock specified for %04X device, "
+-			"pmu rev. %d, using default %d Hz\n",
+-			bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);
++		bcma_warn(bus, "No backplane clock specified for %04X device, pmu rev. %d, using default %d Hz\n",
++			  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);
+ 	}
+ 	return BCMA_CC_PMU_HT_CLOCK;
+ }
+@@ -283,17 +291,21 @@ u32 bcma_pmu_get_clockcpu(struct bcma_dr
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+ 
+-	if (bus->chipinfo.id == 53572)
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM53572)
+ 		return 300000000;
+ 
+ 	if (cc->pmu.rev >= 5) {
+ 		u32 pll;
+ 		switch (bus->chipinfo.id) {
+-		case 0x5356:
++		case BCMA_CHIP_ID_BCM4706:
++			return bcma_pmu_clock_bcm4706(cc,
++						BCMA_CC_PMU4706_MAINPLL_PLL0,
++						BCMA_CC_PMU5_MAINPLL_CPU);
++		case BCMA_CHIP_ID_BCM5356:
+ 			pll = BCMA_CC_PMU5356_MAINPLL_PLL0;
+ 			break;
+-		case 0x5357:
+-		case 0x4749:
++		case BCMA_CHIP_ID_BCM5357:
++		case BCMA_CHIP_ID_BCM4749:
+ 			pll = BCMA_CC_PMU5357_MAINPLL_PLL0;
+ 			break;
+ 		default:
+@@ -301,10 +313,188 @@ u32 bcma_pmu_get_clockcpu(struct bcma_dr
+ 			break;
+ 		}
+ 
+-		/* TODO: if (bus->chipinfo.id == 0x5300)
+-		  return si_4706_pmu_clock(sih, osh, cc, PMU4706_MAINPLL_PLL0, PMU5_MAINPLL_CPU); */
+ 		return bcma_pmu_clock(cc, pll, BCMA_CC_PMU5_MAINPLL_CPU);
+ 	}
+ 
+ 	return bcma_pmu_get_clockcontrol(cc);
+ }
++
++static void bcma_pmu_spuravoid_pll_write(struct bcma_drv_cc *cc, u32 offset,
++					 u32 value)
++{
++	bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR, offset);
++	bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, value);
++}
++
++void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid)
++{
++	u32 tmp = 0;
++	u8 phypll_offset = 0;
++	u8 bcm5357_bcm43236_p1div[] = {0x1, 0x5, 0x5};
++	u8 bcm5357_bcm43236_ndiv[] = {0x30, 0xf6, 0xfc};
++	struct bcma_bus *bus = cc->core->bus;
++
++	switch (bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM5357:
++	case BCMA_CHIP_ID_BCM4749:
++	case BCMA_CHIP_ID_BCM53572:
++		/* 5357[ab]0, 43236[ab]0, and 6362b0 */
++
++		/* BCM5357 needs to touch PLL1_PLLCTL[02],
++		   so offset PLL0_PLLCTL[02] by 6 */
++		phypll_offset = (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
++		       bus->chipinfo.id == BCMA_CHIP_ID_BCM4749 ||
++		       bus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;
++
++		/* RMW only the P1 divider */
++		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
++				BCMA_CC_PMU_PLL_CTL0 + phypll_offset);
++		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
++		tmp &= (~(BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK));
++		tmp |= (bcm5357_bcm43236_p1div[spuravoid] << BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT);
++		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
++
++		/* RMW only the int feedback divider */
++		bcma_cc_write32(cc, BCMA_CC_PLLCTL_ADDR,
++				BCMA_CC_PMU_PLL_CTL2 + phypll_offset);
++		tmp = bcma_cc_read32(cc, BCMA_CC_PLLCTL_DATA);
++		tmp &= ~(BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK);
++		tmp |= (bcm5357_bcm43236_ndiv[spuravoid]) << BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT;
++		bcma_cc_write32(cc, BCMA_CC_PLLCTL_DATA, tmp);
++
++		tmp = 1 << 10;
++		break;
++
++	case BCMA_CHIP_ID_BCM4331:
++	case BCMA_CHIP_ID_BCM43431:
++		if (spuravoid == 2) {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11500014);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x0FC00a08);
++		} else if (spuravoid == 1) {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11500014);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x0F600a08);
++		} else {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11100014);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x03000a08);
++		}
++		tmp = 1 << 10;
++		break;
++
++	case BCMA_CHIP_ID_BCM43224:
++	case BCMA_CHIP_ID_BCM43225:
++	case BCMA_CHIP_ID_BCM43421:
++		if (spuravoid == 1) {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11500010);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x000C0C06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x0F600a08);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x2001E920);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		} else {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11100010);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x000c0c06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x03000a08);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x200005c0);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		}
++		tmp = 1 << 10;
++		break;
++
++	case BCMA_CHIP_ID_BCM4716:
++	case BCMA_CHIP_ID_BCM4748:
++	case BCMA_CHIP_ID_BCM47162:
++		if (spuravoid == 1) {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11500060);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x080C0C06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x0F600000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x2001E924);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		} else {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11100060);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x080c0c06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x03000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x200005c0);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		}
++
++		tmp = 3 << 9;
++		break;
++
++	case BCMA_CHIP_ID_BCM43227:
++	case BCMA_CHIP_ID_BCM43228:
++	case BCMA_CHIP_ID_BCM43428:
++		/* LCNXN */
++		/* PLL Settings for spur avoidance on/off mode,
++		   no on2 support for 43228A0 */
++		if (spuravoid == 1) {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x01100014);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x040C0C06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x03140A08);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00333333);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x202C2820);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		} else {
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,
++						     0x11100014);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,
++						     0x040c0c06);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,
++						     0x03000a08);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,
++						     0x00000000);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,
++						     0x200005c0);
++			bcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,
++						     0x88888815);
++		}
++		tmp = 1 << 10;
++		break;
++	default:
++		bcma_err(bus, "Unknown spuravoidance settings for chip 0x%04X, not changing PLL\n",
++			 bus->chipinfo.id);
++		break;
++	}
++
++	tmp |= bcma_cc_read32(cc, BCMA_CC_PMU_CTL);
++	bcma_cc_write32(cc, BCMA_CC_PMU_CTL, tmp);
++}
++EXPORT_SYMBOL_GPL(bcma_pmu_spuravoid_pllupdate);
+--- /dev/null
++++ b/drivers/bcma/driver_gmac_cmn.c
+@@ -0,0 +1,14 @@
++/*
++ * Broadcom specific AMBA
++ * GBIT MAC COMMON Core
++ *
++ * Licensed under the GNU/GPL. See COPYING for details.
++ */
++
++#include "bcma_private.h"
++#include <linux/bcma/bcma.h>
++
++void __devinit bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc)
++{
++	mutex_init(&gc->phy_mutex);
++}
+--- a/drivers/bcma/driver_mips.c
++++ b/drivers/bcma/driver_mips.c
+@@ -22,15 +22,15 @@
+ /* The 47162a0 hangs when reading MIPS DMP registers registers */
+ static inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)
+ {
+-	return dev->bus->chipinfo.id == 47162 && dev->bus->chipinfo.rev == 0 &&
+-	       dev->id.id == BCMA_CORE_MIPS_74K;
++	return dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM47162 &&
++	       dev->bus->chipinfo.rev == 0 && dev->id.id == BCMA_CORE_MIPS_74K;
+ }
+ 
+ /* The 5357b0 hangs when reading USB20H DMP registers */
+ static inline bool bcma_core_mips_bcm5357b0_quirk(struct bcma_device *dev)
+ {
+-	return (dev->bus->chipinfo.id == 0x5357 ||
+-		dev->bus->chipinfo.id == 0x4749) &&
++	return (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||
++		dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) &&
+ 	       dev->bus->chipinfo.pkg == 11 &&
+ 	       dev->id.id == BCMA_CORE_USB20_HOST;
+ }
+@@ -143,8 +143,8 @@ static void bcma_core_mips_set_irq(struc
+ 			     1 << irqflag);
+ 	}
+ 
+-	pr_info("set_irq: core 0x%04x, irq %d => %d\n",
+-		dev->id.id, oldirq + 2, irq + 2);
++	bcma_info(bus, "set_irq: core 0x%04x, irq %d => %d\n",
++		  dev->id.id, oldirq + 2, irq + 2);
+ }
+ 
+ static void bcma_core_mips_print_irq(struct bcma_device *dev, unsigned int irq)
+@@ -173,7 +173,7 @@ u32 bcma_cpu_clock(struct bcma_drv_mips
+ 	if (bus->drv_cc.capabilities & BCMA_CC_CAP_PMU)
+ 		return bcma_pmu_get_clockcpu(&bus->drv_cc);
+ 
+-	pr_err("No PMU available, need this to get the cpu clock\n");
++	bcma_err(bus, "No PMU available, need this to get the cpu clock\n");
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bcma_cpu_clock);
+@@ -185,10 +185,10 @@ static void bcma_core_mips_flash_detect(
+ 	switch (bus->drv_cc.capabilities & BCMA_CC_CAP_FLASHT) {
+ 	case BCMA_CC_FLASHT_STSER:
+ 	case BCMA_CC_FLASHT_ATSER:
+-		pr_err("Serial flash not supported.\n");
++		bcma_err(bus, "Serial flash not supported.\n");
+ 		break;
+ 	case BCMA_CC_FLASHT_PARA:
+-		pr_info("found parallel flash.\n");
++		bcma_info(bus, "found parallel flash.\n");
+ 		bus->drv_cc.pflash.window = 0x1c000000;
+ 		bus->drv_cc.pflash.window_size = 0x02000000;
+ 
+@@ -199,7 +199,7 @@ static void bcma_core_mips_flash_detect(
+ 			bus->drv_cc.pflash.buswidth = 2;
+ 		break;
+ 	default:
+-		pr_err("flash not supported.\n");
++		bcma_err(bus, "flash not supported.\n");
+ 	}
+ }
+ 
+@@ -209,7 +209,7 @@ void bcma_core_mips_init(struct bcma_drv
+ 	struct bcma_device *core;
+ 	bus = mcore->core->bus;
+ 
+-	pr_info("Initializing MIPS core...\n");
++	bcma_info(bus, "Initializing MIPS core...\n");
+ 
+ 	if (!mcore->setup_done)
+ 		mcore->assigned_irqs = 1;
+@@ -244,7 +244,7 @@ void bcma_core_mips_init(struct bcma_drv
+ 			break;
+ 		}
+ 	}
+-	pr_info("IRQ reconfiguration done\n");
++	bcma_info(bus, "IRQ reconfiguration done\n");
+ 	bcma_core_mips_dump_irq(bus);
+ 
+ 	if (mcore->setup_done)
 --- a/drivers/bcma/driver_pci.c
 +++ b/drivers/bcma/driver_pci.c
 @@ -2,8 +2,9 @@
@@ -57,7 +756,7 @@
   *
   * Licensed under the GNU/GPL. See COPYING for details.
   */
-@@ -16,40 +17,41 @@
+@@ -16,40 +17,39 @@
   * R/W ops.
   **************************************************/
  
@@ -72,7 +771,7 @@
 +	return pcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_DATA);
  }
  
- #if 0
+-#if 0
  static void bcma_pcie_write(struct bcma_drv_pci *pc, u32 address, u32 data)
  {
 -	pcicore_write32(pc, 0x130, address);
@@ -82,7 +781,7 @@
 +	pcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_ADDR);
 +	pcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_DATA, data);
  }
- #endif
+-#endif
  
  static void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u8 phy)
  {
@@ -115,7 +814,7 @@
  			break;
  		msleep(1);
  	}
-@@ -57,79 +59,84 @@ static void bcma_pcie_mdio_set_phy(struc
+@@ -57,79 +57,84 @@ static void bcma_pcie_mdio_set_phy(struc
  
  static u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u8 device, u8 address)
  {
@@ -231,7 +930,7 @@
  }
  
  /**************************************************
-@@ -138,72 +145,53 @@ static void bcma_pcie_mdio_write(struct
+@@ -138,88 +143,108 @@ static void bcma_pcie_mdio_write(struct
  
  static u8 bcma_pcicore_polarity_workaround(struct bcma_drv_pci *pc)
  {
@@ -266,6 +965,41 @@
 +		bcma_pcie_mdio_write(pc, BCMA_CORE_PCI_MDIODATA_DEV_PLL,
 +		                     BCMA_CORE_PCI_SERDES_PLL_CTRL,
 +		                     tmp & ~BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN);
++}
++
++static void bcma_core_pci_fixcfg(struct bcma_drv_pci *pc)
++{
++	struct bcma_device *core = pc->core;
++	u16 val16, core_index;
++	uint regoff;
++
++	regoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_PI_OFFSET);
++	core_index = (u16)core->core_index;
++
++	val16 = pcicore_read16(pc, regoff);
++	if (((val16 & BCMA_CORE_PCI_SPROM_PI_MASK) >> BCMA_CORE_PCI_SPROM_PI_SHIFT)
++	     != core_index) {
++		val16 = (core_index << BCMA_CORE_PCI_SPROM_PI_SHIFT) |
++			(val16 & ~BCMA_CORE_PCI_SPROM_PI_MASK);
++		pcicore_write16(pc, regoff, val16);
++	}
++}
++
++/* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
++/* Needs to happen when coming out of 'standby'/'hibernate' */
++static void bcma_core_pci_config_fixup(struct bcma_drv_pci *pc)
++{
++	u16 val16;
++	uint regoff;
++
++	regoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_MISC_CONFIG);
++
++	val16 = pcicore_read16(pc, regoff);
++
++	if (!(val16 & BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST)) {
++		val16 |= BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST;
++		pcicore_write16(pc, regoff, val16);
++	}
  }
  
  /**************************************************
@@ -275,7 +1009,9 @@
 -static void bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)
 +static void __devinit bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)
  {
++	bcma_core_pci_fixcfg(pc);
  	bcma_pcicore_serdes_workaround(pc);
++	bcma_core_pci_config_fixup(pc);
  }
  
 -static bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)
@@ -327,9 +1063,47 @@
  }
  
  int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc, struct bcma_device *core,
+ 			  bool enable)
+ {
+-	struct pci_dev *pdev = pc->core->bus->host_pci;
++	struct pci_dev *pdev;
+ 	u32 coremask, tmp;
+ 	int err = 0;
+ 
+-	if (core->bus->hosttype != BCMA_HOSTTYPE_PCI) {
++	if (!pc || core->bus->hosttype != BCMA_HOSTTYPE_PCI) {
+ 		/* This bcma device is not on a PCI host-bus. So the IRQs are
+ 		 * not routed through the PCI core.
+ 		 * So we must not enable routing through the PCI core. */
+ 		goto out;
+ 	}
+ 
++	pdev = pc->core->bus->host_pci;
++
+ 	err = pci_read_config_dword(pdev, BCMA_PCI_IRQMASK, &tmp);
+ 	if (err)
+ 		goto out;
+@@ -236,3 +261,17 @@ out:
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(bcma_core_pci_irq_ctl);
++
++void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)
++{
++	u32 w;
++
++	w = bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);
++	if (extend)
++		w |= BCMA_CORE_PCI_ASPMTIMER_EXTEND;
++	else
++		w &= ~BCMA_CORE_PCI_ASPMTIMER_EXTEND;
++	bcma_pcie_write(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG, w);
++	bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);
++}
++EXPORT_SYMBOL_GPL(bcma_core_pci_extend_L1timer);
 --- a/drivers/bcma/driver_pci_host.c
 +++ b/drivers/bcma/driver_pci_host.c
-@@ -2,13 +2,588 @@
+@@ -2,13 +2,592 @@
   * Broadcom specific AMBA
   * PCI Core in hostmode
   *
@@ -367,7 +1141,7 @@
 +		return false;
 +
 +	if (bus->sprom.boardflags_lo & BCMA_CORE_PCI_BFL_NOPCI) {
-+		pr_info("This PCI core is disabled and not working\n");
++		bcma_info(bus, "This PCI core is disabled and not working\n");
 +		return false;
 +	}
 +
@@ -452,7 +1226,7 @@
 +		if (unlikely(!addr))
 +			goto out;
 +		err = -ENOMEM;
-+		mmio = ioremap_nocache(addr, len);
++		mmio = ioremap_nocache(addr, sizeof(val));
 +		if (!mmio)
 +			goto out;
 +
@@ -504,7 +1278,7 @@
 +			addr = pc->core->addr + BCMA_CORE_PCI_PCICFG0;
 +			addr |= (func << 8);
 +			addr |= (off & 0xfc);
-+			mmio = ioremap_nocache(addr, len);
++			mmio = ioremap_nocache(addr, sizeof(val));
 +			if (!mmio)
 +				goto out;
 +		}
@@ -513,7 +1287,7 @@
 +		if (unlikely(!addr))
 +			goto out;
 +		err = -ENOMEM;
-+		mmio = ioremap_nocache(addr, len);
++		mmio = ioremap_nocache(addr, sizeof(val));
 +		if (!mmio)
 +			goto out;
 +
@@ -548,7 +1322,8 @@
 +	} else {
 +		writel(val, mmio);
 +
-+		if (chipid == 0x4716 || chipid == 0x4748)
++		if (chipid == BCMA_CHIP_ID_BCM4716 ||
++		    chipid == BCMA_CHIP_ID_BCM4748)
 +			readl(mmio);
 +	}
 +
@@ -673,6 +1448,7 @@
 + */
 +static void __devinit bcma_core_pci_enable_crs(struct bcma_drv_pci *pc)
 +{
++	struct bcma_bus *bus = pc->core->bus;
 +	u8 cap_ptr, root_ctrl, root_cap, dev;
 +	u16 val16;
 +	int i;
@@ -711,7 +1487,8 @@
 +				udelay(10);
 +			}
 +			if (val16 == 0x1)
-+				pr_err("PCI: Broken device in slot %d\n", dev);
++				bcma_err(bus, "PCI: Broken device in slot %d\n",
++					 dev);
 +		}
 +	}
 +}
@@ -724,11 +1501,11 @@
 +	u32 pci_membase_1G;
 +	unsigned long io_map_base;
 +
-+	pr_info("PCIEcore in host mode found\n");
++	bcma_info(bus, "PCIEcore in host mode found\n");
 +
 +	pc_host = kzalloc(sizeof(*pc_host), GFP_KERNEL);
 +	if (!pc_host)  {
-+		pr_err("can not allocate memory");
++		bcma_err(bus, "can not allocate memory");
 +		return;
 +	}
 +
@@ -767,13 +1544,14 @@
 +	 * as mips can't generate 64-bit address on the
 +	 * backplane.
 +	 */
-+	if (bus->chipinfo.id == 0x4716 || bus->chipinfo.id == 0x4748) {
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4716 ||
++	    bus->chipinfo.id == BCMA_CHIP_ID_BCM4748) {
 +		pc_host->mem_resource.start = BCMA_SOC_PCI_MEM;
 +		pc_host->mem_resource.end = BCMA_SOC_PCI_MEM +
 +					    BCMA_SOC_PCI_MEM_SZ - 1;
 +		pcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,
 +				BCMA_CORE_PCI_SBTOPCI_MEM | BCMA_SOC_PCI_MEM);
-+	} else if (bus->chipinfo.id == 0x5300) {
++	} else if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {
 +		tmp = BCMA_CORE_PCI_SBTOPCI_MEM;
 +		tmp |= BCMA_CORE_PCI_SBTOPCI_PREF;
 +		tmp |= BCMA_CORE_PCI_SBTOPCI_BURST;
@@ -824,8 +1602,8 @@
 +	/* Ok, ready to run, register it to the system.
 +	 * The following needs change, if we want to port hostmode
 +	 * to non-MIPS platform. */
-+	io_map_base = (unsigned long)ioremap_nocache(BCMA_SOC_PCI_MEM,
-+						     0x04000000);
++	io_map_base = (unsigned long)ioremap_nocache(pc_host->mem_resource.start,
++						     resource_size(&pc_host->mem_resource));
 +	pc_host->pci_controller.io_map_base = io_map_base;
 +	set_io_port_base(pc_host->pci_controller.io_map_base);
 +	/* Give some time to the PCI controller to configure itself with the new
@@ -922,6 +1700,15 @@
 +EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq);
 --- a/drivers/bcma/host_pci.c
 +++ b/drivers/bcma/host_pci.c
+@@ -18,7 +18,7 @@ static void bcma_host_pci_switch_core(st
+ 	pci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN2,
+ 			       core->wrap);
+ 	core->bus->mapped_core = core;
+-	pr_debug("Switched to core: 0x%X\n", core->id.id);
++	bcma_debug(core->bus, "Switched to core: 0x%X\n", core->id.id);
+ }
+ 
+ /* Provides access to the requested core. Returns base offset that has to be
 @@ -154,8 +154,8 @@ const struct bcma_host_ops bcma_host_pci
  	.awrite32	= bcma_host_pci_awrite32,
  };
@@ -933,6 +1720,51 @@
  {
  	struct bcma_bus *bus;
  	int err = -ENOMEM;
+@@ -188,7 +188,7 @@ static int bcma_host_pci_probe(struct pc
+ 
+ 	/* SSB needed additional powering up, do we have any AMBA PCI cards? */
+ 	if (!pci_is_pcie(dev))
+-		pr_err("PCI card detected, report problems.\n");
++		bcma_err(bus, "PCI card detected, report problems.\n");
+ 
+ 	/* Map MMIO */
+ 	err = -ENOMEM;
+@@ -201,6 +201,9 @@ static int bcma_host_pci_probe(struct pc
+ 	bus->hosttype = BCMA_HOSTTYPE_PCI;
+ 	bus->ops = &bcma_host_pci_ops;
+ 
++	bus->boardinfo.vendor = bus->host_pci->subsystem_vendor;
++	bus->boardinfo.type = bus->host_pci->subsystem_device;
++
+ 	/* Register */
+ 	err = bcma_bus_register(bus);
+ 	if (err)
+@@ -222,7 +225,7 @@ err_kfree_bus:
+ 	return err;
+ }
+ 
+-static void bcma_host_pci_remove(struct pci_dev *dev)
++static void __devexit bcma_host_pci_remove(struct pci_dev *dev)
+ {
+ 	struct bcma_bus *bus = pci_get_drvdata(dev);
+ 
+@@ -265,6 +268,7 @@ static SIMPLE_DEV_PM_OPS(bcma_pm_ops, bc
+ 
+ static DEFINE_PCI_DEVICE_TABLE(bcma_pci_bridge_tbl) = {
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x0576) },
++	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43224) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4331) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4353) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4357) },
+@@ -277,7 +281,7 @@ static struct pci_driver bcma_pci_bridge
+ 	.name = "bcma-pci-bridge",
+ 	.id_table = bcma_pci_bridge_tbl,
+ 	.probe = bcma_host_pci_probe,
+-	.remove = bcma_host_pci_remove,
++	.remove = __devexit_p(bcma_host_pci_remove),
+ 	.driver.pm = BCMA_PM_OPS,
+ };
+ 
 --- a/drivers/bcma/main.c
 +++ b/drivers/bcma/main.c
 @@ -13,6 +13,12 @@
@@ -948,16 +1780,23 @@
  static int bcma_bus_match(struct device *dev, struct device_driver *drv);
  static int bcma_device_probe(struct device *dev);
  static int bcma_device_remove(struct device *dev);
-@@ -55,7 +61,7 @@ static struct bus_type bcma_bus_type = {
+@@ -55,7 +61,14 @@ static struct bus_type bcma_bus_type = {
  	.dev_attrs	= bcma_device_attrs,
  };
  
 -static struct bcma_device *bcma_find_core(struct bcma_bus *bus, u16 coreid)
++static u16 bcma_cc_core_id(struct bcma_bus *bus)
++{
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)
++		return BCMA_CORE_4706_CHIPCOMMON;
++	return BCMA_CORE_CHIPCOMMON;
++}
++
 +struct bcma_device *bcma_find_core(struct bcma_bus *bus, u16 coreid)
  {
  	struct bcma_device *core;
  
-@@ -65,6 +71,7 @@ static struct bcma_device *bcma_find_cor
+@@ -65,6 +78,7 @@ static struct bcma_device *bcma_find_cor
  	}
  	return NULL;
  }
@@ -965,7 +1804,18 @@
  
  static void bcma_release_core_dev(struct device *dev)
  {
-@@ -93,7 +100,7 @@ static int bcma_register_cores(struct bc
+@@ -84,16 +98,18 @@ static int bcma_register_cores(struct bc
+ 	list_for_each_entry(core, &bus->cores, list) {
+ 		/* We support that cores ourself */
+ 		switch (core->id.id) {
++		case BCMA_CORE_4706_CHIPCOMMON:
+ 		case BCMA_CORE_CHIPCOMMON:
+ 		case BCMA_CORE_PCI:
+ 		case BCMA_CORE_PCIE:
+ 		case BCMA_CORE_MIPS_74K:
++		case BCMA_CORE_4706_MAC_GBIT_COMMON:
+ 			continue;
+ 		}
  
  		core->dev.release = bcma_release_core_dev;
  		core->dev.bus = &bcma_bus_type;
@@ -974,7 +1824,19 @@
  
  		switch (bus->hosttype) {
  		case BCMA_HOSTTYPE_PCI:
-@@ -132,11 +139,15 @@ static void bcma_unregister_cores(struct
+@@ -111,8 +127,9 @@ static int bcma_register_cores(struct bc
+ 
+ 		err = device_register(&core->dev);
+ 		if (err) {
+-			pr_err("Could not register dev for core 0x%03X\n",
+-			       core->id.id);
++			bcma_err(bus,
++				 "Could not register dev for core 0x%03X\n",
++				 core->id.id);
+ 			continue;
+ 		}
+ 		core->dev_registered = true;
+@@ -132,20 +149,24 @@ static void bcma_unregister_cores(struct
  	}
  }
  
@@ -991,9 +1853,202 @@
  	/* Scan for devices (cores) */
  	err = bcma_bus_scan(bus);
  	if (err) {
+-		pr_err("Failed to scan: %d\n", err);
++		bcma_err(bus, "Failed to scan: %d\n", err);
+ 		return -1;
+ 	}
+ 
+ 	/* Init CC core */
+-	core = bcma_find_core(bus, BCMA_CORE_CHIPCOMMON);
++	core = bcma_find_core(bus, bcma_cc_core_id(bus));
+ 	if (core) {
+ 		bus->drv_cc.core = core;
+ 		bcma_core_chipcommon_init(&bus->drv_cc);
+@@ -165,17 +186,24 @@ int bcma_bus_register(struct bcma_bus *b
+ 		bcma_core_pci_init(&bus->drv_pci);
+ 	}
+ 
++	/* Init GBIT MAC COMMON core */
++	core = bcma_find_core(bus, BCMA_CORE_4706_MAC_GBIT_COMMON);
++	if (core) {
++		bus->drv_gmac_cmn.core = core;
++		bcma_core_gmac_cmn_init(&bus->drv_gmac_cmn);
++	}
++
+ 	/* Try to get SPROM */
+ 	err = bcma_sprom_get(bus);
+ 	if (err == -ENOENT) {
+-		pr_err("No SPROM available\n");
++		bcma_err(bus, "No SPROM available\n");
+ 	} else if (err)
+-		pr_err("Failed to get SPROM: %d\n", err);
++		bcma_err(bus, "Failed to get SPROM: %d\n", err);
+ 
+ 	/* Register found cores */
+ 	bcma_register_cores(bus);
+ 
+-	pr_info("Bus registered\n");
++	bcma_info(bus, "Bus registered\n");
+ 
+ 	return 0;
+ }
+@@ -196,14 +224,14 @@ int __init bcma_bus_early_register(struc
+ 	bcma_init_bus(bus);
+ 
+ 	match.manuf = BCMA_MANUF_BCM;
+-	match.id = BCMA_CORE_CHIPCOMMON;
++	match.id = bcma_cc_core_id(bus);
+ 	match.class = BCMA_CL_SIM;
+ 	match.rev = BCMA_ANY_REV;
+ 
+ 	/* Scan for chip common core */
+ 	err = bcma_bus_scan_early(bus, &match, core_cc);
+ 	if (err) {
+-		pr_err("Failed to scan for common core: %d\n", err);
++		bcma_err(bus, "Failed to scan for common core: %d\n", err);
+ 		return -1;
+ 	}
+ 
+@@ -215,12 +243,12 @@ int __init bcma_bus_early_register(struc
+ 	/* Scan for mips core */
+ 	err = bcma_bus_scan_early(bus, &match, core_mips);
+ 	if (err) {
+-		pr_err("Failed to scan for mips core: %d\n", err);
++		bcma_err(bus, "Failed to scan for mips core: %d\n", err);
+ 		return -1;
+ 	}
+ 
+ 	/* Init CC core */
+-	core = bcma_find_core(bus, BCMA_CORE_CHIPCOMMON);
++	core = bcma_find_core(bus, bcma_cc_core_id(bus));
+ 	if (core) {
+ 		bus->drv_cc.core = core;
+ 		bcma_core_chipcommon_init(&bus->drv_cc);
+@@ -233,7 +261,7 @@ int __init bcma_bus_early_register(struc
+ 		bcma_core_mips_init(&bus->drv_mips);
+ 	}
+ 
+-	pr_info("Early bus registered\n");
++	bcma_info(bus, "Early bus registered\n");
+ 
+ 	return 0;
+ }
+@@ -259,8 +287,7 @@ int bcma_bus_resume(struct bcma_bus *bus
+ 	struct bcma_device *core;
+ 
+ 	/* Init CC core */
+-	core = bcma_find_core(bus, BCMA_CORE_CHIPCOMMON);
+-	if (core) {
++	if (bus->drv_cc.core) {
+ 		bus->drv_cc.setup_done = false;
+ 		bcma_core_chipcommon_init(&bus->drv_cc);
+ 	}
 --- a/drivers/bcma/scan.c
 +++ b/drivers/bcma/scan.c
-@@ -212,6 +212,17 @@ static struct bcma_device *bcma_find_cor
+@@ -19,15 +19,27 @@ struct bcma_device_id_name {
+ 	u16 id;
+ 	const char *name;
+ };
+-struct bcma_device_id_name bcma_device_names[] = {
++
++static const struct bcma_device_id_name bcma_arm_device_names[] = {
++	{ BCMA_CORE_4706_MAC_GBIT_COMMON, "BCM4706 GBit MAC Common" },
++	{ BCMA_CORE_ARM_1176, "ARM 1176" },
++	{ BCMA_CORE_ARM_7TDMI, "ARM 7TDMI" },
++	{ BCMA_CORE_ARM_CM3, "ARM CM3" },
++};
++
++static const struct bcma_device_id_name bcma_bcm_device_names[] = {
+ 	{ BCMA_CORE_OOB_ROUTER, "OOB Router" },
++	{ BCMA_CORE_4706_CHIPCOMMON, "BCM4706 ChipCommon" },
++	{ BCMA_CORE_4706_SOC_RAM, "BCM4706 SOC RAM" },
++	{ BCMA_CORE_4706_MAC_GBIT, "BCM4706 GBit MAC" },
++	{ BCMA_CORE_AMEMC, "AMEMC (DDR)" },
++	{ BCMA_CORE_ALTA, "ALTA (I2S)" },
+ 	{ BCMA_CORE_INVALID, "Invalid" },
+ 	{ BCMA_CORE_CHIPCOMMON, "ChipCommon" },
+ 	{ BCMA_CORE_ILINE20, "ILine 20" },
+ 	{ BCMA_CORE_SRAM, "SRAM" },
+ 	{ BCMA_CORE_SDRAM, "SDRAM" },
+ 	{ BCMA_CORE_PCI, "PCI" },
+-	{ BCMA_CORE_MIPS, "MIPS" },
+ 	{ BCMA_CORE_ETHERNET, "Fast Ethernet" },
+ 	{ BCMA_CORE_V90, "V90" },
+ 	{ BCMA_CORE_USB11_HOSTDEV, "USB 1.1 Hostdev" },
+@@ -44,7 +56,6 @@ struct bcma_device_id_name bcma_device_n
+ 	{ BCMA_CORE_PHY_A, "PHY A" },
+ 	{ BCMA_CORE_PHY_B, "PHY B" },
+ 	{ BCMA_CORE_PHY_G, "PHY G" },
+-	{ BCMA_CORE_MIPS_3302, "MIPS 3302" },
+ 	{ BCMA_CORE_USB11_HOST, "USB 1.1 Host" },
+ 	{ BCMA_CORE_USB11_DEV, "USB 1.1 Device" },
+ 	{ BCMA_CORE_USB20_HOST, "USB 2.0 Host" },
+@@ -58,15 +69,11 @@ struct bcma_device_id_name bcma_device_n
+ 	{ BCMA_CORE_PHY_N, "PHY N" },
+ 	{ BCMA_CORE_SRAM_CTL, "SRAM Controller" },
+ 	{ BCMA_CORE_MINI_MACPHY, "Mini MACPHY" },
+-	{ BCMA_CORE_ARM_1176, "ARM 1176" },
+-	{ BCMA_CORE_ARM_7TDMI, "ARM 7TDMI" },
+ 	{ BCMA_CORE_PHY_LP, "PHY LP" },
+ 	{ BCMA_CORE_PMU, "PMU" },
+ 	{ BCMA_CORE_PHY_SSN, "PHY SSN" },
+ 	{ BCMA_CORE_SDIO_DEV, "SDIO Device" },
+-	{ BCMA_CORE_ARM_CM3, "ARM CM3" },
+ 	{ BCMA_CORE_PHY_HT, "PHY HT" },
+-	{ BCMA_CORE_MIPS_74K, "MIPS 74K" },
+ 	{ BCMA_CORE_MAC_GBIT, "GBit MAC" },
+ 	{ BCMA_CORE_DDR12_MEM_CTL, "DDR1/DDR2 Memory Controller" },
+ 	{ BCMA_CORE_PCIE_RC, "PCIe Root Complex" },
+@@ -79,16 +86,41 @@ struct bcma_device_id_name bcma_device_n
+ 	{ BCMA_CORE_SHIM, "SHIM" },
+ 	{ BCMA_CORE_DEFAULT, "Default" },
+ };
+-const char *bcma_device_name(struct bcma_device_id *id)
++
++static const struct bcma_device_id_name bcma_mips_device_names[] = {
++	{ BCMA_CORE_MIPS, "MIPS" },
++	{ BCMA_CORE_MIPS_3302, "MIPS 3302" },
++	{ BCMA_CORE_MIPS_74K, "MIPS 74K" },
++};
++
++static const char *bcma_device_name(const struct bcma_device_id *id)
+ {
+-	int i;
++	const struct bcma_device_id_name *names;
++	int size, i;
+ 
+-	if (id->manuf == BCMA_MANUF_BCM) {
+-		for (i = 0; i < ARRAY_SIZE(bcma_device_names); i++) {
+-			if (bcma_device_names[i].id == id->id)
+-				return bcma_device_names[i].name;
+-		}
++	/* search manufacturer specific names */
++	switch (id->manuf) {
++	case BCMA_MANUF_ARM:
++		names = bcma_arm_device_names;
++		size = ARRAY_SIZE(bcma_arm_device_names);
++		break;
++	case BCMA_MANUF_BCM:
++		names = bcma_bcm_device_names;
++		size = ARRAY_SIZE(bcma_bcm_device_names);
++		break;
++	case BCMA_MANUF_MIPS:
++		names = bcma_mips_device_names;
++		size = ARRAY_SIZE(bcma_mips_device_names);
++		break;
++	default:
++		return "UNKNOWN";
++	}
++
++	for (i = 0; i < size; i++) {
++		if (names[i].id == id->id)
++			return names[i].name;
+ 	}
++
+ 	return "UNKNOWN";
+ }
+ 
+@@ -212,6 +244,17 @@ static struct bcma_device *bcma_find_cor
  	return NULL;
  }
  
@@ -1011,7 +2066,61 @@
  static int bcma_get_next_core(struct bcma_bus *bus, u32 __iomem **eromptr,
  			      struct bcma_device_id *match, int core_num,
  			      struct bcma_device *core)
-@@ -353,6 +364,7 @@ static int bcma_get_next_core(struct bcm
+@@ -252,11 +295,15 @@ static int bcma_get_next_core(struct bcm
+ 
+ 	/* check if component is a core at all */
+ 	if (wrappers[0] + wrappers[1] == 0) {
+-		/* we could save addrl of the router
+-		if (cid == BCMA_CORE_OOB_ROUTER)
+-		 */
+-		bcma_erom_skip_component(bus, eromptr);
+-		return -ENXIO;
++		/* Some specific cores don't need wrappers */
++		switch (core->id.id) {
++		case BCMA_CORE_4706_MAC_GBIT_COMMON:
++		/* Not used yet: case BCMA_CORE_OOB_ROUTER: */
++			break;
++		default:
++			bcma_erom_skip_component(bus, eromptr);
++			return -ENXIO;
++		}
+ 	}
+ 
+ 	if (bcma_erom_is_bridge(bus, eromptr)) {
+@@ -286,6 +333,23 @@ static int bcma_get_next_core(struct bcm
+ 			return -EILSEQ;
+ 	}
+ 
++	/* First Slave Address Descriptor should be port 0:
++	 * the main register space for the core
++	 */
++	tmp = bcma_erom_get_addr_desc(bus, eromptr, SCAN_ADDR_TYPE_SLAVE, 0);
++	if (tmp <= 0) {
++		/* Try again to see if it is a bridge */
++		tmp = bcma_erom_get_addr_desc(bus, eromptr,
++					      SCAN_ADDR_TYPE_BRIDGE, 0);
++		if (tmp <= 0) {
++			return -EILSEQ;
++		} else {
++			bcma_info(bus, "Bridge found\n");
++			return -ENXIO;
++		}
++	}
++	core->addr = tmp;
++
+ 	/* get & parse slave ports */
+ 	for (i = 0; i < ports[1]; i++) {
+ 		for (j = 0; ; j++) {
+@@ -298,7 +362,7 @@ static int bcma_get_next_core(struct bcm
+ 				break;
+ 			} else {
+ 				if (i == 0 && j == 0)
+-					core->addr = tmp;
++					core->addr1 = tmp;
+ 			}
+ 		}
+ 	}
+@@ -353,6 +417,7 @@ static int bcma_get_next_core(struct bcm
  void bcma_init_bus(struct bcma_bus *bus)
  {
  	s32 tmp;
@@ -1019,7 +2128,7 @@
  
  	if (bus->init_done)
  		return;
-@@ -363,9 +375,12 @@ void bcma_init_bus(struct bcma_bus *bus)
+@@ -363,9 +428,12 @@ void bcma_init_bus(struct bcma_bus *bus)
  	bcma_scan_switch_core(bus, BCMA_ADDR_BASE);
  
  	tmp = bcma_scan_read32(bus, 0, BCMA_CC_ID);
@@ -1029,13 +2138,13 @@
 +	chipinfo->id = (tmp & BCMA_CC_ID_ID) >> BCMA_CC_ID_ID_SHIFT;
 +	chipinfo->rev = (tmp & BCMA_CC_ID_REV) >> BCMA_CC_ID_REV_SHIFT;
 +	chipinfo->pkg = (tmp & BCMA_CC_ID_PKG) >> BCMA_CC_ID_PKG_SHIFT;
-+	pr_info("Found chip with id 0x%04X, rev 0x%02X and package 0x%02X\n",
-+		chipinfo->id, chipinfo->rev, chipinfo->pkg);
++	bcma_info(bus, "Found chip with id 0x%04X, rev 0x%02X and package 0x%02X\n",
++		  chipinfo->id, chipinfo->rev, chipinfo->pkg);
 +
  	bus->init_done = true;
  }
  
-@@ -392,6 +407,7 @@ int bcma_bus_scan(struct bcma_bus *bus)
+@@ -392,6 +460,7 @@ int bcma_bus_scan(struct bcma_bus *bus)
  	bcma_scan_switch_core(bus, erombase);
  
  	while (eromptr < eromend) {
@@ -1043,15 +2152,58 @@
  		struct bcma_device *core = kzalloc(sizeof(*core), GFP_KERNEL);
  		if (!core)
  			return -ENOMEM;
-@@ -414,6 +430,8 @@ int bcma_bus_scan(struct bcma_bus *bus)
+@@ -414,14 +483,15 @@ int bcma_bus_scan(struct bcma_bus *bus)
  
  		core->core_index = core_num++;
  		bus->nr_cores++;
 +		other_core = bcma_find_core_reverse(bus, core->id.id);
 +		core->core_unit = (other_core == NULL) ? 0 : other_core->core_unit + 1;
  
- 		pr_info("Core %d found: %s "
- 			"(manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
+-		pr_info("Core %d found: %s "
+-			"(manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
+-			core->core_index, bcma_device_name(&core->id),
+-			core->id.manuf, core->id.id, core->id.rev,
+-			core->id.class);
++		bcma_info(bus, "Core %d found: %s (manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
++			  core->core_index, bcma_device_name(&core->id),
++			  core->id.manuf, core->id.id, core->id.rev,
++			  core->id.class);
+ 
+-		list_add(&core->list, &bus->cores);
++		list_add_tail(&core->list, &bus->cores);
+ 	}
+ 
+ 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
+@@ -471,13 +541,12 @@ int __init bcma_bus_scan_early(struct bc
+ 
+ 		core->core_index = core_num++;
+ 		bus->nr_cores++;
+-		pr_info("Core %d found: %s "
+-			"(manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
+-			core->core_index, bcma_device_name(&core->id),
+-			core->id.manuf, core->id.id, core->id.rev,
+-			core->id.class);
++		bcma_info(bus, "Core %d found: %s (manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\n",
++			  core->core_index, bcma_device_name(&core->id),
++			  core->id.manuf, core->id.id, core->id.rev,
++			  core->id.class);
+ 
+-		list_add(&core->list, &bus->cores);
++		list_add_tail(&core->list, &bus->cores);
+ 		err = 0;
+ 		break;
+ 	}
+--- a/drivers/bcma/scan.h
++++ b/drivers/bcma/scan.h
+@@ -27,7 +27,7 @@
+ #define SCAN_CIB_NMW		0x0007C000
+ #define SCAN_CIB_NMW_SHIFT	14
+ #define SCAN_CIB_NSW		0x00F80000
+-#define SCAN_CIB_NSW_SHIFT	17
++#define SCAN_CIB_NSW_SHIFT	19
+ #define SCAN_CIB_REV		0xFF000000
+ #define SCAN_CIB_REV_SHIFT	24
+ 
 --- a/drivers/bcma/sprom.c
 +++ b/drivers/bcma/sprom.c
 @@ -2,6 +2,8 @@
@@ -1112,17 +2264,17 @@
 +	if (err)
 +		goto fail;
 +
-+	pr_debug("Using SPROM revision %d provided by"
-+		 " platform.\n", bus->sprom.revision);
++	bcma_debug(bus, "Using SPROM revision %d provided by platform.\n",
++		   bus->sprom.revision);
 +	return 0;
 +fail:
-+	pr_warn("Using fallback SPROM failed (err %d)\n", err);
++	bcma_warn(bus, "Using fallback SPROM failed (err %d)\n", err);
 +	return err;
 +}
  
  /**************************************************
   * R/W ops.
-@@ -124,10 +176,21 @@ static int bcma_sprom_valid(const u16 *s
+@@ -124,10 +176,37 @@ static int bcma_sprom_valid(const u16 *s
   * SPROM extraction.
   **************************************************/
  
@@ -1131,6 +2283,22 @@
 +#define SPEX(_field, _offset, _mask, _shift)	\
 +	bus->sprom._field = ((sprom[SPOFF(_offset)] & (_mask)) >> (_shift))
 +
++#define SPEX32(_field, _offset, _mask, _shift)	\
++	bus->sprom._field = ((((u32)sprom[SPOFF((_offset)+2)] << 16 | \
++				sprom[SPOFF(_offset)]) & (_mask)) >> (_shift))
++
++#define SPEX_ARRAY8(_field, _offset, _mask, _shift)	\
++	do {	\
++		SPEX(_field[0], _offset +  0, _mask, _shift);	\
++		SPEX(_field[1], _offset +  2, _mask, _shift);	\
++		SPEX(_field[2], _offset +  4, _mask, _shift);	\
++		SPEX(_field[3], _offset +  6, _mask, _shift);	\
++		SPEX(_field[4], _offset +  8, _mask, _shift);	\
++		SPEX(_field[5], _offset + 10, _mask, _shift);	\
++		SPEX(_field[6], _offset + 12, _mask, _shift);	\
++		SPEX(_field[7], _offset + 14, _mask, _shift);	\
++	} while (0)
++
  static void bcma_sprom_extract_r8(struct bcma_bus *bus, const u16 *sprom)
  {
 -	u16 v;
@@ -1145,7 +2313,7 @@
  
  	bus->sprom.revision = sprom[SSB_SPROMSIZE_WORDS_R4 - 1] &
  		SSB_SPROM_REVISION_REV;
-@@ -137,85 +200,229 @@ static void bcma_sprom_extract_r8(struct
+@@ -137,102 +216,378 @@ static void bcma_sprom_extract_r8(struct
  		*(((__be16 *)bus->sprom.il0mac) + i) = cpu_to_be16(v);
  	}
  
@@ -1257,7 +2425,8 @@
 +	SPEX(boardflags2_lo, SSB_SPROM8_BFL2LO, ~0, 0);
 +	SPEX(boardflags2_hi, SSB_SPROM8_BFL2HI, ~0, 0);
 +
-+	SPEX(country_code, SSB_SPROM8_CCODE, ~0, 0);
++	SPEX(alpha2[0], SSB_SPROM8_CCODE, 0xff00, 8);
++	SPEX(alpha2[1], SSB_SPROM8_CCODE, 0x00ff, 0);
 +
 +	/* Extract cores power info info */
 +	for (i = 0; i < ARRAY_SIZE(pwr_info_offset); i++) {
@@ -1312,6 +2481,136 @@
 +	     SSB_SROM8_FEM_TR_ISO_SHIFT);
 +	SPEX(fem.ghz5.antswlut, SSB_SPROM8_FEM5G, SSB_SROM8_FEM_ANTSWLUT,
 +	     SSB_SROM8_FEM_ANTSWLUT_SHIFT);
++
++	SPEX(ant_available_a, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_A,
++	     SSB_SPROM8_ANTAVAIL_A_SHIFT);
++	SPEX(ant_available_bg, SSB_SPROM8_ANTAVAIL, SSB_SPROM8_ANTAVAIL_BG,
++	     SSB_SPROM8_ANTAVAIL_BG_SHIFT);
++	SPEX(maxpwr_bg, SSB_SPROM8_MAXP_BG, SSB_SPROM8_MAXP_BG_MASK, 0);
++	SPEX(itssi_bg, SSB_SPROM8_MAXP_BG, SSB_SPROM8_ITSSI_BG,
++	     SSB_SPROM8_ITSSI_BG_SHIFT);
++	SPEX(maxpwr_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_MAXP_A_MASK, 0);
++	SPEX(itssi_a, SSB_SPROM8_MAXP_A, SSB_SPROM8_ITSSI_A,
++	     SSB_SPROM8_ITSSI_A_SHIFT);
++	SPEX(maxpwr_ah, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AH_MASK, 0);
++	SPEX(maxpwr_al, SSB_SPROM8_MAXP_AHL, SSB_SPROM8_MAXP_AL_MASK,
++	     SSB_SPROM8_MAXP_AL_SHIFT);
++	SPEX(gpio0, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P0, 0);
++	SPEX(gpio1, SSB_SPROM8_GPIOA, SSB_SPROM8_GPIOA_P1,
++	     SSB_SPROM8_GPIOA_P1_SHIFT);
++	SPEX(gpio2, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P2, 0);
++	SPEX(gpio3, SSB_SPROM8_GPIOB, SSB_SPROM8_GPIOB_P3,
++	     SSB_SPROM8_GPIOB_P3_SHIFT);
++	SPEX(tri2g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI2G, 0);
++	SPEX(tri5g, SSB_SPROM8_TRI25G, SSB_SPROM8_TRI5G,
++	     SSB_SPROM8_TRI5G_SHIFT);
++	SPEX(tri5gl, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GL, 0);
++	SPEX(tri5gh, SSB_SPROM8_TRI5GHL, SSB_SPROM8_TRI5GH,
++	     SSB_SPROM8_TRI5GH_SHIFT);
++	SPEX(rxpo2g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO2G,
++	     SSB_SPROM8_RXPO2G_SHIFT);
++	SPEX(rxpo5g, SSB_SPROM8_RXPO, SSB_SPROM8_RXPO5G,
++	     SSB_SPROM8_RXPO5G_SHIFT);
++	SPEX(rssismf2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMF2G, 0);
++	SPEX(rssismc2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISMC2G,
++	     SSB_SPROM8_RSSISMC2G_SHIFT);
++	SPEX(rssisav2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_RSSISAV2G,
++	     SSB_SPROM8_RSSISAV2G_SHIFT);
++	SPEX(bxa2g, SSB_SPROM8_RSSIPARM2G, SSB_SPROM8_BXA2G,
++	     SSB_SPROM8_BXA2G_SHIFT);
++	SPEX(rssismf5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMF5G, 0);
++	SPEX(rssismc5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISMC5G,
++	     SSB_SPROM8_RSSISMC5G_SHIFT);
++	SPEX(rssisav5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_RSSISAV5G,
++	     SSB_SPROM8_RSSISAV5G_SHIFT);
++	SPEX(bxa5g, SSB_SPROM8_RSSIPARM5G, SSB_SPROM8_BXA5G,
++	     SSB_SPROM8_BXA5G_SHIFT);
++
++	SPEX(pa0b0, SSB_SPROM8_PA0B0, ~0, 0);
++	SPEX(pa0b1, SSB_SPROM8_PA0B1, ~0, 0);
++	SPEX(pa0b2, SSB_SPROM8_PA0B2, ~0, 0);
++	SPEX(pa1b0, SSB_SPROM8_PA1B0, ~0, 0);
++	SPEX(pa1b1, SSB_SPROM8_PA1B1, ~0, 0);
++	SPEX(pa1b2, SSB_SPROM8_PA1B2, ~0, 0);
++	SPEX(pa1lob0, SSB_SPROM8_PA1LOB0, ~0, 0);
++	SPEX(pa1lob1, SSB_SPROM8_PA1LOB1, ~0, 0);
++	SPEX(pa1lob2, SSB_SPROM8_PA1LOB2, ~0, 0);
++	SPEX(pa1hib0, SSB_SPROM8_PA1HIB0, ~0, 0);
++	SPEX(pa1hib1, SSB_SPROM8_PA1HIB1, ~0, 0);
++	SPEX(pa1hib2, SSB_SPROM8_PA1HIB2, ~0, 0);
++	SPEX(cck2gpo, SSB_SPROM8_CCK2GPO, ~0, 0);
++	SPEX32(ofdm2gpo, SSB_SPROM8_OFDM2GPO, ~0, 0);
++	SPEX32(ofdm5glpo, SSB_SPROM8_OFDM5GLPO, ~0, 0);
++	SPEX32(ofdm5gpo, SSB_SPROM8_OFDM5GPO, ~0, 0);
++	SPEX32(ofdm5ghpo, SSB_SPROM8_OFDM5GHPO, ~0, 0);
++
++	/* Extract the antenna gain values. */
++	SPEX(antenna_gain.a0, SSB_SPROM8_AGAIN01,
++	     SSB_SPROM8_AGAIN0, SSB_SPROM8_AGAIN0_SHIFT);
++	SPEX(antenna_gain.a1, SSB_SPROM8_AGAIN01,
++	     SSB_SPROM8_AGAIN1, SSB_SPROM8_AGAIN1_SHIFT);
++	SPEX(antenna_gain.a2, SSB_SPROM8_AGAIN23,
++	     SSB_SPROM8_AGAIN2, SSB_SPROM8_AGAIN2_SHIFT);
++	SPEX(antenna_gain.a3, SSB_SPROM8_AGAIN23,
++	     SSB_SPROM8_AGAIN3, SSB_SPROM8_AGAIN3_SHIFT);
++
++	SPEX(leddc_on_time, SSB_SPROM8_LEDDC, SSB_SPROM8_LEDDC_ON,
++	     SSB_SPROM8_LEDDC_ON_SHIFT);
++	SPEX(leddc_off_time, SSB_SPROM8_LEDDC, SSB_SPROM8_LEDDC_OFF,
++	     SSB_SPROM8_LEDDC_OFF_SHIFT);
++
++	SPEX(txchain, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_TXCHAIN,
++	     SSB_SPROM8_TXRXC_TXCHAIN_SHIFT);
++	SPEX(rxchain, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_RXCHAIN,
++	     SSB_SPROM8_TXRXC_RXCHAIN_SHIFT);
++	SPEX(antswitch, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_SWITCH,
++	     SSB_SPROM8_TXRXC_SWITCH_SHIFT);
++
++	SPEX(opo, SSB_SPROM8_OFDM2GPO, 0x00ff, 0);
++
++	SPEX_ARRAY8(mcs2gpo, SSB_SPROM8_2G_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5gpo, SSB_SPROM8_5G_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5glpo, SSB_SPROM8_5GL_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5ghpo, SSB_SPROM8_5GH_MCSPO, ~0, 0);
++
++	SPEX(rawtempsense, SSB_SPROM8_RAWTS, SSB_SPROM8_RAWTS_RAWTEMP,
++	     SSB_SPROM8_RAWTS_RAWTEMP_SHIFT);
++	SPEX(measpower, SSB_SPROM8_RAWTS, SSB_SPROM8_RAWTS_MEASPOWER,
++	     SSB_SPROM8_RAWTS_MEASPOWER_SHIFT);
++	SPEX(tempsense_slope, SSB_SPROM8_OPT_CORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMP_SLOPE,
++	     SSB_SPROM8_OPT_CORRX_TEMP_SLOPE_SHIFT);
++	SPEX(tempcorrx, SSB_SPROM8_OPT_CORRX, SSB_SPROM8_OPT_CORRX_TEMPCORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMPCORRX_SHIFT);
++	SPEX(tempsense_option, SSB_SPROM8_OPT_CORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMP_OPTION,
++	     SSB_SPROM8_OPT_CORRX_TEMP_OPTION_SHIFT);
++	SPEX(freqoffset_corr, SSB_SPROM8_HWIQ_IQSWP,
++	     SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR,
++	     SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR_SHIFT);
++	SPEX(iqcal_swp_dis, SSB_SPROM8_HWIQ_IQSWP,
++	     SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP,
++	     SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP_SHIFT);
++	SPEX(hw_iqcal_en, SSB_SPROM8_HWIQ_IQSWP, SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL,
++	     SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL_SHIFT);
++
++	SPEX(bw40po, SSB_SPROM8_BW40PO, ~0, 0);
++	SPEX(cddpo, SSB_SPROM8_CDDPO, ~0, 0);
++	SPEX(stbcpo, SSB_SPROM8_STBCPO, ~0, 0);
++	SPEX(bwduppo, SSB_SPROM8_BWDUPPO, ~0, 0);
++
++	SPEX(tempthresh, SSB_SPROM8_THERMAL, SSB_SPROM8_THERMAL_TRESH,
++	     SSB_SPROM8_THERMAL_TRESH_SHIFT);
++	SPEX(tempoffset, SSB_SPROM8_THERMAL, SSB_SPROM8_THERMAL_OFFSET,
++	     SSB_SPROM8_THERMAL_OFFSET_SHIFT);
++	SPEX(phycal_tempdelta, SSB_SPROM8_TEMPDELTA,
++	     SSB_SPROM8_TEMPDELTA_PHYCAL,
++	     SSB_SPROM8_TEMPDELTA_PHYCAL_SHIFT);
++	SPEX(temps_period, SSB_SPROM8_TEMPDELTA, SSB_SPROM8_TEMPDELTA_PERIOD,
++	     SSB_SPROM8_TEMPDELTA_PERIOD_SHIFT);
++	SPEX(temps_hysteresis, SSB_SPROM8_TEMPDELTA,
++	     SSB_SPROM8_TEMPDELTA_HYSTERESIS,
++	     SSB_SPROM8_TEMPDELTA_HYSTERESIS_SHIFT);
 +}
 +
 +/*
@@ -1335,11 +2634,11 @@
 +	/* older chipcommon revisions use chip status register */
 +	chip_status = bcma_read32(bus->drv_cc.core, BCMA_CC_CHIPSTAT);
 +	switch (bus->chipinfo.id) {
-+	case 0x4313:
++	case BCMA_CHIP_ID_BCM4313:
 +		present_mask = BCMA_CC_CHIPST_4313_SPROM_PRESENT;
 +		break;
 +
-+	case 0x4331:
++	case BCMA_CHIP_ID_BCM4331:
 +		present_mask = BCMA_CC_CHIPST_4331_SPROM_PRESENT;
 +		break;
 +
@@ -1361,16 +2660,16 @@
 +
 +	chip_status = bcma_read32(bus->drv_cc.core, BCMA_CC_CHIPSTAT);
 +	switch (bus->chipinfo.id) {
-+	case 0x4313:
++	case BCMA_CHIP_ID_BCM4313:
 +		present = chip_status & BCMA_CC_CHIPST_4313_OTP_PRESENT;
 +		break;
 +
-+	case 0x4331:
++	case BCMA_CHIP_ID_BCM4331:
 +		present = chip_status & BCMA_CC_CHIPST_4331_OTP_PRESENT;
 +		break;
 +
-+	case 43224:
-+	case 43225:
++	case BCMA_CHIP_ID_BCM43224:
++	case BCMA_CHIP_ID_BCM43225:
 +		/* for these chips OTP is always available */
 +		present = true;
 +		break;
@@ -1421,16 +2720,19 @@
 -	if (!(bus->drv_cc.capabilities & BCMA_CC_CAP_SPROM))
 -		return -ENOENT;
 +	if (!bcma_sprom_ext_available(bus)) {
++		bool sprom_onchip;
++
 +		/*
 +		 * External SPROM takes precedence so check
 +		 * on-chip OTP only when no external SPROM
 +		 * is present.
 +		 */
-+		if (bcma_sprom_onchip_available(bus)) {
++		sprom_onchip = bcma_sprom_onchip_available(bus);
++		if (sprom_onchip) {
 +			/* determine offset */
 +			offset = bcma_sprom_onchip_offset(bus);
 +		}
-+		if (!offset) {
++		if (!offset || !sprom_onchip) {
 +			/*
 +			 * Maybe there is no SPROM on the device?
 +			 * Now we ask the arch code if there is some sprom
@@ -1443,8 +2745,12 @@
  
  	sprom = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
  			GFP_KERNEL);
-@@ -225,11 +432,7 @@ int bcma_sprom_get(struct bcma_bus *bus)
- 	if (bus->chipinfo.id == 0x4331)
+ 	if (!sprom)
+ 		return -ENOMEM;
+ 
+-	if (bus->chipinfo.id == 0x4331)
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
++	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
  		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, false);
  
 -	/* Most cards have SPROM moved by additional offset 0x30 (48 dwords).
@@ -1452,22 +2758,101 @@
 -	 * TODO: understand this condition and use it */
 -	offset = (bus->chipinfo.id == 0x4331) ? BCMA_CC_SPROM :
 -		BCMA_CC_SPROM_PCIE6;
-+	pr_debug("SPROM offset 0x%x\n", offset);
++	bcma_debug(bus, "SPROM offset 0x%x\n", offset);
  	bcma_sprom_read(bus, offset, sprom);
  
- 	if (bus->chipinfo.id == 0x4331)
+-	if (bus->chipinfo.id == 0x4331)
++	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
++	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
+ 		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, true);
+ 
+ 	err = bcma_sprom_valid(sprom);
 --- a/include/linux/bcma/bcma.h
 +++ b/include/linux/bcma/bcma.h
-@@ -136,6 +136,7 @@ struct bcma_device {
+@@ -7,6 +7,7 @@
+ #include <linux/bcma/bcma_driver_chipcommon.h>
+ #include <linux/bcma/bcma_driver_pci.h>
+ #include <linux/bcma/bcma_driver_mips.h>
++#include <linux/bcma/bcma_driver_gmac_cmn.h>
+ #include <linux/ssb/ssb.h> /* SPROM sharing */
+ 
+ #include "bcma_regs.h"
+@@ -26,6 +27,11 @@ struct bcma_chipinfo {
+ 	u8 pkg;
+ };
+ 
++struct bcma_boardinfo {
++	u16 vendor;
++	u16 type;
++};
++
+ enum bcma_clkmode {
+ 	BCMA_CLKMODE_FAST,
+ 	BCMA_CLKMODE_DYNAMIC,
+@@ -65,6 +71,13 @@ struct bcma_host_ops {
+ 
+ /* Core-ID values. */
+ #define BCMA_CORE_OOB_ROUTER		0x367	/* Out of band */
++#define BCMA_CORE_4706_CHIPCOMMON	0x500
++#define BCMA_CORE_4706_SOC_RAM		0x50E
++#define BCMA_CORE_4706_MAC_GBIT		0x52D
++#define BCMA_CORE_AMEMC			0x52E	/* DDR1/2 memory controller core */
++#define BCMA_CORE_ALTA			0x534	/* I2S core */
++#define BCMA_CORE_4706_MAC_GBIT_COMMON	0x5DC
++#define BCMA_CORE_DDR23_PHY		0x5DD
+ #define BCMA_CORE_INVALID		0x700
+ #define BCMA_CORE_CHIPCOMMON		0x800
+ #define BCMA_CORE_ILINE20		0x801
+@@ -125,6 +138,36 @@ struct bcma_host_ops {
+ 
+ #define BCMA_MAX_NR_CORES		16
+ 
++/* Chip IDs of PCIe devices */
++#define BCMA_CHIP_ID_BCM4313	0x4313
++#define BCMA_CHIP_ID_BCM43224	43224
++#define  BCMA_PKG_ID_BCM43224_FAB_CSM	0x8
++#define  BCMA_PKG_ID_BCM43224_FAB_SMIC	0xa
++#define BCMA_CHIP_ID_BCM43225	43225
++#define BCMA_CHIP_ID_BCM43227	43227
++#define BCMA_CHIP_ID_BCM43228	43228
++#define BCMA_CHIP_ID_BCM43421	43421
++#define BCMA_CHIP_ID_BCM43428	43428
++#define BCMA_CHIP_ID_BCM43431	43431
++#define BCMA_CHIP_ID_BCM43460	43460
++#define BCMA_CHIP_ID_BCM4331	0x4331
++#define BCMA_CHIP_ID_BCM6362	0x6362
++#define BCMA_CHIP_ID_BCM4360	0x4360
++#define BCMA_CHIP_ID_BCM4352	0x4352
++
++/* Chip IDs of SoCs */
++#define BCMA_CHIP_ID_BCM4706	0x5300
++#define BCMA_CHIP_ID_BCM4716	0x4716
++#define  BCMA_PKG_ID_BCM4716	8
++#define  BCMA_PKG_ID_BCM4717	9
++#define  BCMA_PKG_ID_BCM4718	10
++#define BCMA_CHIP_ID_BCM47162	47162
++#define BCMA_CHIP_ID_BCM4748	0x4748
++#define BCMA_CHIP_ID_BCM4749	0x4749
++#define BCMA_CHIP_ID_BCM5356	0x5356
++#define BCMA_CHIP_ID_BCM5357	0x5357
++#define BCMA_CHIP_ID_BCM53572	53572
++
+ struct bcma_device {
+ 	struct bcma_bus *bus;
+ 	struct bcma_device_id id;
+@@ -136,8 +179,10 @@ struct bcma_device {
  	bool dev_registered;
  
  	u8 core_index;
 +	u8 core_unit;
  
  	u32 addr;
++	u32 addr1;
  	u32 wrap;
-@@ -175,6 +176,12 @@ int __bcma_driver_register(struct bcma_d
  
+ 	void __iomem *io_addr;
+@@ -175,6 +220,12 @@ int __bcma_driver_register(struct bcma_d
+ 
  extern void bcma_driver_unregister(struct bcma_driver *drv);
  
 +/* Set a fallback SPROM.
@@ -1479,7 +2864,13 @@
  struct bcma_bus {
  	/* The MMIO area. */
  	void __iomem *mmio;
-@@ -195,6 +202,7 @@ struct bcma_bus {
+@@ -191,14 +242,18 @@ struct bcma_bus {
+ 
+ 	struct bcma_chipinfo chipinfo;
+ 
++	struct bcma_boardinfo boardinfo;
++
+ 	struct bcma_device *mapped_core;
  	struct list_head cores;
  	u8 nr_cores;
  	u8 init_done:1;
@@ -1487,7 +2878,12 @@
  
  	struct bcma_drv_cc drv_cc;
  	struct bcma_drv_pci drv_pci;
-@@ -282,6 +290,7 @@ static inline void bcma_maskset16(struct
+ 	struct bcma_drv_mips drv_mips;
++	struct bcma_drv_gmac_cmn drv_gmac_cmn;
+ 
+ 	/* We decided to share SPROM struct with SSB as long as we do not need
+ 	 * any hacks for BCMA. This simplifies drivers code. */
+@@ -282,6 +337,7 @@ static inline void bcma_maskset16(struct
  	bcma_write16(cc, offset, (bcma_read16(cc, offset) & mask) | set);
  }
  
@@ -1516,7 +2912,7 @@
  #define BCMA_CC_IRQSTAT			0x0020
  #define BCMA_CC_IRQMASK			0x0024
  #define	 BCMA_CC_IRQ_GPIO		0x00000001	/* gpio intr */
-@@ -79,6 +84,10 @@
+@@ -79,6 +84,15 @@
  #define	 BCMA_CC_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
  #define BCMA_CC_CHIPCTL			0x0028		/* Rev >= 11 only */
  #define BCMA_CC_CHIPSTAT		0x002C		/* Rev >= 11 only */
@@ -1524,10 +2920,15 @@
 +#define  BCMA_CC_CHIPST_4313_OTP_PRESENT	2
 +#define  BCMA_CC_CHIPST_4331_SPROM_PRESENT	2
 +#define  BCMA_CC_CHIPST_4331_OTP_PRESENT	4
++#define  BCMA_CC_CHIPST_4706_PKG_OPTION		BIT(0) /* 0: full-featured package 1: low-cost package */
++#define  BCMA_CC_CHIPST_4706_SFLASH_PRESENT	BIT(1) /* 0: parallel, 1: serial flash is present */
++#define  BCMA_CC_CHIPST_4706_SFLASH_TYPE	BIT(2) /* 0: 8b-p/ST-s flash, 1: 16b-p/Atmal-s flash */
++#define  BCMA_CC_CHIPST_4706_MIPS_BENDIAN	BIT(3) /* 0: little, 1: big endian */
++#define  BCMA_CC_CHIPST_4706_PCIE1_DISABLE	BIT(5) /* PCIE1 enable strap pin */
  #define BCMA_CC_JCMD			0x0030		/* Rev >= 10 only */
  #define  BCMA_CC_JCMD_START		0x80000000
  #define  BCMA_CC_JCMD_BUSY		0x80000000
-@@ -181,6 +190,22 @@
+@@ -181,6 +195,22 @@
  #define BCMA_CC_FLASH_CFG		0x0128
  #define  BCMA_CC_FLASH_CFG_DS		0x0010	/* Data size, 0=8bit, 1=16bit */
  #define BCMA_CC_FLASH_WAITCNT		0x012C
@@ -1550,7 +2951,7 @@
  /* 0x1E0 is defined as shared BCMA_CLKCTLST */
  #define BCMA_CC_HW_WORKAROUND		0x01E4 /* Hardware workaround (rev >= 20) */
  #define BCMA_CC_UART0_DATA		0x0300
-@@ -240,7 +265,6 @@
+@@ -240,7 +270,6 @@
  #define BCMA_CC_PLLCTL_ADDR		0x0660
  #define BCMA_CC_PLLCTL_DATA		0x0664
  #define BCMA_CC_SPROM			0x0800 /* SPROM beginning */
@@ -1558,9 +2959,174 @@
  
  /* Divider allocation in 4716/47162/5356 */
  #define BCMA_CC_PMU5_MAINPLL_CPU	1
+@@ -256,6 +285,15 @@
+ 
+ /* 4706 PMU */
+ #define BCMA_CC_PMU4706_MAINPLL_PLL0	0
++#define BCMA_CC_PMU6_4706_PROCPLL_OFF	4	/* The CPU PLL */
++#define  BCMA_CC_PMU6_4706_PROC_P2DIV_MASK	0x000f0000
++#define  BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT	16
++#define  BCMA_CC_PMU6_4706_PROC_P1DIV_MASK	0x0000f000
++#define  BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT	12
++#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK	0x00000ff8
++#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT	3
++#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_MASK	0x00000007
++#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_SHIFT	0
+ 
+ /* ALP clock on pre-PMU chips */
+ #define BCMA_CC_PMU_ALP_CLOCK		20000000
+@@ -284,6 +322,19 @@
+ #define BCMA_CC_PPL_PCHI_OFF		5
+ #define BCMA_CC_PPL_PCHI_MASK		0x0000003f
+ 
++#define BCMA_CC_PMU_PLL_CTL0		0
++#define BCMA_CC_PMU_PLL_CTL1		1
++#define BCMA_CC_PMU_PLL_CTL2		2
++#define BCMA_CC_PMU_PLL_CTL3		3
++#define BCMA_CC_PMU_PLL_CTL4		4
++#define BCMA_CC_PMU_PLL_CTL5		5
++
++#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK	0x00f00000
++#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT	20
++
++#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
++#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
++
+ /* BCM4331 ChipControl numbers. */
+ #define BCMA_CHIPCTL_4331_BT_COEXIST		BIT(0)	/* 0 disable */
+ #define BCMA_CHIPCTL_4331_SECI			BIT(1)	/* 0 SECI is disabled (JATG functional) */
+@@ -297,9 +348,18 @@
+ #define BCMA_CHIPCTL_4331_OVR_PIPEAUXPWRDOWN	BIT(9)	/* override core control on pipe_AuxPowerDown */
+ #define BCMA_CHIPCTL_4331_PCIE_AUXCLKEN		BIT(10)	/* pcie_auxclkenable */
+ #define BCMA_CHIPCTL_4331_PCIE_PIPE_PLLDOWN	BIT(11)	/* pcie_pipe_pllpowerdown */
++#define BCMA_CHIPCTL_4331_EXTPA_EN2		BIT(12)	/* 0 ext pa disable, 1 ext pa enabled */
+ #define BCMA_CHIPCTL_4331_BT_SHD0_ON_GPIO4	BIT(16)	/* enable bt_shd0 at gpio4 */
+ #define BCMA_CHIPCTL_4331_BT_SHD1_ON_GPIO5	BIT(17)	/* enable bt_shd1 at gpio5 */
+ 
++/* 43224 chip-specific ChipControl register bits */
++#define BCMA_CCTRL_43224_GPIO_TOGGLE		0x8000		/* gpio[3:0] pins as btcoex or s/w gpio */
++#define BCMA_CCTRL_43224A0_12MA_LED_DRIVE	0x00F000F0	/* 12 mA drive strength */
++#define BCMA_CCTRL_43224B0_12MA_LED_DRIVE	0xF0		/* 12 mA drive strength for later 43224s */
++
++/* 4313 Chip specific ChipControl register bits */
++#define BCMA_CCTRL_4313_12MA_LED_DRIVE		0x00000007	/* 12 mA drive strengh for later 4313 */
++
+ /* Data for the PMU, if available.
+  * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
+  */
+@@ -387,5 +447,6 @@ extern void bcma_chipco_chipctl_maskset(
+ 					u32 offset, u32 mask, u32 set);
+ extern void bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc,
+ 				       u32 offset, u32 mask, u32 set);
++extern void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid);
+ 
+ #endif /* LINUX_BCMA_DRIVER_CC_H_ */
+--- /dev/null
++++ b/include/linux/bcma/bcma_driver_gmac_cmn.h
+@@ -0,0 +1,100 @@
++#ifndef LINUX_BCMA_DRIVER_GMAC_CMN_H_
++#define LINUX_BCMA_DRIVER_GMAC_CMN_H_
++
++#include <linux/types.h>
++
++#define BCMA_GMAC_CMN_STAG0		0x000
++#define BCMA_GMAC_CMN_STAG1		0x004
++#define BCMA_GMAC_CMN_STAG2		0x008
++#define BCMA_GMAC_CMN_STAG3		0x00C
++#define BCMA_GMAC_CMN_PARSER_CTL	0x020
++#define BCMA_GMAC_CMN_MIB_MAX_LEN	0x024
++#define BCMA_GMAC_CMN_PHY_ACCESS	0x100
++#define  BCMA_GMAC_CMN_PA_DATA_MASK	0x0000ffff
++#define  BCMA_GMAC_CMN_PA_ADDR_MASK	0x001f0000
++#define  BCMA_GMAC_CMN_PA_ADDR_SHIFT	16
++#define  BCMA_GMAC_CMN_PA_REG_MASK	0x1f000000
++#define  BCMA_GMAC_CMN_PA_REG_SHIFT	24
++#define  BCMA_GMAC_CMN_PA_WRITE		0x20000000
++#define  BCMA_GMAC_CMN_PA_START		0x40000000
++#define BCMA_GMAC_CMN_PHY_CTL		0x104
++#define  BCMA_GMAC_CMN_PC_EPA_MASK	0x0000001f
++#define  BCMA_GMAC_CMN_PC_MCT_MASK	0x007f0000
++#define  BCMA_GMAC_CMN_PC_MCT_SHIFT	16
++#define  BCMA_GMAC_CMN_PC_MTE		0x00800000
++#define BCMA_GMAC_CMN_GMAC0_RGMII_CTL	0x110
++#define BCMA_GMAC_CMN_CFP_ACCESS	0x200
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA0	0x210
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA1	0x214
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA2	0x218
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA3	0x21C
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA4	0x220
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA5	0x224
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA6	0x228
++#define BCMA_GMAC_CMN_CFP_TCAM_DATA7	0x22C
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK0	0x230
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK1	0x234
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK2	0x238
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK3	0x23C
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK4	0x240
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK5	0x244
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK6	0x248
++#define BCMA_GMAC_CMN_CFP_TCAM_MASK7	0x24C
++#define BCMA_GMAC_CMN_CFP_ACTION_DATA	0x250
++#define BCMA_GMAC_CMN_TCAM_BIST_CTL	0x2A0
++#define BCMA_GMAC_CMN_TCAM_BIST_STATUS	0x2A4
++#define BCMA_GMAC_CMN_TCAM_CMP_STATUS	0x2A8
++#define BCMA_GMAC_CMN_TCAM_DISABLE	0x2AC
++#define BCMA_GMAC_CMN_TCAM_TEST_CTL	0x2F0
++#define BCMA_GMAC_CMN_UDF_0_A3_A0	0x300
++#define BCMA_GMAC_CMN_UDF_0_A7_A4	0x304
++#define BCMA_GMAC_CMN_UDF_0_A8		0x308
++#define BCMA_GMAC_CMN_UDF_1_A3_A0	0x310
++#define BCMA_GMAC_CMN_UDF_1_A7_A4	0x314
++#define BCMA_GMAC_CMN_UDF_1_A8		0x318
++#define BCMA_GMAC_CMN_UDF_2_A3_A0	0x320
++#define BCMA_GMAC_CMN_UDF_2_A7_A4	0x324
++#define BCMA_GMAC_CMN_UDF_2_A8		0x328
++#define BCMA_GMAC_CMN_UDF_0_B3_B0	0x330
++#define BCMA_GMAC_CMN_UDF_0_B7_B4	0x334
++#define BCMA_GMAC_CMN_UDF_0_B8		0x338
++#define BCMA_GMAC_CMN_UDF_1_B3_B0	0x340
++#define BCMA_GMAC_CMN_UDF_1_B7_B4	0x344
++#define BCMA_GMAC_CMN_UDF_1_B8		0x348
++#define BCMA_GMAC_CMN_UDF_2_B3_B0	0x350
++#define BCMA_GMAC_CMN_UDF_2_B7_B4	0x354
++#define BCMA_GMAC_CMN_UDF_2_B8		0x358
++#define BCMA_GMAC_CMN_UDF_0_C3_C0	0x360
++#define BCMA_GMAC_CMN_UDF_0_C7_C4	0x364
++#define BCMA_GMAC_CMN_UDF_0_C8		0x368
++#define BCMA_GMAC_CMN_UDF_1_C3_C0	0x370
++#define BCMA_GMAC_CMN_UDF_1_C7_C4	0x374
++#define BCMA_GMAC_CMN_UDF_1_C8		0x378
++#define BCMA_GMAC_CMN_UDF_2_C3_C0	0x380
++#define BCMA_GMAC_CMN_UDF_2_C7_C4	0x384
++#define BCMA_GMAC_CMN_UDF_2_C8		0x388
++#define BCMA_GMAC_CMN_UDF_0_D3_D0	0x390
++#define BCMA_GMAC_CMN_UDF_0_D7_D4	0x394
++#define BCMA_GMAC_CMN_UDF_0_D11_D8	0x394
++
++struct bcma_drv_gmac_cmn {
++	struct bcma_device *core;
++
++	/* Drivers accessing BCMA_GMAC_CMN_PHY_ACCESS and
++	 * BCMA_GMAC_CMN_PHY_CTL need to take that mutex first. */
++	struct mutex phy_mutex;
++};
++
++/* Register access */
++#define gmac_cmn_read16(gc, offset)		bcma_read16((gc)->core, offset)
++#define gmac_cmn_read32(gc, offset)		bcma_read32((gc)->core, offset)
++#define gmac_cmn_write16(gc, offset, val)	bcma_write16((gc)->core, offset, val)
++#define gmac_cmn_write32(gc, offset, val)	bcma_write32((gc)->core, offset, val)
++
++#ifdef CONFIG_BCMA_DRIVER_GMAC_CMN
++extern void __devinit bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc);
++#else
++static inline void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc) { }
++#endif
++
++#endif /* LINUX_BCMA_DRIVER_GMAC_CMN_H_ */
 --- a/include/linux/bcma/bcma_driver_pci.h
 +++ b/include/linux/bcma/bcma_driver_pci.h
-@@ -53,6 +53,35 @@ struct pci_dev;
+@@ -53,11 +53,47 @@ struct pci_dev;
  #define  BCMA_CORE_PCI_SBTOPCI1_MASK		0xFC000000
  #define BCMA_CORE_PCI_SBTOPCI2			0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
  #define  BCMA_CORE_PCI_SBTOPCI2_MASK		0xC0000000
@@ -1596,7 +3162,19 @@
  #define BCMA_CORE_PCI_PCICFG0			0x0400	/* PCI config space 0 (rev >= 8) */
  #define BCMA_CORE_PCI_PCICFG1			0x0500	/* PCI config space 1 (rev >= 8) */
  #define BCMA_CORE_PCI_PCICFG2			0x0600	/* PCI config space 2 (rev >= 8) */
-@@ -72,20 +101,114 @@ struct pci_dev;
+ #define BCMA_CORE_PCI_PCICFG3			0x0700	/* PCI config space 3 (rev >= 8) */
+ #define BCMA_CORE_PCI_SPROM(wordoffset)		(0x0800 + ((wordoffset) * 2)) /* SPROM shadow area (72 bytes) */
++#define  BCMA_CORE_PCI_SPROM_PI_OFFSET		0	/* first word */
++#define   BCMA_CORE_PCI_SPROM_PI_MASK		0xf000	/* bit 15:12 */
++#define   BCMA_CORE_PCI_SPROM_PI_SHIFT		12	/* bit 15:12 */
++#define  BCMA_CORE_PCI_SPROM_MISC_CONFIG	5	/* word 5 */
++#define   BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST	0x8000	/* bit 15 */
++#define   BCMA_CORE_PCI_SPROM_CLKREQ_OFFSET_REV5	20	/* word 20 for srom rev <= 5 */
++#define   BCMA_CORE_PCI_SPROM_CLKREQ_ENB	0x0800	/* bit 11 */
+ 
+ /* SBtoPCIx */
+ #define BCMA_CORE_PCI_SBTOPCI_MEM		0x00000000
+@@ -72,20 +108,118 @@ struct pci_dev;
  #define  BCMA_CORE_PCI_SBTOPCI_RC_READL		0x00000010 /* Memory read line */
  #define  BCMA_CORE_PCI_SBTOPCI_RC_READM		0x00000020 /* Memory read multiple */
  
@@ -1632,6 +3210,7 @@
 +#define BCMA_CORE_PCI_DLLP_LRREG		0x120	/* Link Replay */
 +#define BCMA_CORE_PCI_DLLP_LACKTOREG		0x124	/* Link Ack Timeout */
 +#define BCMA_CORE_PCI_DLLP_PMTHRESHREG		0x128	/* Power Management Threshold */
++#define  BCMA_CORE_PCI_ASPMTIMER_EXTEND		0x01000000 /* > rev7: enable extend ASPM timer */
 +#define BCMA_CORE_PCI_DLLP_RTRYWPREG		0x12C	/* Retry buffer write ptr */
 +#define BCMA_CORE_PCI_DLLP_RTRYRPREG		0x130	/* Retry buffer Read ptr */
 +#define BCMA_CORE_PCI_DLLP_RTRYPPREG		0x134	/* Retry buffer Purged ptr */
@@ -1700,17 +3279,20 @@
  };
  
  /* Register access */
++#define pcicore_read16(pc, offset)		bcma_read16((pc)->core, offset)
  #define pcicore_read32(pc, offset)		bcma_read32((pc)->core, offset)
++#define pcicore_write16(pc, offset, val)	bcma_write16((pc)->core, offset, val)
  #define pcicore_write32(pc, offset, val)	bcma_write32((pc)->core, offset, val)
  
 -extern void bcma_core_pci_init(struct bcma_drv_pci *pc);
 +extern void __devinit bcma_core_pci_init(struct bcma_drv_pci *pc);
  extern int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc,
  				 struct bcma_device *core, bool enable);
- 
++extern void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend);
++
 +extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
 +extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
-+
+ 
  #endif /* LINUX_BCMA_DRIVER_PCI_H_ */
 --- a/include/linux/bcma/bcma_regs.h
 +++ b/include/linux/bcma/bcma_regs.h
Index: target/linux/generic/patches-3.3/132-solos-dma.patch
===================================================================
--- target/linux/generic/patches-3.3/132-solos-dma.patch	(revision 0)
+++ target/linux/generic/patches-3.3/132-solos-dma.patch	(revision 0)
@@ -0,0 +1,442 @@
+commit b4bd8ad9bb311e8536f726f7a633620ccd358cde
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Thu May 24 04:58:27 2012 +0000
+
+    solos-pci: Fix DMA support
+    
+    DMA support has finally made its way to the top of the TODO list, having
+    realised that a Geode using MMIO can't keep up with two ADSL2+ lines
+    each running at 21Mb/s.
+    
+    This patch fixes a couple of bugs in the DMA support in the driver, so
+    once the corresponding FPGA update is complete and tested everything
+    should work properly.
+    
+    We weren't storing the currently-transmitting skb, so we were never
+    unmapping it and never freeing/popping it when the TX was done.
+    And the addition of pci_set_master() is fairly self-explanatory.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Cc: stable@kernel.org
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit 152a2a8b5e1d4cbe91a7c66f1028db15164a3766
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Wed Dec 19 11:01:21 2012 +0000
+
+    solos-pci: ensure all TX packets are aligned to 4 bytes
+    
+    The FPGA can't handled unaligned DMA (yet). So copy into an aligned buffer,
+    if skb->data isn't suitably aligned.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit 13af816469db3449c072afbae6c4c1bd9ccecccb
+Author: Nathan Williams <nathan@traverse.com.au>
+Date:   Wed Dec 19 11:01:20 2012 +0000
+
+    solos-pci: add firmware upgrade support for new models
+    
+    Signed-off-by: Nathan Williams <nathan@traverse.com.au>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit 7fbdadb5e951e4f0c0fc991ff5f50295568786e6
+Author: Nathan Williams <nathan@traverse.com.au>
+Date:   Wed Dec 19 11:01:19 2012 +0000
+
+    solos-pci: remove superfluous debug output
+    
+    Signed-off-by: Nathan Williams <nathan@traverse.com.au>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit f9baad02e7411d9f38d5ebe1a1cdcde4ceec100d
+Author: Nathan Williams <nathan@traverse.com.au>
+Date:   Wed Dec 19 11:01:18 2012 +0000
+
+    solos-pci: add GPIO support for newer versions on Geos board
+    
+    dwmw2: Tidy up a little, simpler matching on which GPIO is being accessed,
+           only register on newer boards, register under PCI device instead of
+           duplicating them under each ATM device.
+    
+    Signed-off-by: Nathan Williams <nathan@traverse.com.au>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit cae49ede00ec3d0cda290b03fee55b72b49efc11
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Tue Dec 11 14:57:14 2012 +0000
+
+    solos-pci: fix double-free of TX skb in DMA mode
+    
+    We weren't clearing card->tx_skb[port] when processing the TX done interrupt.
+    If there wasn't another skb ready to transmit immediately, this led to a
+    double-free because we'd free it *again* next time we did have a packet to
+    send.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Cc: stable@kernel.org
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+==
+There is a typo here so we do a double lock instead of an unlock.
+
+Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
+---
+Only needed in linux-next.  Introduced in f9baad02e7411d9 [14/17]
+solos-pci: add GPIO support for newer versions on Geos board
+
+
+--- a/drivers/atm/solos-pci.c
++++ b/drivers/atm/solos-pci.c
+@@ -42,7 +42,8 @@
+ #include <linux/swab.h>
+ #include <linux/slab.h>
+ 
+-#define VERSION "0.07"
++#define VERSION "1.04"
++#define DRIVER_VERSION 0x01
+ #define PTAG "solos-pci"
+ 
+ #define CONFIG_RAM_SIZE	128
+@@ -56,16 +57,21 @@
+ #define FLASH_BUSY	0x60
+ #define FPGA_MODE	0x5C
+ #define FLASH_MODE	0x58
++#define GPIO_STATUS	0x54
++#define DRIVER_VER	0x50
+ #define TX_DMA_ADDR(port)	(0x40 + (4 * (port)))
+ #define RX_DMA_ADDR(port)	(0x30 + (4 * (port)))
+ 
+ #define DATA_RAM_SIZE	32768
+ #define BUF_SIZE	2048
+ #define OLD_BUF_SIZE	4096 /* For FPGA versions <= 2*/
+-#define FPGA_PAGE	528 /* FPGA flash page size*/
+-#define SOLOS_PAGE	512 /* Solos flash page size*/
+-#define FPGA_BLOCK	(FPGA_PAGE * 8) /* FPGA flash block size*/
+-#define SOLOS_BLOCK	(SOLOS_PAGE * 8) /* Solos flash block size*/
++/* Old boards use ATMEL AD45DB161D flash */
++#define ATMEL_FPGA_PAGE	528 /* FPGA flash page size*/
++#define ATMEL_SOLOS_PAGE	512 /* Solos flash page size*/
++#define ATMEL_FPGA_BLOCK	(ATMEL_FPGA_PAGE * 8) /* FPGA block size*/
++#define ATMEL_SOLOS_BLOCK	(ATMEL_SOLOS_PAGE * 8) /* Solos block size*/
++/* Current boards use M25P/M25PE SPI flash */
++#define SPI_FLASH_BLOCK	(256 * 64)
+ 
+ #define RX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2)
+ #define TX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2 + (card->buffer_size))
+@@ -123,11 +129,14 @@ struct solos_card {
+ 	struct sk_buff_head cli_queue[4];
+ 	struct sk_buff *tx_skb[4];
+ 	struct sk_buff *rx_skb[4];
++	unsigned char *dma_bounce;
+ 	wait_queue_head_t param_wq;
+ 	wait_queue_head_t fw_wq;
+ 	int using_dma;
++	int dma_alignment;
+ 	int fpga_version;
+ 	int buffer_size;
++	int atmel_flash;
+ };
+ 
+ 
+@@ -452,7 +461,6 @@ static ssize_t console_show(struct devic
+ 
+ 	len = skb->len;
+ 	memcpy(buf, skb->data, len);
+-	dev_dbg(&card->dev->dev, "len: %d\n", len);
+ 
+ 	kfree_skb(skb);
+ 	return len;
+@@ -499,6 +507,78 @@ static ssize_t console_store(struct devi
+ 	return err?:count;
+ }
+ 
++struct geos_gpio_attr {
++	struct device_attribute attr;
++	int offset;
++};
++
++#define SOLOS_GPIO_ATTR(_name, _mode, _show, _store, _offset)	\
++	struct geos_gpio_attr gpio_attr_##_name = {		\
++		.attr = __ATTR(_name, _mode, _show, _store),	\
++		.offset = _offset }
++
++static ssize_t geos_gpio_store(struct device *dev, struct device_attribute *attr,
++			       const char *buf, size_t count)
++{
++	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
++	struct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);
++	struct solos_card *card = pci_get_drvdata(pdev);
++	uint32_t data32;
++
++	if (count != 1 && (count != 2 || buf[1] != '\n'))
++		return -EINVAL;
++
++	spin_lock_irq(&card->param_queue_lock);
++	data32 = ioread32(card->config_regs + GPIO_STATUS);
++	if (buf[0] == '1') {
++		data32 |= 1 << gattr->offset;
++		iowrite32(data32, card->config_regs + GPIO_STATUS);
++	} else if (buf[0] == '0') {
++		data32 &= ~(1 << gattr->offset);
++		iowrite32(data32, card->config_regs + GPIO_STATUS);
++	} else {
++		count = -EINVAL;
++	}
++	spin_unlock_irq(&card->param_queue_lock);
++	return count;
++}
++
++static ssize_t geos_gpio_show(struct device *dev, struct device_attribute *attr,
++			      char *buf)
++{
++	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
++	struct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);
++	struct solos_card *card = pci_get_drvdata(pdev);
++	uint32_t data32;
++
++	data32 = ioread32(card->config_regs + GPIO_STATUS);
++	data32 = (data32 >> gattr->offset) & 1;
++
++	return sprintf(buf, "%d\n", data32);
++}
++
++static ssize_t hardware_show(struct device *dev, struct device_attribute *attr,
++			     char *buf)
++{
++	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
++	struct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);
++	struct solos_card *card = pci_get_drvdata(pdev);
++	uint32_t data32;
++
++	data32 = ioread32(card->config_regs + GPIO_STATUS);
++	switch (gattr->offset) {
++	case 0:
++		/* HardwareVersion */
++		data32 = data32 & 0x1F;
++		break;
++	case 1:
++		/* HardwareVariant */
++		data32 = (data32 >> 5) & 0x0F;
++		break;
++	}
++	return sprintf(buf, "%d\n", data32);
++}
++
+ static DEVICE_ATTR(console, 0644, console_show, console_store);
+ 
+ 
+@@ -507,6 +587,14 @@ static DEVICE_ATTR(console, 0644, consol
+ 
+ #include "solos-attrlist.c"
+ 
++static SOLOS_GPIO_ATTR(GPIO1, 0644, geos_gpio_show, geos_gpio_store, 9);
++static SOLOS_GPIO_ATTR(GPIO2, 0644, geos_gpio_show, geos_gpio_store, 10);
++static SOLOS_GPIO_ATTR(GPIO3, 0644, geos_gpio_show, geos_gpio_store, 11);
++static SOLOS_GPIO_ATTR(GPIO4, 0644, geos_gpio_show, geos_gpio_store, 12);
++static SOLOS_GPIO_ATTR(GPIO5, 0644, geos_gpio_show, geos_gpio_store, 13);
++static SOLOS_GPIO_ATTR(PushButton, 0444, geos_gpio_show, NULL, 14);
++static SOLOS_GPIO_ATTR(HardwareVersion, 0444, hardware_show, NULL, 0);
++static SOLOS_GPIO_ATTR(HardwareVariant, 0444, hardware_show, NULL, 1);
+ #undef SOLOS_ATTR_RO
+ #undef SOLOS_ATTR_RW
+ 
+@@ -523,6 +611,23 @@ static struct attribute_group solos_attr
+ 	.name = "parameters",
+ };
+ 
++static struct attribute *gpio_attrs[] = {
++	&gpio_attr_GPIO1.attr.attr,
++	&gpio_attr_GPIO2.attr.attr,
++	&gpio_attr_GPIO3.attr.attr,
++	&gpio_attr_GPIO4.attr.attr,
++	&gpio_attr_GPIO5.attr.attr,
++	&gpio_attr_PushButton.attr.attr,
++	&gpio_attr_HardwareVersion.attr.attr,
++	&gpio_attr_HardwareVariant.attr.attr,
++	NULL
++};
++
++static struct attribute_group gpio_attr_group = {
++	.attrs = gpio_attrs,
++	.name = "gpio",
++};
++
+ static int flash_upgrade(struct solos_card *card, int chip)
+ {
+ 	const struct firmware *fw;
+@@ -534,16 +639,25 @@ static int flash_upgrade(struct solos_ca
+ 	switch (chip) {
+ 	case 0:
+ 		fw_name = "solos-FPGA.bin";
+-		blocksize = FPGA_BLOCK;
++		if (card->atmel_flash)
++			blocksize = ATMEL_FPGA_BLOCK;
++		else
++			blocksize = SPI_FLASH_BLOCK;
+ 		break;
+ 	case 1:
+ 		fw_name = "solos-Firmware.bin";
+-		blocksize = SOLOS_BLOCK;
++		if (card->atmel_flash)
++			blocksize = ATMEL_SOLOS_BLOCK;
++		else
++			blocksize = SPI_FLASH_BLOCK;
+ 		break;
+ 	case 2:
+ 		if (card->fpga_version > LEGACY_BUFFERS){
+ 			fw_name = "solos-db-FPGA.bin";
+-			blocksize = FPGA_BLOCK;
++			if (card->atmel_flash)
++				blocksize = ATMEL_FPGA_BLOCK;
++			else
++				blocksize = SPI_FLASH_BLOCK;
+ 		} else {
+ 			dev_info(&card->dev->dev, "FPGA version doesn't support"
+ 					" daughter board upgrades\n");
+@@ -553,7 +667,10 @@ static int flash_upgrade(struct solos_ca
+ 	case 3:
+ 		if (card->fpga_version > LEGACY_BUFFERS){
+ 			fw_name = "solos-Firmware.bin";
+-			blocksize = SOLOS_BLOCK;
++			if (card->atmel_flash)
++				blocksize = ATMEL_SOLOS_BLOCK;
++			else
++				blocksize = SPI_FLASH_BLOCK;
+ 		} else {
+ 			dev_info(&card->dev->dev, "FPGA version doesn't support"
+ 					" daughter board upgrades\n");
+@@ -569,6 +686,9 @@ static int flash_upgrade(struct solos_ca
+ 
+ 	dev_info(&card->dev->dev, "Flash upgrade starting\n");
+ 
++	/* New FPGAs require driver version before permitting flash upgrades */
++	iowrite32(DRIVER_VERSION, card->config_regs + DRIVER_VER);
++
+ 	numblocks = fw->size / blocksize;
+ 	dev_info(&card->dev->dev, "Firmware size: %zd\n", fw->size);
+ 	dev_info(&card->dev->dev, "Number of blocks: %d\n", numblocks);
+@@ -598,9 +718,13 @@ static int flash_upgrade(struct solos_ca
+ 		/* dev_info(&card->dev->dev, "Set FPGA Flash mode to Block Write\n"); */
+ 		iowrite32(((chip * 2) + 1), card->config_regs + FLASH_MODE);
+ 
+-		/* Copy block to buffer, swapping each 16 bits */
++		/* Copy block to buffer, swapping each 16 bits for Atmel flash */
+ 		for(i = 0; i < blocksize; i += 4) {
+-			uint32_t word = swahb32p((uint32_t *)(fw->data + offset + i));
++			uint32_t word;
++			if (card->atmel_flash)
++				word = swahb32p((uint32_t *)(fw->data + offset + i));
++			else
++				word = *(uint32_t *)(fw->data + offset + i);
+ 			if(card->fpga_version > LEGACY_BUFFERS)
+ 				iowrite32(word, FLASH_BUF + i);
+ 			else
+@@ -945,10 +1069,11 @@ static uint32_t fpga_tx(struct solos_car
+ 	for (port = 0; tx_pending; tx_pending >>= 1, port++) {
+ 		if (tx_pending & 1) {
+ 			struct sk_buff *oldskb = card->tx_skb[port];
+-			if (oldskb)
++			if (oldskb) {
+ 				pci_unmap_single(card->dev, SKB_CB(oldskb)->dma_addr,
+ 						 oldskb->len, PCI_DMA_TODEVICE);
+-
++				card->tx_skb[port] = NULL;
++			}
+ 			spin_lock(&card->tx_queue_lock);
+ 			skb = skb_dequeue(&card->tx_queue[port]);
+ 			if (!skb)
+@@ -960,8 +1085,14 @@ static uint32_t fpga_tx(struct solos_car
+ 				tx_started |= 1 << port;
+ 				oldskb = skb; /* We're done with this skb already */
+ 			} else if (skb && card->using_dma) {
+-				SKB_CB(skb)->dma_addr = pci_map_single(card->dev, skb->data,
++				unsigned char *data = skb->data;
++				if ((unsigned long)data & card->dma_alignment) {
++					data = card->dma_bounce + (BUF_SIZE * port);
++					memcpy(data, skb->data, skb->len);
++				}
++				SKB_CB(skb)->dma_addr = pci_map_single(card->dev, data,
+ 								       skb->len, PCI_DMA_TODEVICE);
++				card->tx_skb[port] = skb;
+ 				iowrite32(SKB_CB(skb)->dma_addr,
+ 					  card->config_regs + TX_DMA_ADDR(port));
+ 			}
+@@ -1133,17 +1264,33 @@ static int fpga_probe(struct pci_dev *de
+ 		db_fpga_upgrade = db_firmware_upgrade = 0;
+ 	}
+ 
+-	if (card->fpga_version >= DMA_SUPPORTED){
++	/* Stopped using Atmel flash after 0.03-38 */
++	if (fpga_ver < 39)
++		card->atmel_flash = 1;
++	else
++		card->atmel_flash = 0;
++
++	data32 = ioread32(card->config_regs + PORTS);
++	card->nr_ports = (data32 & 0x000000FF);
++
++	if (card->fpga_version >= DMA_SUPPORTED) {
++		pci_set_master(dev);
+ 		card->using_dma = 1;
++		if (1) { /* All known FPGA versions so far */
++			card->dma_alignment = 3;
++			card->dma_bounce = kmalloc(card->nr_ports * BUF_SIZE, GFP_KERNEL);
++			if (!card->dma_bounce) {
++				dev_warn(&card->dev->dev, "Failed to allocate DMA bounce buffers\n");
++				/* Fallback to MMIO doesn't work */
++				goto out_unmap_both;
++			}
++		}
+ 	} else {
+ 		card->using_dma = 0;
+ 		/* Set RX empty flag for all ports */
+ 		iowrite32(0xF0, card->config_regs + FLAGS_ADDR);
+ 	}
+ 
+-	data32 = ioread32(card->config_regs + PORTS);
+-	card->nr_ports = (data32 & 0x000000FF);
+-
+ 	pci_set_drvdata(dev, card);
+ 
+ 	tasklet_init(&card->tlet, solos_bh, (unsigned long)card);
+@@ -1178,6 +1325,10 @@ static int fpga_probe(struct pci_dev *de
+ 	if (err)
+ 		goto out_free_irq;
+ 
++	if (card->fpga_version >= DMA_SUPPORTED &&
++	    sysfs_create_group(&card->dev->dev.kobj, &gpio_attr_group))
++		dev_err(&card->dev->dev, "Could not register parameter group for GPIOs\n");
++
+ 	return 0;
+ 
+  out_free_irq:
+@@ -1186,6 +1337,7 @@ static int fpga_probe(struct pci_dev *de
+ 	tasklet_kill(&card->tlet);
+ 	
+  out_unmap_both:
++	kfree(card->dma_bounce);
+ 	pci_set_drvdata(dev, NULL);
+ 	pci_iounmap(dev, card->buffers);
+  out_unmap_config:
+@@ -1288,11 +1440,16 @@ static void fpga_remove(struct pci_dev *
+ 	iowrite32(1, card->config_regs + FPGA_MODE);
+ 	(void)ioread32(card->config_regs + FPGA_MODE); 
+ 
++	if (card->fpga_version >= DMA_SUPPORTED)
++		sysfs_remove_group(&card->dev->dev.kobj, &gpio_attr_group);
++
+ 	atm_remove(card);
+ 
+ 	free_irq(dev->irq, card);
+ 	tasklet_kill(&card->tlet);
+ 
++	kfree(card->dma_bounce);
++
+ 	/* Release device from reset */
+ 	iowrite32(0, card->config_regs + FPGA_MODE);
+ 	(void)ioread32(card->config_regs + FPGA_MODE); 
Index: target/linux/generic/patches-3.3/044-net-codel-fix-build-errors.patch
===================================================================
--- target/linux/generic/patches-3.3/044-net-codel-fix-build-errors.patch	(revision 0)
+++ target/linux/generic/patches-3.3/044-net-codel-fix-build-errors.patch	(revision 0)
@@ -0,0 +1,51 @@
+From b49ab5f6bb7e609190065cb9a605de809e50ab60 Mon Sep 17 00:00:00 2001
+From: Sasha Levin <levinsasha928@gmail.com>
+Date: Mon, 14 May 2012 11:57:06 +0000
+Subject: [PATCH] net: codel: fix build errors
+
+commit 669d67bf777def468970f2dcba1537edf3b2d329 upstream.
+
+Fix the following build error:
+
+net/sched/sch_fq_codel.c: In function 'fq_codel_dump_stats':
+net/sched/sch_fq_codel.c:464:3: error: unknown field 'qdisc_stats' specified in initializer
+net/sched/sch_fq_codel.c:464:3: warning: missing braces around initializer
+net/sched/sch_fq_codel.c:464:3: warning: (near initialization for 'st.<anonymous>')
+net/sched/sch_fq_codel.c:465:3: error: unknown field 'qdisc_stats' specified in initializer
+net/sched/sch_fq_codel.c:465:3: warning: excess elements in struct initializer
+net/sched/sch_fq_codel.c:465:3: warning: (near initialization for 'st')
+net/sched/sch_fq_codel.c:466:3: error: unknown field 'qdisc_stats' specified in initializer
+net/sched/sch_fq_codel.c:466:3: warning: excess elements in struct initializer
+net/sched/sch_fq_codel.c:466:3: warning: (near initialization for 'st')
+net/sched/sch_fq_codel.c:467:3: error: unknown field 'qdisc_stats' specified in initializer
+net/sched/sch_fq_codel.c:467:3: warning: excess elements in struct initializer
+net/sched/sch_fq_codel.c:467:3: warning: (near initialization for 'st')
+make[1]: *** [net/sched/sch_fq_codel.o] Error 1
+
+Signed-off-by: Sasha Levin <levinsasha928@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/sched/sch_fq_codel.c |    9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -461,13 +461,14 @@ static int fq_codel_dump_stats(struct Qd
+ 	struct fq_codel_sched_data *q = qdisc_priv(sch);
+ 	struct tc_fq_codel_xstats st = {
+ 		.type				= TCA_FQ_CODEL_XSTATS_QDISC,
+-		.qdisc_stats.maxpacket		= q->cstats.maxpacket,
+-		.qdisc_stats.drop_overlimit	= q->drop_overlimit,
+-		.qdisc_stats.ecn_mark		= q->cstats.ecn_mark,
+-		.qdisc_stats.new_flow_count	= q->new_flow_count,
+ 	};
+ 	struct list_head *pos;
+ 
++	st.qdisc_stats.maxpacket = q->cstats.maxpacket;
++	st.qdisc_stats.drop_overlimit = q->drop_overlimit;
++	st.qdisc_stats.ecn_mark = q->cstats.ecn_mark;
++	st.qdisc_stats.new_flow_count = q->new_flow_count;
++
+ 	list_for_each(pos, &q->new_flows)
+ 		st.qdisc_stats.new_flows_len++;
+ 
Index: target/linux/generic/patches-3.3/043-net-codel-Add-missing-include-linux-prefetch.h.patch
===================================================================
--- target/linux/generic/patches-3.3/043-net-codel-Add-missing-include-linux-prefetch.h.patch	(revision 0)
+++ target/linux/generic/patches-3.3/043-net-codel-Add-missing-include-linux-prefetch.h.patch	(revision 0)
@@ -0,0 +1,33 @@
+From 18c12e496ead3306de00a82d0bc73d71b34d7c24 Mon Sep 17 00:00:00 2001
+From: Geert Uytterhoeven <geert@linux-m68k.org>
+Date: Mon, 14 May 2012 09:47:05 +0000
+Subject: [PATCH] net/codel: Add missing #include <linux/prefetch.h>
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+commit ce5b4b977127ee20c3f9c3fd3637cd3796f649f5 upstream.
+
+m68k allmodconfig:
+
+net/sched/sch_codel.c: In function dequeue:
+net/sched/sch_codel.c:70: error: implicit declaration of function prefetch
+make[1]: *** [net/sched/sch_codel.o] Error 1
+
+Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
+Acked-by: Eric Dumazet <edumazet@google.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/sched/sch_codel.c |    1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/sched/sch_codel.c
++++ b/net/sched/sch_codel.c
+@@ -46,6 +46,7 @@
+ #include <linux/kernel.h>
+ #include <linux/errno.h>
+ #include <linux/skbuff.h>
++#include <linux/prefetch.h>
+ #include <net/pkt_sched.h>
+ #include <net/codel.h>
+ 
Index: target/linux/generic/patches-3.3/040-Controlled-Delay-AQM.patch
===================================================================
--- target/linux/generic/patches-3.3/040-Controlled-Delay-AQM.patch	(revision 0)
+++ target/linux/generic/patches-3.3/040-Controlled-Delay-AQM.patch	(revision 0)
@@ -0,0 +1,757 @@
+From a93fd80d261f1dc2788442dba8dd5701363d3d6e Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Thu, 10 May 2012 07:51:25 +0000
+Subject: [PATCH] codel: Controlled Delay AQM
+
+commit 76e3cc126bb223013a6b9a0e2a51238d1ef2e409 upstream.
+
+An implementation of CoDel AQM, from Kathleen Nichols and Van Jacobson.
+
+http://queue.acm.org/detail.cfm?id=2209336
+
+This AQM main input is no longer queue size in bytes or packets, but the
+delay packets stay in (FIFO) queue.
+
+As we don't have infinite memory, we still can drop packets in enqueue()
+in case of massive load, but mean of CoDel is to drop packets in
+dequeue(), using a control law based on two simple parameters :
+
+target : target sojourn time (default 5ms)
+interval : width of moving time window (default 100ms)
+
+Based on initial work from Dave Taht.
+
+Refactored to help future codel inclusion as a plugin for other linux
+qdisc (FQ_CODEL, ...), like RED.
+
+include/net/codel.h contains codel algorithm as close as possible than
+Kathleen reference.
+
+net/sched/sch_codel.c contains the linux qdisc specific glue.
+
+Separate structures permit a memory efficient implementation of fq_codel
+(to be sent as a separate work) : Each flow has its own struct
+codel_vars.
+
+timestamps are taken at enqueue() time with 1024 ns precision, allowing
+a range of 2199 seconds in queue, and 100Gb links support. iproute2 uses
+usec as base unit.
+
+Selected packets are dropped, unless ECN is enabled and packets can get
+ECN mark instead.
+
+Tested from 2Mb to 10Gb speeds with no particular problems, on ixgbe and
+tg3 drivers (BQL enabled).
+
+Usage: tc qdisc ... codel [ limit PACKETS ] [ target TIME ]
+                          [ interval TIME ] [ ecn ]
+
+qdisc codel 10: parent 1:1 limit 2000p target 3.0ms interval 60.0ms ecn
+ Sent 13347099587 bytes 8815805 pkt (dropped 0, overlimits 0 requeues 0)
+ rate 202365Kbit 16708pps backlog 113550b 75p requeues 0
+  count 116 lastcount 98 ldelay 4.3ms dropping drop_next 816us
+  maxpacket 1514 ecn_mark 84399 drop_overlimit 0
+
+CoDel must be seen as a base module, and should be used keeping in mind
+there is still a FIFO queue. So a typical setup will probably need a
+hierarchy of several qdiscs and packet classifiers to be able to meet
+whatever constraints a user might have.
+
+One possible example would be to use fq_codel, which combines Fair
+Queueing and CoDel, in replacement of sfq / sfq_red.
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Signed-off-by: Dave Taht <dave.taht@bufferbloat.net>
+Cc: Kathleen Nichols <nichols@pollere.com>
+Cc: Van Jacobson <van@pollere.net>
+Cc: Tom Herbert <therbert@google.com>
+Cc: Matt Mathis <mattmathis@google.com>
+Cc: Yuchung Cheng <ycheng@google.com>
+Cc: Stephen Hemminger <shemminger@vyatta.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/pkt_sched.h |   26 ++++
+ include/net/codel.h       |  332 +++++++++++++++++++++++++++++++++++++++++++++
+ net/sched/Kconfig         |   11 ++
+ net/sched/Makefile        |    1 +
+ net/sched/sch_codel.c     |  275 +++++++++++++++++++++++++++++++++++++
+ 5 files changed, 645 insertions(+)
+ create mode 100644 include/net/codel.h
+ create mode 100644 net/sched/sch_codel.c
+
+--- a/include/linux/pkt_sched.h
++++ b/include/linux/pkt_sched.h
+@@ -633,4 +633,30 @@ struct tc_qfq_stats {
+ 	__u32 lmax;
+ };
+ 
++/* CODEL */
++
++enum {
++	TCA_CODEL_UNSPEC,
++	TCA_CODEL_TARGET,
++	TCA_CODEL_LIMIT,
++	TCA_CODEL_INTERVAL,
++	TCA_CODEL_ECN,
++	__TCA_CODEL_MAX
++};
++
++#define TCA_CODEL_MAX	(__TCA_CODEL_MAX - 1)
++
++struct tc_codel_xstats {
++	__u32	maxpacket; /* largest packet we've seen so far */
++	__u32	count;	   /* how many drops we've done since the last time we
++			    * entered dropping state
++			    */
++	__u32	lastcount; /* count at entry to dropping state */
++	__u32	ldelay;    /* in-queue delay seen by most recently dequeued packet */
++	__s32	drop_next; /* time to drop next packet */
++	__u32	drop_overlimit; /* number of time max qdisc packet limit was hit */
++	__u32	ecn_mark;  /* number of packets we ECN marked instead of dropped */
++	__u32	dropping;  /* are we in dropping state ? */
++};
++
+ #endif
+--- /dev/null
++++ b/include/net/codel.h
+@@ -0,0 +1,332 @@
++#ifndef __NET_SCHED_CODEL_H
++#define __NET_SCHED_CODEL_H
++
++/*
++ * Codel - The Controlled-Delay Active Queue Management algorithm
++ *
++ *  Copyright (C) 2011-2012 Kathleen Nichols <nichols@pollere.com>
++ *  Copyright (C) 2011-2012 Van Jacobson <van@pollere.net>
++ *  Copyright (C) 2012 Michael D. Taht <dave.taht@bufferbloat.net>
++ *  Copyright (C) 2012 Eric Dumazet <edumazet@google.com>
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions, and the following disclaimer,
++ *    without modification.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. The names of the authors may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * Alternatively, provided that this notice is retained in full, this
++ * software may be distributed under the terms of the GNU General
++ * Public License ("GPL") version 2, in which case the provisions of the
++ * GPL apply INSTEAD OF those given above.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
++ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
++ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
++ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
++ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
++ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
++ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
++ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
++ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
++ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
++ * DAMAGE.
++ *
++ */
++
++#include <linux/types.h>
++#include <linux/ktime.h>
++#include <linux/skbuff.h>
++#include <net/pkt_sched.h>
++#include <net/inet_ecn.h>
++
++/* Controlling Queue Delay (CoDel) algorithm
++ * =========================================
++ * Source : Kathleen Nichols and Van Jacobson
++ * http://queue.acm.org/detail.cfm?id=2209336
++ *
++ * Implemented on linux by Dave Taht and Eric Dumazet
++ */
++
++
++/* CoDel uses a 1024 nsec clock, encoded in u32
++ * This gives a range of 2199 seconds, because of signed compares
++ */
++typedef u32 codel_time_t;
++typedef s32 codel_tdiff_t;
++#define CODEL_SHIFT 10
++#define MS2TIME(a) ((a * NSEC_PER_MSEC) >> CODEL_SHIFT)
++
++static inline codel_time_t codel_get_time(void)
++{
++	u64 ns = ktime_to_ns(ktime_get());
++
++	return ns >> CODEL_SHIFT;
++}
++
++#define codel_time_after(a, b)		((s32)(a) - (s32)(b) > 0)
++#define codel_time_after_eq(a, b)	((s32)(a) - (s32)(b) >= 0)
++#define codel_time_before(a, b)		((s32)(a) - (s32)(b) < 0)
++#define codel_time_before_eq(a, b)	((s32)(a) - (s32)(b) <= 0)
++
++/* Qdiscs using codel plugin must use codel_skb_cb in their own cb[] */
++struct codel_skb_cb {
++	codel_time_t enqueue_time;
++};
++
++static struct codel_skb_cb *get_codel_cb(const struct sk_buff *skb)
++{
++	qdisc_cb_private_validate(skb, sizeof(struct codel_skb_cb));
++	return (struct codel_skb_cb *)qdisc_skb_cb(skb)->data;
++}
++
++static codel_time_t codel_get_enqueue_time(const struct sk_buff *skb)
++{
++	return get_codel_cb(skb)->enqueue_time;
++}
++
++static void codel_set_enqueue_time(struct sk_buff *skb)
++{
++	get_codel_cb(skb)->enqueue_time = codel_get_time();
++}
++
++static inline u32 codel_time_to_us(codel_time_t val)
++{
++	u64 valns = ((u64)val << CODEL_SHIFT);
++
++	do_div(valns, NSEC_PER_USEC);
++	return (u32)valns;
++}
++
++/**
++ * struct codel_params - contains codel parameters
++ * @target:	target queue size (in time units)
++ * @interval:	width of moving time window
++ * @ecn:	is Explicit Congestion Notification enabled
++ */
++struct codel_params {
++	codel_time_t	target;
++	codel_time_t	interval;
++	bool		ecn;
++};
++
++/**
++ * struct codel_vars - contains codel variables
++ * @count:		how many drops we've done since the last time we
++ *			entered dropping state
++ * @lastcount:		count at entry to dropping state
++ * @dropping:		set to true if in dropping state
++ * @first_above_time:	when we went (or will go) continuously above target
++ *			for interval
++ * @drop_next:		time to drop next packet, or when we dropped last
++ * @ldelay:		sojourn time of last dequeued packet
++ */
++struct codel_vars {
++	u32		count;
++	u32		lastcount;
++	bool		dropping;
++	codel_time_t	first_above_time;
++	codel_time_t	drop_next;
++	codel_time_t	ldelay;
++};
++
++/**
++ * struct codel_stats - contains codel shared variables and stats
++ * @maxpacket:	largest packet we've seen so far
++ * @drop_count:	temp count of dropped packets in dequeue()
++ * ecn_mark:	number of packets we ECN marked instead of dropping
++ */
++struct codel_stats {
++	u32		maxpacket;
++	u32		drop_count;
++	u32		ecn_mark;
++};
++
++static void codel_params_init(struct codel_params *params)
++{
++	params->interval = MS2TIME(100);
++	params->target = MS2TIME(5);
++	params->ecn = false;
++}
++
++static void codel_vars_init(struct codel_vars *vars)
++{
++	vars->drop_next = 0;
++	vars->first_above_time = 0;
++	vars->dropping = false; /* exit dropping state */
++	vars->count = 0;
++	vars->lastcount = 0;
++}
++
++static void codel_stats_init(struct codel_stats *stats)
++{
++	stats->maxpacket = 256;
++}
++
++/* return interval/sqrt(x) with good precision
++ * relies on int_sqrt(unsigned long x) kernel implementation
++ */
++static u32 codel_inv_sqrt(u32 _interval, u32 _x)
++{
++	u64 interval = _interval;
++	unsigned long x = _x;
++
++	/* Scale operands for max precision */
++
++#if BITS_PER_LONG == 64
++	x <<= 32; /* On 64bit arches, we can prescale x by 32bits */
++	interval <<= 16;
++#endif
++
++	while (x < (1UL << (BITS_PER_LONG - 2))) {
++		x <<= 2;
++		interval <<= 1;
++	}
++	do_div(interval, int_sqrt(x));
++	return (u32)interval;
++}
++
++static codel_time_t codel_control_law(codel_time_t t,
++				      codel_time_t interval,
++				      u32 count)
++{
++	return t + codel_inv_sqrt(interval, count);
++}
++
++
++static bool codel_should_drop(struct sk_buff *skb,
++			      unsigned int *backlog,
++			      struct codel_vars *vars,
++			      struct codel_params *params,
++			      struct codel_stats *stats,
++			      codel_time_t now)
++{
++	bool ok_to_drop;
++
++	if (!skb) {
++		vars->first_above_time = 0;
++		return false;
++	}
++
++	vars->ldelay = now - codel_get_enqueue_time(skb);
++	*backlog -= qdisc_pkt_len(skb);
++
++	if (unlikely(qdisc_pkt_len(skb) > stats->maxpacket))
++		stats->maxpacket = qdisc_pkt_len(skb);
++
++	if (codel_time_before(vars->ldelay, params->target) ||
++	    *backlog <= stats->maxpacket) {
++		/* went below - stay below for at least interval */
++		vars->first_above_time = 0;
++		return false;
++	}
++	ok_to_drop = false;
++	if (vars->first_above_time == 0) {
++		/* just went above from below. If we stay above
++		 * for at least interval we'll say it's ok to drop
++		 */
++		vars->first_above_time = now + params->interval;
++	} else if (codel_time_after(now, vars->first_above_time)) {
++		ok_to_drop = true;
++	}
++	return ok_to_drop;
++}
++
++typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *vars,
++						struct Qdisc *sch);
++
++static struct sk_buff *codel_dequeue(struct Qdisc *sch,
++				     struct codel_params *params,
++				     struct codel_vars *vars,
++				     struct codel_stats *stats,
++				     codel_skb_dequeue_t dequeue_func,
++				     u32 *backlog)
++{
++	struct sk_buff *skb = dequeue_func(vars, sch);
++	codel_time_t now;
++	bool drop;
++
++	if (!skb) {
++		vars->dropping = false;
++		return skb;
++	}
++	now = codel_get_time();
++	drop = codel_should_drop(skb, backlog, vars, params, stats, now);
++	if (vars->dropping) {
++		if (!drop) {
++			/* sojourn time below target - leave dropping state */
++			vars->dropping = false;
++		} else if (codel_time_after_eq(now, vars->drop_next)) {
++			/* It's time for the next drop. Drop the current
++			 * packet and dequeue the next. The dequeue might
++			 * take us out of dropping state.
++			 * If not, schedule the next drop.
++			 * A large backlog might result in drop rates so high
++			 * that the next drop should happen now,
++			 * hence the while loop.
++			 */
++			while (vars->dropping &&
++			       codel_time_after_eq(now, vars->drop_next)) {
++				if (++vars->count == 0) /* avoid zero divides */
++					vars->count = ~0U;
++				if (params->ecn && INET_ECN_set_ce(skb)) {
++					stats->ecn_mark++;
++					vars->drop_next =
++						codel_control_law(vars->drop_next,
++								  params->interval,
++								  vars->count);
++					goto end;
++				}
++				qdisc_drop(skb, sch);
++				stats->drop_count++;
++				skb = dequeue_func(vars, sch);
++				if (!codel_should_drop(skb, backlog,
++						       vars, params, stats, now)) {
++					/* leave dropping state */
++					vars->dropping = false;
++				} else {
++					/* and schedule the next drop */
++					vars->drop_next =
++						codel_control_law(vars->drop_next,
++								  params->interval,
++								  vars->count);
++				}
++			}
++		}
++	} else if (drop) {
++		if (params->ecn && INET_ECN_set_ce(skb)) {
++			stats->ecn_mark++;
++		} else {
++			qdisc_drop(skb, sch);
++			stats->drop_count++;
++
++			skb = dequeue_func(vars, sch);
++			drop = codel_should_drop(skb, backlog, vars, params,
++						 stats, now);
++		}
++		vars->dropping = true;
++		/* if min went above target close to when we last went below it
++		 * assume that the drop rate that controlled the queue on the
++		 * last cycle is a good starting point to control it now.
++		 */
++		if (codel_time_before(now - vars->drop_next,
++				      16 * params->interval)) {
++			vars->count = (vars->count - vars->lastcount) | 1;
++		} else {
++			vars->count = 1;
++		}
++		vars->lastcount = vars->count;
++		vars->drop_next = codel_control_law(now, params->interval,
++						    vars->count);
++	}
++end:
++	return skb;
++}
++#endif
+--- a/net/sched/Kconfig
++++ b/net/sched/Kconfig
+@@ -250,6 +250,17 @@ config NET_SCH_QFQ
+ 
+ 	  If unsure, say N.
+ 
++config NET_SCH_CODEL
++	tristate "Controlled Delay AQM (CODEL)"
++	help
++	  Say Y here if you want to use the Controlled Delay (CODEL)
++	  packet scheduling algorithm.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called sch_codel.
++
++	  If unsure, say N.
++
+ config NET_SCH_INGRESS
+ 	tristate "Ingress Qdisc"
+ 	depends on NET_CLS_ACT
+--- a/net/sched/Makefile
++++ b/net/sched/Makefile
+@@ -36,6 +36,7 @@ obj-$(CONFIG_NET_SCH_DRR)	+= sch_drr.o
+ obj-$(CONFIG_NET_SCH_MQPRIO)	+= sch_mqprio.o
+ obj-$(CONFIG_NET_SCH_CHOKE)	+= sch_choke.o
+ obj-$(CONFIG_NET_SCH_QFQ)	+= sch_qfq.o
++obj-$(CONFIG_NET_SCH_CODEL)	+= sch_codel.o
+ 
+ obj-$(CONFIG_NET_CLS_U32)	+= cls_u32.o
+ obj-$(CONFIG_NET_CLS_ROUTE4)	+= cls_route.o
+--- /dev/null
++++ b/net/sched/sch_codel.c
+@@ -0,0 +1,275 @@
++/*
++ * Codel - The Controlled-Delay Active Queue Management algorithm
++ *
++ *  Copyright (C) 2011-2012 Kathleen Nichols <nichols@pollere.com>
++ *  Copyright (C) 2011-2012 Van Jacobson <van@pollere.net>
++ *
++ *  Implemented on linux by :
++ *  Copyright (C) 2012 Michael D. Taht <dave.taht@bufferbloat.net>
++ *  Copyright (C) 2012 Eric Dumazet <edumazet@google.com>
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions, and the following disclaimer,
++ *    without modification.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. The names of the authors may not be used to endorse or promote products
++ *    derived from this software without specific prior written permission.
++ *
++ * Alternatively, provided that this notice is retained in full, this
++ * software may be distributed under the terms of the GNU General
++ * Public License ("GPL") version 2, in which case the provisions of the
++ * GPL apply INSTEAD OF those given above.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
++ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
++ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
++ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
++ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
++ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
++ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
++ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
++ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
++ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
++ * DAMAGE.
++ *
++ */
++
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/skbuff.h>
++#include <net/pkt_sched.h>
++#include <net/codel.h>
++
++
++#define DEFAULT_CODEL_LIMIT 1000
++
++struct codel_sched_data {
++	struct codel_params	params;
++	struct codel_vars	vars;
++	struct codel_stats	stats;
++	u32			drop_overlimit;
++};
++
++/* This is the specific function called from codel_dequeue()
++ * to dequeue a packet from queue. Note: backlog is handled in
++ * codel, we dont need to reduce it here.
++ */
++static struct sk_buff *dequeue(struct codel_vars *vars, struct Qdisc *sch)
++{
++	struct sk_buff *skb = __skb_dequeue(&sch->q);
++
++	prefetch(&skb->end); /* we'll need skb_shinfo() */
++	return skb;
++}
++
++static struct sk_buff *codel_qdisc_dequeue(struct Qdisc *sch)
++{
++	struct codel_sched_data *q = qdisc_priv(sch);
++	struct sk_buff *skb;
++
++	skb = codel_dequeue(sch, &q->params, &q->vars, &q->stats,
++			    dequeue, &sch->qstats.backlog);
++	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,
++	 * or HTB crashes. Defer it for next round.
++	 */
++	if (q->stats.drop_count && sch->q.qlen) {
++		qdisc_tree_decrease_qlen(sch, q->stats.drop_count);
++		q->stats.drop_count = 0;
++	}
++	if (skb)
++		qdisc_bstats_update(sch, skb);
++	return skb;
++}
++
++static int codel_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++{
++	struct codel_sched_data *q;
++
++	if (likely(qdisc_qlen(sch) < sch->limit)) {
++		codel_set_enqueue_time(skb);
++		return qdisc_enqueue_tail(skb, sch);
++	}
++	q = qdisc_priv(sch);
++	q->drop_overlimit++;
++	return qdisc_drop(skb, sch);
++}
++
++static const struct nla_policy codel_policy[TCA_CODEL_MAX + 1] = {
++	[TCA_CODEL_TARGET]	= { .type = NLA_U32 },
++	[TCA_CODEL_LIMIT]	= { .type = NLA_U32 },
++	[TCA_CODEL_INTERVAL]	= { .type = NLA_U32 },
++	[TCA_CODEL_ECN]		= { .type = NLA_U32 },
++};
++
++static int codel_change(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct codel_sched_data *q = qdisc_priv(sch);
++	struct nlattr *tb[TCA_CODEL_MAX + 1];
++	unsigned int qlen;
++	int err;
++
++	if (!opt)
++		return -EINVAL;
++
++	err = nla_parse_nested(tb, TCA_CODEL_MAX, opt, codel_policy);
++	if (err < 0)
++		return err;
++
++	sch_tree_lock(sch);
++
++	if (tb[TCA_CODEL_TARGET]) {
++		u32 target = nla_get_u32(tb[TCA_CODEL_TARGET]);
++
++		q->params.target = ((u64)target * NSEC_PER_USEC) >> CODEL_SHIFT;
++	}
++
++	if (tb[TCA_CODEL_INTERVAL]) {
++		u32 interval = nla_get_u32(tb[TCA_CODEL_INTERVAL]);
++
++		q->params.interval = ((u64)interval * NSEC_PER_USEC) >> CODEL_SHIFT;
++	}
++
++	if (tb[TCA_CODEL_LIMIT])
++		sch->limit = nla_get_u32(tb[TCA_CODEL_LIMIT]);
++
++	if (tb[TCA_CODEL_ECN])
++		q->params.ecn = !!nla_get_u32(tb[TCA_CODEL_ECN]);
++
++	qlen = sch->q.qlen;
++	while (sch->q.qlen > sch->limit) {
++		struct sk_buff *skb = __skb_dequeue(&sch->q);
++
++		sch->qstats.backlog -= qdisc_pkt_len(skb);
++		qdisc_drop(skb, sch);
++	}
++	qdisc_tree_decrease_qlen(sch, qlen - sch->q.qlen);
++
++	sch_tree_unlock(sch);
++	return 0;
++}
++
++static int codel_init(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct codel_sched_data *q = qdisc_priv(sch);
++
++	sch->limit = DEFAULT_CODEL_LIMIT;
++
++	codel_params_init(&q->params);
++	codel_vars_init(&q->vars);
++	codel_stats_init(&q->stats);
++
++	if (opt) {
++		int err = codel_change(sch, opt);
++
++		if (err)
++			return err;
++	}
++
++	if (sch->limit >= 1)
++		sch->flags |= TCQ_F_CAN_BYPASS;
++	else
++		sch->flags &= ~TCQ_F_CAN_BYPASS;
++
++	return 0;
++}
++
++static int codel_dump(struct Qdisc *sch, struct sk_buff *skb)
++{
++	struct codel_sched_data *q = qdisc_priv(sch);
++	struct nlattr *opts;
++
++	opts = nla_nest_start(skb, TCA_OPTIONS);
++	if (opts == NULL)
++		goto nla_put_failure;
++
++	if (nla_put_u32(skb, TCA_CODEL_TARGET,
++			codel_time_to_us(q->params.target)) ||
++	    nla_put_u32(skb, TCA_CODEL_LIMIT,
++			sch->limit) ||
++	    nla_put_u32(skb, TCA_CODEL_INTERVAL,
++			codel_time_to_us(q->params.interval)) ||
++	    nla_put_u32(skb, TCA_CODEL_ECN,
++			q->params.ecn))
++		goto nla_put_failure;
++
++	return nla_nest_end(skb, opts);
++
++nla_put_failure:
++	nla_nest_cancel(skb, opts);
++	return -1;
++}
++
++static int codel_dump_stats(struct Qdisc *sch, struct gnet_dump *d)
++{
++	const struct codel_sched_data *q = qdisc_priv(sch);
++	struct tc_codel_xstats st = {
++		.maxpacket	= q->stats.maxpacket,
++		.count		= q->vars.count,
++		.lastcount	= q->vars.lastcount,
++		.drop_overlimit = q->drop_overlimit,
++		.ldelay		= codel_time_to_us(q->vars.ldelay),
++		.dropping	= q->vars.dropping,
++		.ecn_mark	= q->stats.ecn_mark,
++	};
++
++	if (q->vars.dropping) {
++		codel_tdiff_t delta = q->vars.drop_next - codel_get_time();
++
++		if (delta >= 0)
++			st.drop_next = codel_time_to_us(delta);
++		else
++			st.drop_next = -codel_time_to_us(-delta);
++	}
++
++	return gnet_stats_copy_app(d, &st, sizeof(st));
++}
++
++static void codel_reset(struct Qdisc *sch)
++{
++	struct codel_sched_data *q = qdisc_priv(sch);
++
++	qdisc_reset_queue(sch);
++	codel_vars_init(&q->vars);
++}
++
++static struct Qdisc_ops codel_qdisc_ops __read_mostly = {
++	.id		=	"codel",
++	.priv_size	=	sizeof(struct codel_sched_data),
++
++	.enqueue	=	codel_qdisc_enqueue,
++	.dequeue	=	codel_qdisc_dequeue,
++	.peek		=	qdisc_peek_dequeued,
++	.init		=	codel_init,
++	.reset		=	codel_reset,
++	.change 	=	codel_change,
++	.dump		=	codel_dump,
++	.dump_stats	=	codel_dump_stats,
++	.owner		=	THIS_MODULE,
++};
++
++static int __init codel_module_init(void)
++{
++	return register_qdisc(&codel_qdisc_ops);
++}
++
++static void __exit codel_module_exit(void)
++{
++	unregister_qdisc(&codel_qdisc_ops);
++}
++
++module_init(codel_module_init)
++module_exit(codel_module_exit)
++
++MODULE_DESCRIPTION("Controlled Delay queue discipline");
++MODULE_AUTHOR("Dave Taht");
++MODULE_AUTHOR("Eric Dumazet");
++MODULE_LICENSE("Dual BSD/GPL");
Index: target/linux/generic/patches-3.3/729-phy-tantos.patch
===================================================================
--- target/linux/generic/patches-3.3/729-phy-tantos.patch	(revision 0)
+++ target/linux/generic/patches-3.3/729-phy-tantos.patch	(revision 0)
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -206,3 +206,8 @@ endif # PHYLIB
+ config MICREL_KS8995MA
+ 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
+ 	depends on SPI
++
++config PSB6970_PHY
++	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
++	select SWCONFIG
++	select ETHERNET_PACKET_MANGLE
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -28,6 +28,7 @@ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
++obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
Index: target/linux/generic/patches-3.3/443-block2mtd-avoid-recursive-call-of-mtd_writev.patch
===================================================================
--- target/linux/generic/patches-3.3/443-block2mtd-avoid-recursive-call-of-mtd_writev.patch	(revision 0)
+++ target/linux/generic/patches-3.3/443-block2mtd-avoid-recursive-call-of-mtd_writev.patch	(revision 0)
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/devices/block2mtd.c
++++ b/drivers/mtd/devices/block2mtd.c
+@@ -388,7 +388,6 @@ static struct block2mtd_dev *add_device(
+ 	dev->mtd.flags = MTD_CAP_RAM;
+ 	dev->mtd.erase = block2mtd_erase;
+ 	dev->mtd.write = block2mtd_write;
+-	dev->mtd.writev = mtd_writev;
+ 	dev->mtd.sync = block2mtd_sync;
+ 	dev->mtd.read = block2mtd_read;
+ 	dev->mtd.priv = dev;
Index: target/linux/generic/patches-3.3/941-ocf_20110720.patch
===================================================================
--- target/linux/generic/patches-3.3/941-ocf_20110720.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/941-ocf_20110720.patch	(working copy)
@@ -1,133 +0,0 @@
---- a/kernel/pid.c
-+++ b/kernel/pid.c
-@@ -430,6 +430,7 @@ struct task_struct *find_task_by_vpid(pi
- {
- 	return find_task_by_pid_ns(vnr, current->nsproxy->pid_ns);
- }
-+EXPORT_SYMBOL(find_task_by_vpid);
- 
- struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
- {
---- a/drivers/char/random.c
-+++ b/drivers/char/random.c
-@@ -130,6 +130,9 @@
-  * 	void add_interrupt_randomness(int irq);
-  * 	void add_disk_randomness(struct gendisk *disk);
-  *
-+ *      void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
-+ *      int random_input_wait(void);
-+ *
-  * add_input_randomness() uses the input layer interrupt timing, as well as
-  * the event type information from the hardware.
-  *
-@@ -147,6 +150,13 @@
-  * seek times do not make for good sources of entropy, as their seek
-  * times are usually fairly consistent.
-  *
-+ * random_input_words() just provides a raw block of entropy to the input
-+ * pool, such as from a hardware entropy generator.
-+ *
-+ * random_input_wait() suspends the caller until such time as the
-+ * entropy pool falls below the write threshold, and returns a count of how
-+ * much entropy (in bits) is needed to sustain the pool.
-+ *
-  * All of these routines try to estimate how many bits of randomness a
-  * particular randomness source.  They do this by keeping track of the
-  * first and second order deltas of the event timings.
-@@ -726,6 +736,63 @@ void add_disk_randomness(struct gendisk 
- }
- #endif
- 
-+/*
-+ * random_input_words - add bulk entropy to pool
-+ *
-+ * @buf: buffer to add
-+ * @wordcount: number of __u32 words to add
-+ * @ent_count: total amount of entropy (in bits) to credit
-+ *
-+ * this provides bulk input of entropy to the input pool
-+ *
-+ */
-+void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
-+{
-+	mix_pool_bytes(&input_pool, buf, wordcount*4);
-+
-+	credit_entropy_bits(&input_pool, ent_count);
-+
-+	DEBUG_ENT("crediting %d bits => %d\n",
-+		  ent_count, input_pool.entropy_count);
-+	/*
-+	 * Wake up waiting processes if we have enough
-+	 * entropy.
-+	 */
-+	if (input_pool.entropy_count >= random_read_wakeup_thresh)
-+		wake_up_interruptible(&random_read_wait);
-+}
-+EXPORT_SYMBOL(random_input_words);
-+
-+/*
-+ * random_input_wait - wait until random needs entropy
-+ *
-+ * this function sleeps until the /dev/random subsystem actually
-+ * needs more entropy, and then return the amount of entropy
-+ * that it would be nice to have added to the system.
-+ */
-+int random_input_wait(void)
-+{
-+	int count;
-+
-+	wait_event_interruptible(random_write_wait, 
-+			 input_pool.entropy_count < random_write_wakeup_thresh);
-+
-+	count = random_write_wakeup_thresh - input_pool.entropy_count;
-+
-+        /* likely we got woken up due to a signal */
-+	if (count <= 0) count = random_read_wakeup_thresh; 
-+
-+	DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
-+		  count,
-+		  input_pool.entropy_count, random_write_wakeup_thresh);
-+
-+	return count;
-+}
-+EXPORT_SYMBOL(random_input_wait);
-+
-+
-+#define EXTRACT_SIZE 10
-+
- /*********************************************************************
-  *
-  * Entropy extraction routines
---- a/fs/fcntl.c
-+++ b/fs/fcntl.c
-@@ -142,6 +142,7 @@ SYSCALL_DEFINE1(dup, unsigned int, filde
- 	}
- 	return ret;
- }
-+EXPORT_SYMBOL(sys_dup);
- 
- #define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | O_DIRECT | O_NOATIME)
- 
---- a/include/linux/miscdevice.h
-+++ b/include/linux/miscdevice.h
-@@ -19,6 +19,7 @@
- #define APOLLO_MOUSE_MINOR	7
- #define PC110PAD_MINOR		9
- /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
-+#define CRYPTODEV_MINOR		70	/* /dev/crypto */
- #define WATCHDOG_MINOR		130	/* Watchdog timer     */
- #define TEMP_MINOR		131	/* Temperature Sensor */
- #define RTC_MINOR		135
---- a/include/linux/random.h
-+++ b/include/linux/random.h
-@@ -54,6 +54,10 @@ extern void add_input_randomness(unsigne
- 				 unsigned int value);
- extern void add_interrupt_randomness(int irq);
- 
-+extern void random_input_words(__u32 *buf, size_t wordcount, int ent_count);
-+extern int random_input_wait(void);
-+#define HAS_RANDOM_INPUT_WAIT 1
-+
- extern void get_random_bytes(void *buf, int nbytes);
- void generate_random_uuid(unsigned char uuid_out[16]);
- 
Index: target/linux/generic/patches-3.3/028-bcma-fix-regression-in-interrupt-assignment-on-mips.patch
===================================================================
--- target/linux/generic/patches-3.3/028-bcma-fix-regression-in-interrupt-assignment-on-mips.patch	(revision 0)
+++ target/linux/generic/patches-3.3/028-bcma-fix-regression-in-interrupt-assignment-on-mips.patch	(revision 0)
@@ -0,0 +1,29 @@
+--- a/drivers/bcma/driver_mips.c
++++ b/drivers/bcma/driver_mips.c
+@@ -131,7 +131,7 @@ static void bcma_core_mips_set_irq(struc
+ 			/* backplane irq line is in use, find out who uses
+ 			 * it and set user to irq 0
+ 			 */
+-			list_for_each_entry_reverse(core, &bus->cores, list) {
++			list_for_each_entry(core, &bus->cores, list) {
+ 				if ((1 << bcma_core_mips_irqflag(core)) ==
+ 				    oldirqflag) {
+ 					bcma_core_mips_set_irq(core, 0);
+@@ -161,7 +161,7 @@ static void bcma_core_mips_dump_irq(stru
+ {
+ 	struct bcma_device *core;
+ 
+-	list_for_each_entry_reverse(core, &bus->cores, list) {
++	list_for_each_entry(core, &bus->cores, list) {
+ 		bcma_core_mips_print_irq(core, bcma_core_mips_irq(core));
+ 	}
+ }
+@@ -215,7 +215,7 @@ void bcma_core_mips_init(struct bcma_drv
+ 		mcore->assigned_irqs = 1;
+ 
+ 	/* Assign IRQs to all cores on the bus */
+-	list_for_each_entry_reverse(core, &bus->cores, list) {
++	list_for_each_entry(core, &bus->cores, list) {
+ 		int mips_irq;
+ 		if (core->irq)
+ 			continue;
Index: target/linux/generic/patches-3.3/131-atm-fixes.patch
===================================================================
--- target/linux/generic/patches-3.3/131-atm-fixes.patch	(revision 0)
+++ target/linux/generic/patches-3.3/131-atm-fixes.patch	(revision 0)
@@ -0,0 +1,900 @@
+commit d7d3d8f1ee4435e32bc6c93187798b7e2e3170a9
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Thu Nov 29 23:28:30 2012 +0000
+
+    solos-pci: remove list_vccs() debugging function
+    
+    No idea why we've gone so long dumping a list of VCCs with vci==0 on
+    every ->open() call...
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit c93967bfd3a3dffa759a3f28370167bf3cdbc3d0
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Thu Nov 29 23:27:20 2012 +0000
+
+    solos-pci: use GFP_KERNEL where possible, not GFP_ATOMIC
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit ad6999e17ae4f7b99f6d28f425ae970acb115347
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Thu Nov 29 23:15:30 2012 +0000
+
+    solos-pci: clean up pclose() function
+    
+     - Flush pending TX skbs from the queue rather than waiting for them all to
+       complete (suggested by Krzysztof Mazur <krzysiek@podlesie.net>).
+     - Clear ATM_VF_ADDR only when the PKT_PCLOSE packet has been submitted.
+     - Don't clear ATM_VF_READY at all  vcc_destroy_socket() does that for us.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit 2547e97f29d6d69d567947d5ef90b6b4fbcaf565
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Wed Nov 28 10:15:05 2012 +0000
+
+    pppoatm: optimise PPP channel wakeups after sock_owned_by_user()
+    
+    We don't need to schedule the wakeup tasklet on *every* unlock; only if we
+    actually blocked the channel in the first place.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>
+
+commit 990b0884a2e9668c08e9daa4d70a54d65329cb6f
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Wed Nov 28 09:08:04 2012 +0100
+
+    br2684: allow assign only on a connected socket
+    
+    The br2684 does not check if used vcc is in connected state,
+    causing potential Oops in pppoatm_send() when vcc->send() is called
+    on not fully connected socket.
+    
+    Now br2684 can be assigned only on connected sockets; otherwise
+    -EINVAL error is returned.
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit f49b6da01f0abebb17f6241473d53018d923f6b0
+Author: Nathan Williams <nathan@traverse.com.au>
+Date:   Tue Nov 27 17:34:09 2012 +1100
+
+    solos-pci: Fix leak of skb received for unknown vcc
+    
+    ... and ensure that the next skb is set up for RX in the DMA case.
+    
+    Signed-off-by: Nathan Williams <nathan@traverse.com.au>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit a61d37ff4a555886c4ebe31d2c6d893afb6f4d3c
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Wed Nov 28 00:46:45 2012 +0000
+
+    br2684: fix module_put() race
+    
+    The br2684 code used module_put() during unassignment from vcc with
+    hope that we have BKL. This assumption is no longer true.
+    
+    Now owner field in atmvcc is used to move this module_put()
+    to vcc_destroy_socket().
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>
+
+commit c52f40629884ddc62c7af445fd5d620fdb466fb2
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Wed Nov 28 00:05:52 2012 +0000
+
+    pppoatm: fix missing wakeup in pppoatm_send()
+    
+    Now that we can return zero from pppoatm_send() for reasons *other* than
+    the queue being full, that means we can't depend on a subsequent call to
+    pppoatm_pop() waking the queue, and we might leave it stalled
+    indefinitely.
+    
+    Use the ->release_cb() callback to wake the queue after the sock is
+    unlocked.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>
+
+commit 35826e7372fe39b7db7930eda0267c82d68d1a4c
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Tue Nov 27 23:28:36 2012 +0000
+
+    br2684: don't send frames on not-ready vcc
+    
+    Avoid submitting packets to a vcc which is being closed. Things go badly
+    wrong when the ->pop method gets later called after everything's been
+    torn down.
+    
+    Use the ATM socket lock for synchronisation with vcc_destroy_socket(),
+    which clears the ATM_VF_READY bit under the same lock. Otherwise, we
+    could end up submitting a packet to the device driver even after its
+    ->ops->close method has been called. And it could call the vcc's ->pop
+    method after the protocol has been shut down. Which leads to a panic.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>
+
+commit 7f940dde65de4a707f3dd723bb6ce9de90ca1eab
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Wed Nov 28 00:03:11 2012 +0000
+
+    atm: add release_cb() callback to vcc
+    
+    The immediate use case for this is that it will allow us to ensure that a
+    pppoatm queue is woken after it has to drop a packet due to the sock being
+    locked.
+    
+    Note that 'release_cb' is called when the socket is *unlocked*. This is
+    not to be confused with vcc_release()  which probably ought to be called
+    vcc_close().
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>
+
+commit def1b2f9083f84d0a77730e537c76429914d17c1
+Author: David Woodhouse <David.Woodhouse@intel.com>
+Date:   Tue Nov 27 23:49:24 2012 +0000
+
+    solos-pci: wait for pending TX to complete when releasing vcc
+    
+    We should no longer be calling the old pop routine for the vcc, after
+    vcc_release() has completed. Make sure we wait for any pending TX skbs
+    to complete, by waiting for our own PKT_PCLOSE control skb to be sent.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit 397ff16dce53888ec693b3718640be2560204751
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Tue Nov 6 23:17:02 2012 +0100
+
+    pppoatm: do not inline pppoatm_may_send()
+    
+    The pppoatm_may_send() is quite heavy and it's called three times
+    in pppoatm_send() and inlining costs more than 200 bytes of code
+    (more than 10% of total pppoatm driver code size).
+    
+    add/remove: 1/0 grow/shrink: 0/1 up/down: 132/-367 (-235)
+    function                                     old     new   delta
+    pppoatm_may_send                               -     132    +132
+    pppoatm_send                                 900     533    -367
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit 071d93931a75dc1f82f0baa9959613af81c5a032
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Sat Nov 10 23:33:19 2012 +0100
+
+    pppoatm: drop frames to not-ready vcc
+    
+    The vcc_destroy_socket() closes vcc before the protocol is detached
+    from vcc by calling vcc->push() with NULL skb. This leaves some time
+    window, where the protocol may call vcc->send() on closed vcc
+    and crash.
+    
+    Now pppoatm_send(), like vcc_sendmsg(), checks for vcc flags that
+    indicate that vcc is not ready. If the vcc is not ready we just
+    drop frame. Queueing frames is much more complicated because we
+    don't have callbacks that inform us about vcc flags changes.
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit 3ac108006fd7f20cb8fc8ea2287f1497bcda00a1
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Tue Nov 6 23:17:00 2012 +0100
+
+    pppoatm: take ATM socket lock in pppoatm_send()
+    
+    The pppoatm_send() does not take any lock that will prevent concurrent
+    vcc_sendmsg(). This causes two problems:
+    
+    	- there is no locking between checking the send queue size
+    	  with atm_may_send() and incrementing sk_wmem_alloc,
+    	  and the real queue size can be a little higher than sk_sndbuf
+    
+    	- the vcc->sendmsg() can be called concurrently. I'm not sure
+    	  if it's allowed. Some drivers (eni, nicstar, ...) seem
+    	  to assume it will never happen.
+    
+    Now pppoatm_send() takes ATM socket lock, the same that is used
+    in vcc_sendmsg() and other ATM socket functions. The pppoatm_send()
+    is called with BH disabled, so bh_lock_sock() is used instead
+    of lock_sock().
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Cc: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit e41faed9cde1acce657f75a0b19a1787e9850d3f
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Tue Nov 6 23:16:59 2012 +0100
+
+    pppoatm: fix module_put() race
+    
+    The pppoatm used module_put() during unassignment from vcc with
+    hope that we have BKL. This assumption is no longer true.
+    
+    Now owner field in atmvcc is used to move this module_put()
+    to vcc_destroy_socket().
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit 3b1a914595f3f9beb9e38ff3ddc7bdafa092ba22
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Tue Nov 6 23:16:58 2012 +0100
+
+    pppoatm: allow assign only on a connected socket
+    
+    The pppoatm does not check if used vcc is in connected state,
+    causing an Oops in pppoatm_send() when vcc->send() is called
+    on not fully connected socket.
+    
+    Now pppoatm can be assigned only on connected sockets; otherwise
+    -EINVAL error is returned.
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Cc: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+
+commit ec809bd817dfa1905283468e4c813684ed4efe78
+Author: Krzysztof Mazur <krzysiek@podlesie.net>
+Date:   Tue Nov 6 23:16:57 2012 +0100
+
+    atm: add owner of push() callback to atmvcc
+    
+    The atm is using atmvcc->push(vcc, NULL) callback to notify protocol
+    that vcc will be closed and protocol must detach from it. This callback
+    is usually used by protocol to decrement module usage count by module_put(),
+    but it leaves small window then module is still used after module_put().
+    
+    Now the owner of push() callback is kept in atmvcc and
+    module_put(atmvcc->owner) is called after the protocol is detached from vcc.
+    
+    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>
+
+commit ae088d663beebb3cad0e7abaac67ee61a7c578d5
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Sun Nov 25 12:06:52 2012 +0000
+
+    atm: br2684: Fix excessive queue bloat
+    
+    There's really no excuse for an additional wmem_default of buffering
+    between the netdev queue and the ATM device. Two packets (one in-flight,
+    and one ready to send) ought to be fine. It's not as if it should take
+    long to get another from the netdev queue when we need it.
+    
+    If necessary we can make the queue space configurable later, but I don't
+    think it's likely to be necessary.
+    
+    cf. commit 9d02daf754238adac48fa075ee79e7edd3d79ed3 (pppoatm: Fix
+    excessive queue bloat) which did something very similar for PPPoATM.
+    
+    Note that there is a tremendously unlikely race condition which may
+    result in qspace temporarily going negative. If a CPU running the
+    br2684_pop() function goes off into the weeds for a long period of time
+    after incrementing qspace to 1, but before calling netdev_wake_queue()...
+    and another CPU ends up calling br2684_start_xmit() and *stopping* the
+    queue again before the first CPU comes back, the netdev queue could
+    end up being woken when qspace has already reached zero.
+    
+    An alternative approach to coping with this race would be to check in
+    br2684_start_xmit() for qspace==0 and return NETDEV_TX_BUSY, but just
+    using '> 0' and '< 1' for comparison instead of '== 0' and '!= 0' is
+    simpler. It just warranted a mention of *why* we do it that way...
+    
+    Move the call to atmvcc->send() to happen *after* the accounting and
+    potentially stopping the netdev queue, in br2684_xmit_vcc(). This matters
+    if the ->send() call suffers an immediate failure, because it'll call
+    br2684_pop() with the offending skb before returning. We want that to
+    happen *after* we've done the initial accounting for the packet in
+    question. Also make it return an appropriate success/failure indication
+    while we're at it.
+    
+    Tested by running 'ping -l 1000 bottomless.aaisp.net.uk' from within my
+    network, with only a single PPPoE-over-BR2684 link running. And after
+    setting txqueuelen on the nas0 interface to something low (5, in fact).
+    Before the patch, we'd see about 15 packets being queued and a resulting
+    latency of ~56ms being reached. After the patch, we see only about 8,
+    which is fairly much what we expect. And a max latency of ~36ms. On this
+    OpenWRT box, wmem_default is 163840.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Reviewed-by: Krzysztof Mazur <krzysiek@podlesie.net>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+--- a/drivers/atm/solos-pci.c
++++ b/drivers/atm/solos-pci.c
+@@ -92,6 +92,7 @@ struct pkt_hdr {
+ };
+ 
+ struct solos_skb_cb {
++	struct completion c;
+ 	struct atm_vcc *vcc;
+ 	uint32_t dma_addr;
+ };
+@@ -164,7 +165,6 @@ static void fpga_queue(struct solos_card
+ static uint32_t fpga_tx(struct solos_card *);
+ static irqreturn_t solos_irq(int irq, void *dev_id);
+ static struct atm_vcc* find_vcc(struct atm_dev *dev, short vpi, int vci);
+-static int list_vccs(int vci);
+ static int atm_init(struct solos_card *, struct device *);
+ static void atm_remove(struct solos_card *);
+ static int send_command(struct solos_card *card, int dev, const char *buf, size_t size);
+@@ -710,7 +710,8 @@ void solos_bh(unsigned long card_arg)
+ 						dev_warn(&card->dev->dev, "Received packet for unknown VPI.VCI %d.%d on port %d\n",
+ 							 le16_to_cpu(header->vpi), le16_to_cpu(header->vci),
+ 							 port);
+-					continue;
++					dev_kfree_skb_any(skb);
++					break;
+ 				}
+ 				atm_charge(vcc, skb->truesize);
+ 				vcc->push(vcc, skb);
+@@ -790,44 +791,6 @@ static struct atm_vcc *find_vcc(struct a
+ 	return vcc;
+ }
+ 
+-static int list_vccs(int vci)
+-{
+-	struct hlist_head *head;
+-	struct atm_vcc *vcc;
+-	struct hlist_node *node;
+-	struct sock *s;
+-	int num_found = 0;
+-	int i;
+-
+-	read_lock(&vcc_sklist_lock);
+-	if (vci != 0){
+-		head = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];
+-		sk_for_each(s, node, head) {
+-			num_found ++;
+-			vcc = atm_sk(s);
+-			printk(KERN_DEBUG "Device: %d Vpi: %d Vci: %d\n",
+-			       vcc->dev->number,
+-			       vcc->vpi,
+-			       vcc->vci);
+-		}
+-	} else {
+-		for(i = 0; i < VCC_HTABLE_SIZE; i++){
+-			head = &vcc_hash[i];
+-			sk_for_each(s, node, head) {
+-				num_found ++;
+-				vcc = atm_sk(s);
+-				printk(KERN_DEBUG "Device: %d Vpi: %d Vci: %d\n",
+-				       vcc->dev->number,
+-				       vcc->vpi,
+-				       vcc->vci);
+-			}
+-		}
+-	}
+-	read_unlock(&vcc_sklist_lock);
+-	return num_found;
+-}
+-
+-
+ static int popen(struct atm_vcc *vcc)
+ {
+ 	struct solos_card *card = vcc->dev->dev_data;
+@@ -840,7 +803,7 @@ static int popen(struct atm_vcc *vcc)
+ 		return -EINVAL;
+ 	}
+ 
+-	skb = alloc_skb(sizeof(*header), GFP_ATOMIC);
++	skb = alloc_skb(sizeof(*header), GFP_KERNEL);
+ 	if (!skb) {
+ 		if (net_ratelimit())
+ 			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in popen()\n");
+@@ -857,8 +820,6 @@ static int popen(struct atm_vcc *vcc)
+ 
+ 	set_bit(ATM_VF_ADDR, &vcc->flags);
+ 	set_bit(ATM_VF_READY, &vcc->flags);
+-	list_vccs(0);
+-
+ 
+ 	return 0;
+ }
+@@ -866,10 +827,21 @@ static int popen(struct atm_vcc *vcc)
+ static void pclose(struct atm_vcc *vcc)
+ {
+ 	struct solos_card *card = vcc->dev->dev_data;
+-	struct sk_buff *skb;
++	unsigned char port = SOLOS_CHAN(vcc->dev);
++	struct sk_buff *skb, *tmpskb;
+ 	struct pkt_hdr *header;
+ 
+-	skb = alloc_skb(sizeof(*header), GFP_ATOMIC);
++	/* Remove any yet-to-be-transmitted packets from the pending queue */
++	spin_lock(&card->tx_queue_lock);
++	skb_queue_walk_safe(&card->tx_queue[port], skb, tmpskb) {
++		if (SKB_CB(skb)->vcc == vcc) {
++			skb_unlink(skb, &card->tx_queue[port]);
++			solos_pop(vcc, skb);
++		}
++	}
++	spin_unlock(&card->tx_queue_lock);
++
++	skb = alloc_skb(sizeof(*header), GFP_KERNEL);
+ 	if (!skb) {
+ 		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in pclose()\n");
+ 		return;
+@@ -881,15 +853,21 @@ static void pclose(struct atm_vcc *vcc)
+ 	header->vci = cpu_to_le16(vcc->vci);
+ 	header->type = cpu_to_le16(PKT_PCLOSE);
+ 
+-	fpga_queue(card, SOLOS_CHAN(vcc->dev), skb, NULL);
++	init_completion(&SKB_CB(skb)->c);
+ 
+-	clear_bit(ATM_VF_ADDR, &vcc->flags);
+-	clear_bit(ATM_VF_READY, &vcc->flags);
++	fpga_queue(card, port, skb, NULL);
++
++	if (!wait_for_completion_timeout(&SKB_CB(skb)->c, 5 * HZ))
++		dev_warn(&card->dev->dev, "Timeout waiting for VCC close on port %d\n",
++			 port);
+ 
+ 	/* Hold up vcc_destroy_socket() (our caller) until solos_bh() in the
+ 	   tasklet has finished processing any incoming packets (and, more to
+ 	   the point, using the vcc pointer). */
+ 	tasklet_unlock_wait(&card->tlet);
++
++	clear_bit(ATM_VF_ADDR, &vcc->flags);
++
+ 	return;
+ }
+ 
+@@ -1010,9 +988,12 @@ static uint32_t fpga_tx(struct solos_car
+ 			if (vcc) {
+ 				atomic_inc(&vcc->stats->tx);
+ 				solos_pop(vcc, oldskb);
+-			} else
++			} else {
++				struct pkt_hdr *header = (void *)oldskb->data;
++				if (le16_to_cpu(header->type) == PKT_PCLOSE)
++					complete(&SKB_CB(oldskb)->c);
+ 				dev_kfree_skb_irq(oldskb);
+-
++			}
+ 		}
+ 	}
+ 	/* For non-DMA TX, write the 'TX start' bit for all four ports simultaneously */
+@@ -1246,7 +1227,7 @@ static int atm_init(struct solos_card *c
+ 		card->atmdev[i]->phy_data = (void *)(unsigned long)i;
+ 		atm_dev_signal_change(card->atmdev[i], ATM_PHY_SIG_FOUND);
+ 
+-		skb = alloc_skb(sizeof(*header), GFP_ATOMIC);
++		skb = alloc_skb(sizeof(*header), GFP_KERNEL);
+ 		if (!skb) {
+ 			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in atm_init()\n");
+ 			continue;
+@@ -1343,6 +1324,8 @@ static struct pci_driver fpga_driver = {
+ 
+ static int __init solos_pci_init(void)
+ {
++	BUILD_BUG_ON(sizeof(struct solos_skb_cb) > sizeof(((struct sk_buff *)0)->cb));
++
+ 	printk(KERN_INFO "Solos PCI Driver Version %s\n", VERSION);
+ 	return pci_register_driver(&fpga_driver);
+ }
+--- a/include/linux/atmdev.h
++++ b/include/linux/atmdev.h
+@@ -307,6 +307,7 @@ struct atm_vcc {
+ 	struct atm_dev	*dev;		/* device back pointer */
+ 	struct atm_qos	qos;		/* QOS */
+ 	struct atm_sap	sap;		/* SAP */
++	void (*release_cb)(struct atm_vcc *vcc); /* release_sock callback */
+ 	void (*push)(struct atm_vcc *vcc,struct sk_buff *skb);
+ 	void (*pop)(struct atm_vcc *vcc,struct sk_buff *skb); /* optional */
+ 	int (*push_oam)(struct atm_vcc *vcc,void *cell);
+@@ -314,6 +315,7 @@ struct atm_vcc {
+ 	void		*dev_data;	/* per-device data */
+ 	void		*proto_data;	/* per-protocol data */
+ 	struct k_atm_aal_stats *stats;	/* pointer to AAL stats group */
++	struct module *owner;		/* owner of ->push function */
+ 	/* SVC part --- may move later ------------------------------------- */
+ 	short		itf;		/* interface number */
+ 	struct sockaddr_atmsvc local;
+--- a/net/atm/br2684.c
++++ b/net/atm/br2684.c
+@@ -68,12 +68,15 @@ struct br2684_vcc {
+ 	/* keep old push, pop functions for chaining */
+ 	void (*old_push)(struct atm_vcc *vcc, struct sk_buff *skb);
+ 	void (*old_pop)(struct atm_vcc *vcc, struct sk_buff *skb);
++	void (*old_release_cb)(struct atm_vcc *vcc);
++	struct module *old_owner;
+ 	enum br2684_encaps encaps;
+ 	struct list_head brvccs;
+ #ifdef CONFIG_ATM_BR2684_IPFILTER
+ 	struct br2684_filter filter;
+ #endif /* CONFIG_ATM_BR2684_IPFILTER */
+ 	unsigned copies_needed, copies_failed;
++	atomic_t qspace;
+ };
+ 
+ struct br2684_dev {
+@@ -181,18 +184,15 @@ static struct notifier_block atm_dev_not
+ static void br2684_pop(struct atm_vcc *vcc, struct sk_buff *skb)
+ {
+ 	struct br2684_vcc *brvcc = BR2684_VCC(vcc);
+-	struct net_device *net_dev = skb->dev;
+ 
+-	pr_debug("(vcc %p ; net_dev %p )\n", vcc, net_dev);
++	pr_debug("(vcc %p ; net_dev %p )\n", vcc, brvcc->device);
+ 	brvcc->old_pop(vcc, skb);
+ 
+-	if (!net_dev)
+-		return;
+-
+-	if (atm_may_send(vcc, 0))
+-		netif_wake_queue(net_dev);
+-
++	/* If the queue space just went up from zero, wake */
++	if (atomic_inc_return(&brvcc->qspace) == 1)
++		netif_wake_queue(brvcc->device);
+ }
++
+ /*
+  * Send a packet out a particular vcc.  Not to useful right now, but paves
+  * the way for multiple vcc's per itf.  Returns true if we can send,
+@@ -256,16 +256,30 @@ static int br2684_xmit_vcc(struct sk_buf
+ 	ATM_SKB(skb)->atm_options = atmvcc->atm_options;
+ 	dev->stats.tx_packets++;
+ 	dev->stats.tx_bytes += skb->len;
+-	atmvcc->send(atmvcc, skb);
+ 
+-	if (!atm_may_send(atmvcc, 0)) {
++	if (atomic_dec_return(&brvcc->qspace) < 1) {
++		/* No more please! */
+ 		netif_stop_queue(brvcc->device);
+-		/*check for race with br2684_pop*/
+-		if (atm_may_send(atmvcc, 0))
+-			netif_start_queue(brvcc->device);
++		/* We might have raced with br2684_pop() */
++		if (unlikely(atomic_read(&brvcc->qspace) > 0))
++			netif_wake_queue(brvcc->device);
+ 	}
+ 
+-	return 1;
++	/* If this fails immediately, the skb will be freed and br2684_pop()
++	   will wake the queue if appropriate. Just return an error so that
++	   the stats are updated correctly */
++	return !atmvcc->send(atmvcc, skb);
++}
++
++static void br2684_release_cb(struct atm_vcc *atmvcc)
++{
++	struct br2684_vcc *brvcc = BR2684_VCC(atmvcc);
++
++	if (atomic_read(&brvcc->qspace) > 0)
++		netif_wake_queue(brvcc->device);
++
++	if (brvcc->old_release_cb)
++		brvcc->old_release_cb(atmvcc);
+ }
+ 
+ static inline struct br2684_vcc *pick_outgoing_vcc(const struct sk_buff *skb,
+@@ -279,6 +293,8 @@ static netdev_tx_t br2684_start_xmit(str
+ {
+ 	struct br2684_dev *brdev = BRPRIV(dev);
+ 	struct br2684_vcc *brvcc;
++	struct atm_vcc *atmvcc;
++	netdev_tx_t ret = NETDEV_TX_OK;
+ 
+ 	pr_debug("skb_dst(skb)=%p\n", skb_dst(skb));
+ 	read_lock(&devs_lock);
+@@ -289,9 +305,26 @@ static netdev_tx_t br2684_start_xmit(str
+ 		dev->stats.tx_carrier_errors++;
+ 		/* netif_stop_queue(dev); */
+ 		dev_kfree_skb(skb);
+-		read_unlock(&devs_lock);
+-		return NETDEV_TX_OK;
++		goto out_devs;
+ 	}
++	atmvcc = brvcc->atmvcc;
++
++	bh_lock_sock(sk_atm(atmvcc));
++
++	if (test_bit(ATM_VF_RELEASED, &atmvcc->flags) ||
++	    test_bit(ATM_VF_CLOSE, &atmvcc->flags) ||
++	    !test_bit(ATM_VF_READY, &atmvcc->flags)) {
++		dev->stats.tx_dropped++;
++		dev_kfree_skb(skb);
++		goto out;
++	}
++
++	if (sock_owned_by_user(sk_atm(atmvcc))) {
++		netif_stop_queue(brvcc->device);
++		ret = NETDEV_TX_BUSY;
++		goto out;
++	}
++
+ 	if (!br2684_xmit_vcc(skb, dev, brvcc)) {
+ 		/*
+ 		 * We should probably use netif_*_queue() here, but that
+@@ -303,8 +336,11 @@ static netdev_tx_t br2684_start_xmit(str
+ 		dev->stats.tx_errors++;
+ 		dev->stats.tx_fifo_errors++;
+ 	}
++ out:
++	bh_unlock_sock(sk_atm(atmvcc));
++ out_devs:
+ 	read_unlock(&devs_lock);
+-	return NETDEV_TX_OK;
++	return ret;
+ }
+ 
+ /*
+@@ -377,9 +413,10 @@ static void br2684_close_vcc(struct br26
+ 	list_del(&brvcc->brvccs);
+ 	write_unlock_irq(&devs_lock);
+ 	brvcc->atmvcc->user_back = NULL;	/* what about vcc->recvq ??? */
++	brvcc->atmvcc->release_cb = brvcc->old_release_cb;
+ 	brvcc->old_push(brvcc->atmvcc, NULL);	/* pass on the bad news */
++	module_put(brvcc->old_owner);
+ 	kfree(brvcc);
+-	module_put(THIS_MODULE);
+ }
+ 
+ /* when AAL5 PDU comes in: */
+@@ -504,6 +541,13 @@ static int br2684_regvcc(struct atm_vcc
+ 	brvcc = kzalloc(sizeof(struct br2684_vcc), GFP_KERNEL);
+ 	if (!brvcc)
+ 		return -ENOMEM;
++	/*
++	 * Allow two packets in the ATM queue. One actually being sent, and one
++	 * for the ATM 'TX done' handler to send. It shouldn't take long to get
++	 * the next one from the netdev queue, when we need it. More than that
++	 * would be bufferbloat.
++	 */
++	atomic_set(&brvcc->qspace, 2);
+ 	write_lock_irq(&devs_lock);
+ 	net_dev = br2684_find_dev(&be.ifspec);
+ 	if (net_dev == NULL) {
+@@ -546,9 +590,13 @@ static int br2684_regvcc(struct atm_vcc
+ 	brvcc->encaps = (enum br2684_encaps)be.encaps;
+ 	brvcc->old_push = atmvcc->push;
+ 	brvcc->old_pop = atmvcc->pop;
++	brvcc->old_release_cb = atmvcc->release_cb;
++	brvcc->old_owner = atmvcc->owner;
+ 	barrier();
+ 	atmvcc->push = br2684_push;
+ 	atmvcc->pop = br2684_pop;
++	atmvcc->release_cb = br2684_release_cb;
++	atmvcc->owner = THIS_MODULE;
+ 
+ 	/* initialize netdev carrier state */
+ 	if (atmvcc->dev->signal == ATM_PHY_SIG_LOST)
+@@ -687,10 +735,13 @@ static int br2684_ioctl(struct socket *s
+ 			return -ENOIOCTLCMD;
+ 		if (!capable(CAP_NET_ADMIN))
+ 			return -EPERM;
+-		if (cmd == ATM_SETBACKEND)
++		if (cmd == ATM_SETBACKEND) {
++			if (sock->state != SS_CONNECTED)
++				return -EINVAL;
+ 			return br2684_regvcc(atmvcc, argp);
+-		else
++		} else {
+ 			return br2684_create(argp);
++		}
+ #ifdef CONFIG_ATM_BR2684_IPFILTER
+ 	case BR2684_SETFILT:
+ 		if (atmvcc->push != br2684_push)
+--- a/net/atm/common.c
++++ b/net/atm/common.c
+@@ -126,10 +126,19 @@ static void vcc_write_space(struct sock
+ 	rcu_read_unlock();
+ }
+ 
++static void vcc_release_cb(struct sock *sk)
++{
++	struct atm_vcc *vcc = atm_sk(sk);
++
++	if (vcc->release_cb)
++		vcc->release_cb(vcc);
++}
++
+ static struct proto vcc_proto = {
+ 	.name	  = "VCC",
+ 	.owner	  = THIS_MODULE,
+ 	.obj_size = sizeof(struct atm_vcc),
++	.release_cb = vcc_release_cb,
+ };
+ 
+ int vcc_create(struct net *net, struct socket *sock, int protocol, int family)
+@@ -156,7 +165,9 @@ int vcc_create(struct net *net, struct s
+ 	atomic_set(&sk->sk_rmem_alloc, 0);
+ 	vcc->push = NULL;
+ 	vcc->pop = NULL;
++	vcc->owner = NULL;
+ 	vcc->push_oam = NULL;
++	vcc->release_cb = NULL;
+ 	vcc->vpi = vcc->vci = 0; /* no VCI/VPI yet */
+ 	vcc->atm_options = vcc->aal_options = 0;
+ 	sk->sk_destruct = vcc_sock_destruct;
+@@ -175,6 +186,7 @@ static void vcc_destroy_socket(struct so
+ 			vcc->dev->ops->close(vcc);
+ 		if (vcc->push)
+ 			vcc->push(vcc, NULL); /* atmarpd has no push */
++		module_put(vcc->owner);
+ 
+ 		while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {
+ 			atm_return(vcc, skb->truesize);
+--- a/net/atm/pppoatm.c
++++ b/net/atm/pppoatm.c
+@@ -60,6 +60,8 @@ struct pppoatm_vcc {
+ 	struct atm_vcc	*atmvcc;	/* VCC descriptor */
+ 	void (*old_push)(struct atm_vcc *, struct sk_buff *);
+ 	void (*old_pop)(struct atm_vcc *, struct sk_buff *);
++	void (*old_release_cb)(struct atm_vcc *);
++	struct module *old_owner;
+ 					/* keep old push/pop for detaching */
+ 	enum pppoatm_encaps encaps;
+ 	atomic_t inflight;
+@@ -107,6 +109,24 @@ static void pppoatm_wakeup_sender(unsign
+ 	ppp_output_wakeup((struct ppp_channel *) arg);
+ }
+ 
++static void pppoatm_release_cb(struct atm_vcc *atmvcc)
++{
++	struct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);
++
++	/*
++	 * As in pppoatm_pop(), it's safe to clear the BLOCKED bit here because
++	 * the wakeup *can't* race with pppoatm_send(). They both hold the PPP
++	 * channel's ->downl lock. And the potential race with *setting* it,
++	 * which leads to the double-check dance in pppoatm_may_send(), doesn't
++	 * exist here. In the sock_owned_by_user() case in pppoatm_send(), we
++	 * set the BLOCKED bit while the socket is still locked. We know that
++	 * ->release_cb() can't be called until that's done.
++	 */
++	if (test_and_clear_bit(BLOCKED, &pvcc->blocked))
++		tasklet_schedule(&pvcc->wakeup_tasklet);
++	if (pvcc->old_release_cb)
++		pvcc->old_release_cb(atmvcc);
++}
+ /*
+  * This gets called every time the ATM card has finished sending our
+  * skb.  The ->old_pop will take care up normal atm flow control,
+@@ -151,12 +171,11 @@ static void pppoatm_unassign_vcc(struct
+ 	pvcc = atmvcc_to_pvcc(atmvcc);
+ 	atmvcc->push = pvcc->old_push;
+ 	atmvcc->pop = pvcc->old_pop;
++	atmvcc->release_cb = pvcc->old_release_cb;
+ 	tasklet_kill(&pvcc->wakeup_tasklet);
+ 	ppp_unregister_channel(&pvcc->chan);
+ 	atmvcc->user_back = NULL;
+ 	kfree(pvcc);
+-	/* Gee, I hope we have the big kernel lock here... */
+-	module_put(THIS_MODULE);
+ }
+ 
+ /* Called when an AAL5 PDU comes in */
+@@ -165,9 +184,13 @@ static void pppoatm_push(struct atm_vcc
+ 	struct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);
+ 	pr_debug("\n");
+ 	if (skb == NULL) {			/* VCC was closed */
++		struct module *module;
++
+ 		pr_debug("removing ATMPPP VCC %p\n", pvcc);
++		module = pvcc->old_owner;
+ 		pppoatm_unassign_vcc(atmvcc);
+ 		atmvcc->push(atmvcc, NULL);	/* Pass along bad news */
++		module_put(module);
+ 		return;
+ 	}
+ 	atm_return(atmvcc, skb->truesize);
+@@ -211,7 +234,7 @@ error:
+ 	ppp_input_error(&pvcc->chan, 0);
+ }
+ 
+-static inline int pppoatm_may_send(struct pppoatm_vcc *pvcc, int size)
++static int pppoatm_may_send(struct pppoatm_vcc *pvcc, int size)
+ {
+ 	/*
+ 	 * It's not clear that we need to bother with using atm_may_send()
+@@ -269,10 +292,33 @@ static inline int pppoatm_may_send(struc
+ static int pppoatm_send(struct ppp_channel *chan, struct sk_buff *skb)
+ {
+ 	struct pppoatm_vcc *pvcc = chan_to_pvcc(chan);
++	struct atm_vcc *vcc;
++	int ret;
++
+ 	ATM_SKB(skb)->vcc = pvcc->atmvcc;
+ 	pr_debug("(skb=0x%p, vcc=0x%p)\n", skb, pvcc->atmvcc);
+ 	if (skb->data[0] == '\0' && (pvcc->flags & SC_COMP_PROT))
+ 		(void) skb_pull(skb, 1);
++
++	vcc = ATM_SKB(skb)->vcc;
++	bh_lock_sock(sk_atm(vcc));
++	if (sock_owned_by_user(sk_atm(vcc))) {
++		/*
++		 * Needs to happen (and be flushed, hence test_and_) before we unlock
++		 * the socket. It needs to be seen by the time our ->release_cb gets
++		 * called.
++		 */
++		test_and_set_bit(BLOCKED, &pvcc->blocked);
++		goto nospace;
++	}
++	if (test_bit(ATM_VF_RELEASED, &vcc->flags) ||
++	    test_bit(ATM_VF_CLOSE, &vcc->flags) ||
++	    !test_bit(ATM_VF_READY, &vcc->flags)) {
++		bh_unlock_sock(sk_atm(vcc));
++		kfree_skb(skb);
++		return DROP_PACKET;
++	}
++
+ 	switch (pvcc->encaps) {		/* LLC encapsulation needed */
+ 	case e_llc:
+ 		if (skb_headroom(skb) < LLC_LEN) {
+@@ -285,8 +331,10 @@ static int pppoatm_send(struct ppp_chann
+ 			}
+ 			kfree_skb(skb);
+ 			skb = n;
+-			if (skb == NULL)
++			if (skb == NULL) {
++				bh_unlock_sock(sk_atm(vcc));
+ 				return DROP_PACKET;
++			}
+ 		} else if (!pppoatm_may_send(pvcc, skb->truesize))
+ 			goto nospace;
+ 		memcpy(skb_push(skb, LLC_LEN), pppllc, LLC_LEN);
+@@ -296,6 +344,7 @@ static int pppoatm_send(struct ppp_chann
+ 			goto nospace;
+ 		break;
+ 	case e_autodetect:
++		bh_unlock_sock(sk_atm(vcc));
+ 		pr_debug("Trying to send without setting encaps!\n");
+ 		kfree_skb(skb);
+ 		return 1;
+@@ -305,9 +354,12 @@ static int pppoatm_send(struct ppp_chann
+ 	ATM_SKB(skb)->atm_options = ATM_SKB(skb)->vcc->atm_options;
+ 	pr_debug("atm_skb(%p)->vcc(%p)->dev(%p)\n",
+ 		 skb, ATM_SKB(skb)->vcc, ATM_SKB(skb)->vcc->dev);
+-	return ATM_SKB(skb)->vcc->send(ATM_SKB(skb)->vcc, skb)
++	ret = ATM_SKB(skb)->vcc->send(ATM_SKB(skb)->vcc, skb)
+ 	    ? DROP_PACKET : 1;
++	bh_unlock_sock(sk_atm(vcc));
++	return ret;
+ nospace:
++	bh_unlock_sock(sk_atm(vcc));
+ 	/*
+ 	 * We don't have space to send this SKB now, but we might have
+ 	 * already applied SC_COMP_PROT compression, so may need to undo
+@@ -362,6 +414,8 @@ static int pppoatm_assign_vcc(struct atm
+ 	atomic_set(&pvcc->inflight, NONE_INFLIGHT);
+ 	pvcc->old_push = atmvcc->push;
+ 	pvcc->old_pop = atmvcc->pop;
++	pvcc->old_owner = atmvcc->owner;
++	pvcc->old_release_cb = atmvcc->release_cb;
+ 	pvcc->encaps = (enum pppoatm_encaps) be.encaps;
+ 	pvcc->chan.private = pvcc;
+ 	pvcc->chan.ops = &pppoatm_ops;
+@@ -377,7 +431,9 @@ static int pppoatm_assign_vcc(struct atm
+ 	atmvcc->user_back = pvcc;
+ 	atmvcc->push = pppoatm_push;
+ 	atmvcc->pop = pppoatm_pop;
++	atmvcc->release_cb = pppoatm_release_cb;
+ 	__module_get(THIS_MODULE);
++	atmvcc->owner = THIS_MODULE;
+ 
+ 	/* re-process everything received between connection setup and
+ 	   backend setup */
+@@ -406,6 +462,8 @@ static int pppoatm_ioctl(struct socket *
+ 			return -ENOIOCTLCMD;
+ 		if (!capable(CAP_NET_ADMIN))
+ 			return -EPERM;
++		if (sock->state != SS_CONNECTED)
++			return -EINVAL;
+ 		return pppoatm_assign_vcc(atmvcc, argp);
+ 		}
+ 	case PPPIOCGCHAN:
Index: target/linux/generic/patches-3.3/140-ixp4xx_hss_module_h_include.patch
===================================================================
--- target/linux/generic/patches-3.3/140-ixp4xx_hss_module_h_include.patch	(revision 0)
+++ target/linux/generic/patches-3.3/140-ixp4xx_hss_module_h_include.patch	(revision 0)
@@ -0,0 +1,39 @@
+From 32e857cd1fbb006f56a99a2eab998173b1576533 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <florian@openwrt.org>
+Date: Mon, 10 Sep 2012 10:18:57 +0200
+Subject: [PATCH net] ixp4xx_hss: fix build failure after logging conversion
+
+Commit c75bb2c6f0cf455c23e60f14d780e841dd47f801 (ixp4xx_hss: Update to
+current logging forms) converted the ixp4xx_hss module to use the current
+logging macros, but forgot to include linux/module.h, leading to the
+following build failures:
+
+  CC [M]  drivers/net/wan/ixp4xx_hss.o
+ drivers/net/wan/ixp4xx_hss.c:1412:20: error: expected ';', ',' or ')'
+ before string constant
+ drivers/net/wan/ixp4xx_hss.c:1413:25: error: expected ';', ',' or ')'
+ before string constant
+ drivers/net/wan/ixp4xx_hss.c:1414:21: error: expected ';', ',' or ')'
+ before string constant
+ drivers/net/wan/ixp4xx_hss.c:1415:19: error: expected ';', ',' or ')'
+ before string constant
+ make[8]: *** [drivers/net/wan/ixp4xx_hss.o] Error 1
+
+CC: stable@vger.kernel.org
+Signed-off-by: Florian Fainelli <florian@openwrt.org>
+---
+[stable: 3.1+]
+
+ drivers/net/wan/ixp4xx_hss.c |    1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/wan/ixp4xx_hss.c
++++ b/drivers/net/wan/ixp4xx_hss.c
+@@ -10,6 +10,7 @@
+ 
+ #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+ 
++#include <linux/module.h>
+ #include <linux/bitops.h>
+ #include <linux/cdev.h>
+ #include <linux/dma-mapping.h>
Index: target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch
===================================================================
--- target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch	(revision 0)
+++ target/linux/generic/patches-3.3/478-mtd-partial_eraseblock_unlock.patch	(revision 0)
@@ -0,0 +1,18 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -356,7 +356,14 @@ static int part_unlock(struct mtd_info *
+ 	struct mtd_part *part = PART(mtd);
+ 	if ((len + ofs) > mtd->size)
+ 		return -EINVAL;
+-	return mtd_unlock(part->master, ofs + part->offset, len);
++
++	ofs += part->offset;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		/* round up len to next erasesize and round down offset to prev block */
++		len = (mtd_div_by_eb(len, part->master) + 1) * part->master->erasesize;
++		ofs &= ~(part->master->erasesize - 1);
++	}
++	return mtd_unlock(part->master, ofs, len);
+ }
+ 
+ static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
Index: target/linux/generic/patches-3.3/729-phy-rtl8367b.patch
===================================================================
--- target/linux/generic/patches-3.3/729-phy-rtl8367b.patch	(revision 0)
+++ target/linux/generic/patches-3.3/729-phy-rtl8367b.patch	(revision 0)
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -199,6 +199,10 @@ config RTL8367_PHY
+ 	tristate "Driver for the Realtek RTL8367R/M switches"
+ 	select SWCONFIG
+ 
++config RTL8367B_PHY
++	tristate "Driver fot the Realtek RTL8367R-VB switch"
++	select SWCONFIG
++
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi
+ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
++obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
Index: target/linux/generic/patches-3.3/065-8139cp-fixes.patch
===================================================================
--- target/linux/generic/patches-3.3/065-8139cp-fixes.patch	(revision 0)
+++ target/linux/generic/patches-3.3/065-8139cp-fixes.patch	(revision 0)
@@ -0,0 +1,189 @@
+commit 01ffc0a7f1c1801a2354719dedbc32aff45b987d
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Sat Nov 24 12:11:21 2012 +0000
+
+    8139cp: re-enable interrupts after tx timeout
+    
+    Recovery doesn't work too well if we leave interrupts disabled...
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-by: Francois Romieu <romieu@fr.zoreil.com>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit 871f0d4c153e1258d4becf306eca6761bf38b629
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Thu Nov 22 03:16:58 2012 +0000
+
+    8139cp: enable bql
+    
+    This adds support for byte queue limits on RTL8139C+
+    
+    Tested on real hardware.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Acked-By: Dave Tht <dave.taht@bufferbloat.net>
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit a9dbe40fc10cea2efe6e1ff9e03c62dd7579c5ba
+Author: David Woodhouse <dwmw2@infradead.org>
+Date:   Wed Nov 21 10:27:19 2012 +0000
+
+    8139cp: set ring address after enabling C+ mode
+    
+    This fixes (for me) a regression introduced by commit b01af457 ("8139cp:
+    set ring address before enabling receiver"). That commit configured the
+    descriptor ring addresses earlier in the initialisation sequence, in
+    order to avoid the possibility of triggering stray DMA before the
+    correct address had been set up.
+    
+    Unfortunately, it seems that the hardware will scribble garbage into the
+    TxRingAddr registers when we enable "plus mode" Tx in the CpCmd
+    register. Observed on a Traverse Geos router board.
+    
+    To deal with this, while not reintroducing the problem which led to the
+    original commit, we augment cp_start_hw() to write to the CpCmd register
+    *first*, then set the descriptor ring addresses, and then finally to
+    enable Rx and Tx in the original 8139 Cmd register. The datasheet
+    actually indicates that we should enable Tx/Rx in the Cmd register
+    *before* configuring the descriptor addresses, but that would appear to
+    re-introduce the problem that the offending commit b01af457 was trying
+    to solve. And this variant appears to work fine on real hardware.
+    
+    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+    Cc: stable@kernel.org [3.5+]
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+commit 071e3ef4a94a021b16a2912f3885c86f4ff36b49
+Author: David S. Miller <davem@davemloft.net>
+Date:   Sun Nov 25 15:52:09 2012 -0500
+
+    Revert "8139cp: revert "set ring address before enabling receiver""
+    
+    This reverts commit b26623dab7eeb1e9f5898c7a49458789dd492f20.
+    
+    This reverts the revert, in net-next we'll try another scheme
+    to fix this bug using patches from David Woodhouse.
+    
+    Signed-off-by: David S. Miller <davem@davemloft.net>
+
+diff --git a/drivers/net/ethernet/realtek/8139cp.c b/drivers/net/ethernet/realtek/8139cp.c
+index b01f83a..6cb96b4 100644
+--- a/drivers/net/ethernet/realtek/8139cp.c
++++ b/drivers/net/ethernet/realtek/8139cp.c
+@@ -648,6 +648,7 @@ static void cp_tx (struct cp_private *cp)
+ {
+ 	unsigned tx_head = cp->tx_head;
+ 	unsigned tx_tail = cp->tx_tail;
++	unsigned bytes_compl = 0, pkts_compl = 0;
+ 
+ 	while (tx_tail != tx_head) {
+ 		struct cp_desc *txd = cp->tx_ring + tx_tail;
+@@ -666,6 +667,9 @@ static void cp_tx (struct cp_private *cp)
+ 				 le32_to_cpu(txd->opts1) & 0xffff,
+ 				 PCI_DMA_TODEVICE);
+ 
++		bytes_compl += skb->len;
++		pkts_compl++;
++
+ 		if (status & LastFrag) {
+ 			if (status & (TxError | TxFIFOUnder)) {
+ 				netif_dbg(cp, tx_err, cp->dev,
+@@ -697,6 +701,7 @@ static void cp_tx (struct cp_private *cp)
+ 
+ 	cp->tx_tail = tx_tail;
+ 
++	netdev_completed_queue(cp->dev, pkts_compl, bytes_compl);
+ 	if (TX_BUFFS_AVAIL(cp) > (MAX_SKB_FRAGS + 1))
+ 		netif_wake_queue(cp->dev);
+ }
+@@ -843,6 +848,8 @@ static netdev_tx_t cp_start_xmit (struct sk_buff *skb,
+ 		wmb();
+ 	}
+ 	cp->tx_head = entry;
++
++	netdev_sent_queue(dev, skb->len);
+ 	netif_dbg(cp, tx_queued, cp->dev, "tx queued, slot %d, skblen %d\n",
+ 		  entry, skb->len);
+ 	if (TX_BUFFS_AVAIL(cp) <= (MAX_SKB_FRAGS + 1))
+@@ -937,6 +944,8 @@ static void cp_stop_hw (struct cp_private *cp)
+ 
+ 	cp->rx_tail = 0;
+ 	cp->tx_head = cp->tx_tail = 0;
++
++	netdev_reset_queue(cp->dev);
+ }
+ 
+ static void cp_reset_hw (struct cp_private *cp)
+@@ -957,8 +966,38 @@ static void cp_reset_hw (struct cp_private *cp)
+ 
+ static inline void cp_start_hw (struct cp_private *cp)
+ {
++	dma_addr_t ring_dma;
++
+ 	cpw16(CpCmd, cp->cpcmd);
++
++	/*
++	 * These (at least TxRingAddr) need to be configured after the
++	 * corresponding bits in CpCmd are enabled. Datasheet v1.6 6.33
++	 * (C+ Command Register) recommends that these and more be configured
++	 * *after* the [RT]xEnable bits in CpCmd are set. And on some hardware
++	 * it's been observed that the TxRingAddr is actually reset to garbage
++	 * when C+ mode Tx is enabled in CpCmd.
++	 */
++	cpw32_f(HiTxRingAddr, 0);
++	cpw32_f(HiTxRingAddr + 4, 0);
++
++	ring_dma = cp->ring_dma;
++	cpw32_f(RxRingAddr, ring_dma & 0xffffffff);
++	cpw32_f(RxRingAddr + 4, (ring_dma >> 16) >> 16);
++
++	ring_dma += sizeof(struct cp_desc) * CP_RX_RING_SIZE;
++	cpw32_f(TxRingAddr, ring_dma & 0xffffffff);
++	cpw32_f(TxRingAddr + 4, (ring_dma >> 16) >> 16);
++
++	/*
++	 * Strictly speaking, the datasheet says this should be enabled
++	 * *before* setting the descriptor addresses. But what, then, would
++	 * prevent it from doing DMA to random unconfigured addresses?
++	 * This variant appears to work fine.
++	 */
+ 	cpw8(Cmd, RxOn | TxOn);
++
++	netdev_reset_queue(cp->dev);
+ }
+ 
+ static void cp_enable_irq(struct cp_private *cp)
+@@ -969,7 +1008,6 @@ static void cp_enable_irq(struct cp_private *cp)
+ static void cp_init_hw (struct cp_private *cp)
+ {
+ 	struct net_device *dev = cp->dev;
+-	dma_addr_t ring_dma;
+ 
+ 	cp_reset_hw(cp);
+ 
+@@ -992,17 +1030,6 @@ static void cp_init_hw (struct cp_private *cp)
+ 
+ 	cpw8(Config5, cpr8(Config5) & PMEStatus);
+ 
+-	cpw32_f(HiTxRingAddr, 0);
+-	cpw32_f(HiTxRingAddr + 4, 0);
+-
+-	ring_dma = cp->ring_dma;
+-	cpw32_f(RxRingAddr, ring_dma & 0xffffffff);
+-	cpw32_f(RxRingAddr + 4, (ring_dma >> 16) >> 16);
+-
+-	ring_dma += sizeof(struct cp_desc) * CP_RX_RING_SIZE;
+-	cpw32_f(TxRingAddr, ring_dma & 0xffffffff);
+-	cpw32_f(TxRingAddr + 4, (ring_dma >> 16) >> 16);
+-
+ 	cpw16(MultiIntr, 0);
+ 
+ 	cpw8_f(Cfg9346, Cfg9346_Lock);
+@@ -1192,6 +1219,7 @@ static void cp_tx_timeout(struct net_device *dev)
+ 	cp_clean_rings(cp);
+ 	rc = cp_init_rings(cp);
+ 	cp_start_hw(cp);
++	cp_enable_irq(cp);
+ 
+ 	netif_wake_queue(dev);
+ 
Index: target/linux/generic/patches-3.3/621-sched_act_connmark.patch
===================================================================
--- target/linux/generic/patches-3.3/621-sched_act_connmark.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/621-sched_act_connmark.patch	(working copy)
@@ -46,7 +46,7 @@
 +	.lock	=	&connmark_lock,
 +};
 +
-+static int tcf_connmark(struct sk_buff *skb, struct tc_action *a,
++static int tcf_connmark(struct sk_buff *skb, const struct tc_action *a,
 +		       struct tcf_result *res)
 +{
 +	struct nf_conn *c;
@@ -140,7 +140,7 @@
 +module_exit(connmark_cleanup_module);
 --- a/net/sched/Kconfig
 +++ b/net/sched/Kconfig
-@@ -602,6 +602,19 @@ config NET_ACT_CSUM
+@@ -624,6 +624,19 @@ config NET_ACT_CSUM
  	  To compile this code as a module, choose M here: the
  	  module will be called act_csum.
  
Index: target/linux/generic/patches-3.3/042-fq_codel-Fair-Queue-Codel-AQM.patch
===================================================================
--- target/linux/generic/patches-3.3/042-fq_codel-Fair-Queue-Codel-AQM.patch	(revision 0)
+++ target/linux/generic/patches-3.3/042-fq_codel-Fair-Queue-Codel-AQM.patch	(revision 0)
@@ -0,0 +1,839 @@
+From f8cf19c19528a468cc0b9846c0328a94cccdc605 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Fri, 11 May 2012 09:30:50 +0000
+Subject: [PATCH] fq_codel: Fair Queue Codel AQM
+
+commit 4b549a2ef4bef9965d97cbd992ba67930cd3e0fe upstream.
+
+Fair Queue Codel packet scheduler
+
+Principles :
+
+- Packets are classified (internal classifier or external) on flows.
+- This is a Stochastic model (as we use a hash, several flows might
+                              be hashed on same slot)
+- Each flow has a CoDel managed queue.
+- Flows are linked onto two (Round Robin) lists,
+  so that new flows have priority on old ones.
+
+- For a given flow, packets are not reordered (CoDel uses a FIFO)
+- head drops only.
+- ECN capability is on by default.
+- Very low memory footprint (64 bytes per flow)
+
+tc qdisc ... fq_codel [ limit PACKETS ] [ flows number ]
+                      [ target TIME ] [ interval TIME ] [ noecn ]
+                      [ quantum BYTES ]
+
+defaults : 1024 flows, 10240 packets limit, quantum : device MTU
+           target : 5ms (CoDel default)
+           interval : 100ms (CoDel default)
+
+Impressive results on load :
+
+class htb 1:1 root leaf 10: prio 0 quantum 1514 rate 200000Kbit ceil 200000Kbit burst 1475b/8 mpu 0b overhead 0b cburst 1475b/8 mpu 0b overhead 0b level 0
+ Sent 43304920109 bytes 33063109 pkt (dropped 0, overlimits 0 requeues 0)
+ rate 201691Kbit 28595pps backlog 0b 312p requeues 0
+ lended: 33063109 borrowed: 0 giants: 0
+ tokens: -912 ctokens: -912
+
+class fq_codel 10:1735 parent 10:
+ (dropped 1292, overlimits 0 requeues 0)
+ backlog 15140b 10p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.1ms
+class fq_codel 10:4524 parent 10:
+ (dropped 1291, overlimits 0 requeues 0)
+ backlog 16654b 11p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.1ms
+class fq_codel 10:4e74 parent 10:
+ (dropped 1290, overlimits 0 requeues 0)
+ backlog 6056b 4p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 6.4ms dropping drop_next 92.0ms
+class fq_codel 10:628a parent 10:
+ (dropped 1289, overlimits 0 requeues 0)
+ backlog 7570b 5p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 5.4ms dropping drop_next 90.9ms
+class fq_codel 10:a4b3 parent 10:
+ (dropped 302, overlimits 0 requeues 0)
+ backlog 16654b 11p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.1ms
+class fq_codel 10:c3c2 parent 10:
+ (dropped 1284, overlimits 0 requeues 0)
+ backlog 13626b 9p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 5.9ms
+class fq_codel 10:d331 parent 10:
+ (dropped 299, overlimits 0 requeues 0)
+ backlog 15140b 10p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.0ms
+class fq_codel 10:d526 parent 10:
+ (dropped 12160, overlimits 0 requeues 0)
+ backlog 35870b 211p requeues 0
+  deficit 1508 count 12160 lastcount 1 ldelay 15.3ms dropping drop_next 247us
+class fq_codel 10:e2c6 parent 10:
+ (dropped 1288, overlimits 0 requeues 0)
+ backlog 15140b 10p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.1ms
+class fq_codel 10:eab5 parent 10:
+ (dropped 1285, overlimits 0 requeues 0)
+ backlog 16654b 11p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 5.9ms
+class fq_codel 10:f220 parent 10:
+ (dropped 1289, overlimits 0 requeues 0)
+ backlog 15140b 10p requeues 0
+  deficit 1514 count 1 lastcount 1 ldelay 7.1ms
+
+qdisc htb 1: root refcnt 6 r2q 10 default 1 direct_packets_stat 0 ver 3.17
+ Sent 43331086547 bytes 33092812 pkt (dropped 0, overlimits 66063544 requeues 71)
+ rate 201697Kbit 28602pps backlog 0b 260p requeues 71
+qdisc fq_codel 10: parent 1:1 limit 10240p flows 65536 target 5.0ms interval 100.0ms ecn
+ Sent 43331086547 bytes 33092812 pkt (dropped 949359, overlimits 0 requeues 0)
+ rate 201697Kbit 28602pps backlog 189352b 260p requeues 0
+  maxpacket 1514 drop_overlimit 0 new_flow_count 5582 ecn_mark 125593
+  new_flows_len 0 old_flows_len 11
+
+PING 172.30.42.18 (172.30.42.18) 56(84) bytes of data.
+64 bytes from 172.30.42.18: icmp_req=1 ttl=64 time=0.227 ms
+64 bytes from 172.30.42.18: icmp_req=2 ttl=64 time=0.165 ms
+64 bytes from 172.30.42.18: icmp_req=3 ttl=64 time=0.166 ms
+64 bytes from 172.30.42.18: icmp_req=4 ttl=64 time=0.151 ms
+64 bytes from 172.30.42.18: icmp_req=5 ttl=64 time=0.164 ms
+64 bytes from 172.30.42.18: icmp_req=6 ttl=64 time=0.172 ms
+64 bytes from 172.30.42.18: icmp_req=7 ttl=64 time=0.175 ms
+64 bytes from 172.30.42.18: icmp_req=8 ttl=64 time=0.183 ms
+64 bytes from 172.30.42.18: icmp_req=9 ttl=64 time=0.158 ms
+64 bytes from 172.30.42.18: icmp_req=10 ttl=64 time=0.200 ms
+
+10 packets transmitted, 10 received, 0% packet loss, time 8999ms
+rtt min/avg/max/mdev = 0.151/0.176/0.227/0.022 ms
+
+Much better than SFQ because of priority given to new flows, and fast
+path dirtying less cache lines.
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/pkt_sched.h |   54 ++++
+ net/sched/Kconfig         |   11 +
+ net/sched/Makefile        |    1 +
+ net/sched/sch_fq_codel.c  |  624 +++++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 690 insertions(+)
+ create mode 100644 net/sched/sch_fq_codel.c
+
+--- a/include/linux/pkt_sched.h
++++ b/include/linux/pkt_sched.h
+@@ -659,4 +659,58 @@ struct tc_codel_xstats {
+ 	__u32	dropping;  /* are we in dropping state ? */
+ };
+ 
++/* FQ_CODEL */
++
++enum {
++	TCA_FQ_CODEL_UNSPEC,
++	TCA_FQ_CODEL_TARGET,
++	TCA_FQ_CODEL_LIMIT,
++	TCA_FQ_CODEL_INTERVAL,
++	TCA_FQ_CODEL_ECN,
++	TCA_FQ_CODEL_FLOWS,
++	TCA_FQ_CODEL_QUANTUM,
++	__TCA_FQ_CODEL_MAX
++};
++
++#define TCA_FQ_CODEL_MAX	(__TCA_FQ_CODEL_MAX - 1)
++
++enum {
++	TCA_FQ_CODEL_XSTATS_QDISC,
++	TCA_FQ_CODEL_XSTATS_CLASS,
++};
++
++struct tc_fq_codel_qd_stats {
++	__u32	maxpacket;	/* largest packet we've seen so far */
++	__u32	drop_overlimit; /* number of time max qdisc
++				 * packet limit was hit
++				 */
++	__u32	ecn_mark;	/* number of packets we ECN marked
++				 * instead of being dropped
++				 */
++	__u32	new_flow_count; /* number of time packets
++				 * created a 'new flow'
++				 */
++	__u32	new_flows_len;	/* count of flows in new list */
++	__u32	old_flows_len;	/* count of flows in old list */
++};
++
++struct tc_fq_codel_cl_stats {
++	__s32	deficit;
++	__u32	ldelay;		/* in-queue delay seen by most recently
++				 * dequeued packet
++				 */
++	__u32	count;
++	__u32	lastcount;
++	__u32	dropping;
++	__s32	drop_next;
++};
++
++struct tc_fq_codel_xstats {
++	__u32	type;
++	union {
++		struct tc_fq_codel_qd_stats qdisc_stats;
++		struct tc_fq_codel_cl_stats class_stats;
++	};
++};
++
+ #endif
+--- a/net/sched/Kconfig
++++ b/net/sched/Kconfig
+@@ -261,6 +261,17 @@ config NET_SCH_CODEL
+ 
+ 	  If unsure, say N.
+ 
++config NET_SCH_FQ_CODEL
++	tristate "Fair Queue Controlled Delay AQM (FQ_CODEL)"
++	help
++	  Say Y here if you want to use the FQ Controlled Delay (FQ_CODEL)
++	  packet scheduling algorithm.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called sch_fq_codel.
++
++	  If unsure, say N.
++
+ config NET_SCH_INGRESS
+ 	tristate "Ingress Qdisc"
+ 	depends on NET_CLS_ACT
+--- a/net/sched/Makefile
++++ b/net/sched/Makefile
+@@ -37,6 +37,7 @@ obj-$(CONFIG_NET_SCH_MQPRIO)	+= sch_mqpr
+ obj-$(CONFIG_NET_SCH_CHOKE)	+= sch_choke.o
+ obj-$(CONFIG_NET_SCH_QFQ)	+= sch_qfq.o
+ obj-$(CONFIG_NET_SCH_CODEL)	+= sch_codel.o
++obj-$(CONFIG_NET_SCH_FQ_CODEL)	+= sch_fq_codel.o
+ 
+ obj-$(CONFIG_NET_CLS_U32)	+= cls_u32.o
+ obj-$(CONFIG_NET_CLS_ROUTE4)	+= cls_route.o
+--- /dev/null
++++ b/net/sched/sch_fq_codel.c
+@@ -0,0 +1,624 @@
++/*
++ * Fair Queue CoDel discipline
++ *
++ *	This program is free software; you can redistribute it and/or
++ *	modify it under the terms of the GNU General Public License
++ *	as published by the Free Software Foundation; either version
++ *	2 of the License, or (at your option) any later version.
++ *
++ *  Copyright (C) 2012 Eric Dumazet <edumazet@google.com>
++ */
++
++#include <linux/module.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/jiffies.h>
++#include <linux/string.h>
++#include <linux/in.h>
++#include <linux/errno.h>
++#include <linux/init.h>
++#include <linux/skbuff.h>
++#include <linux/jhash.h>
++#include <linux/slab.h>
++#include <linux/vmalloc.h>
++#include <net/netlink.h>
++#include <net/pkt_sched.h>
++#include <net/flow_keys.h>
++#include <net/codel.h>
++
++/*	Fair Queue CoDel.
++ *
++ * Principles :
++ * Packets are classified (internal classifier or external) on flows.
++ * This is a Stochastic model (as we use a hash, several flows
++ *			       might be hashed on same slot)
++ * Each flow has a CoDel managed queue.
++ * Flows are linked onto two (Round Robin) lists,
++ * so that new flows have priority on old ones.
++ *
++ * For a given flow, packets are not reordered (CoDel uses a FIFO)
++ * head drops only.
++ * ECN capability is on by default.
++ * Low memory footprint (64 bytes per flow)
++ */
++
++struct fq_codel_flow {
++	struct sk_buff	  *head;
++	struct sk_buff	  *tail;
++	struct list_head  flowchain;
++	int		  deficit;
++	u32		  dropped; /* number of drops (or ECN marks) on this flow */
++	struct codel_vars cvars;
++}; /* please try to keep this structure <= 64 bytes */
++
++struct fq_codel_sched_data {
++	struct tcf_proto *filter_list;	/* optional external classifier */
++	struct fq_codel_flow *flows;	/* Flows table [flows_cnt] */
++	u32		*backlogs;	/* backlog table [flows_cnt] */
++	u32		flows_cnt;	/* number of flows */
++	u32		perturbation;	/* hash perturbation */
++	u32		quantum;	/* psched_mtu(qdisc_dev(sch)); */
++	struct codel_params cparams;
++	struct codel_stats cstats;
++	u32		drop_overlimit;
++	u32		new_flow_count;
++
++	struct list_head new_flows;	/* list of new flows */
++	struct list_head old_flows;	/* list of old flows */
++};
++
++static unsigned int fq_codel_hash(const struct fq_codel_sched_data *q,
++				  const struct sk_buff *skb)
++{
++	struct flow_keys keys;
++	unsigned int hash;
++
++	skb_flow_dissect(skb, &keys);
++	hash = jhash_3words((__force u32)keys.dst,
++			    (__force u32)keys.src ^ keys.ip_proto,
++			    (__force u32)keys.ports, q->perturbation);
++	return ((u64)hash * q->flows_cnt) >> 32;
++}
++
++static unsigned int fq_codel_classify(struct sk_buff *skb, struct Qdisc *sch,
++				      int *qerr)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct tcf_result res;
++	int result;
++
++	if (TC_H_MAJ(skb->priority) == sch->handle &&
++	    TC_H_MIN(skb->priority) > 0 &&
++	    TC_H_MIN(skb->priority) <= q->flows_cnt)
++		return TC_H_MIN(skb->priority);
++
++	if (!q->filter_list)
++		return fq_codel_hash(q, skb) + 1;
++
++	*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;
++	result = tc_classify(skb, q->filter_list, &res);
++	if (result >= 0) {
++#ifdef CONFIG_NET_CLS_ACT
++		switch (result) {
++		case TC_ACT_STOLEN:
++		case TC_ACT_QUEUED:
++			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
++		case TC_ACT_SHOT:
++			return 0;
++		}
++#endif
++		if (TC_H_MIN(res.classid) <= q->flows_cnt)
++			return TC_H_MIN(res.classid);
++	}
++	return 0;
++}
++
++/* helper functions : might be changed when/if skb use a standard list_head */
++
++/* remove one skb from head of slot queue */
++static inline struct sk_buff *dequeue_head(struct fq_codel_flow *flow)
++{
++	struct sk_buff *skb = flow->head;
++
++	flow->head = skb->next;
++	skb->next = NULL;
++	return skb;
++}
++
++/* add skb to flow queue (tail add) */
++static inline void flow_queue_add(struct fq_codel_flow *flow,
++				  struct sk_buff *skb)
++{
++	if (flow->head == NULL)
++		flow->head = skb;
++	else
++		flow->tail->next = skb;
++	flow->tail = skb;
++	skb->next = NULL;
++}
++
++static unsigned int fq_codel_drop(struct Qdisc *sch)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct sk_buff *skb;
++	unsigned int maxbacklog = 0, idx = 0, i, len;
++	struct fq_codel_flow *flow;
++
++	/* Queue is full! Find the fat flow and drop packet from it.
++	 * This might sound expensive, but with 1024 flows, we scan
++	 * 4KB of memory, and we dont need to handle a complex tree
++	 * in fast path (packet queue/enqueue) with many cache misses.
++	 */
++	for (i = 0; i < q->flows_cnt; i++) {
++		if (q->backlogs[i] > maxbacklog) {
++			maxbacklog = q->backlogs[i];
++			idx = i;
++		}
++	}
++	flow = &q->flows[idx];
++	skb = dequeue_head(flow);
++	len = qdisc_pkt_len(skb);
++	q->backlogs[idx] -= len;
++	kfree_skb(skb);
++	sch->q.qlen--;
++	sch->qstats.drops++;
++	sch->qstats.backlog -= len;
++	flow->dropped++;
++	return idx;
++}
++
++static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	unsigned int idx;
++	struct fq_codel_flow *flow;
++	int uninitialized_var(ret);
++
++	idx = fq_codel_classify(skb, sch, &ret);
++	if (idx == 0) {
++		if (ret & __NET_XMIT_BYPASS)
++			sch->qstats.drops++;
++		kfree_skb(skb);
++		return ret;
++	}
++	idx--;
++
++	codel_set_enqueue_time(skb);
++	flow = &q->flows[idx];
++	flow_queue_add(flow, skb);
++	q->backlogs[idx] += qdisc_pkt_len(skb);
++	sch->qstats.backlog += qdisc_pkt_len(skb);
++
++	if (list_empty(&flow->flowchain)) {
++		list_add_tail(&flow->flowchain, &q->new_flows);
++		codel_vars_init(&flow->cvars);
++		q->new_flow_count++;
++		flow->deficit = q->quantum;
++		flow->dropped = 0;
++	}
++	if (++sch->q.qlen < sch->limit)
++		return NET_XMIT_SUCCESS;
++
++	q->drop_overlimit++;
++	/* Return Congestion Notification only if we dropped a packet
++	 * from this flow.
++	 */
++	if (fq_codel_drop(sch) == idx)
++		return NET_XMIT_CN;
++
++	/* As we dropped a packet, better let upper stack know this */
++	qdisc_tree_decrease_qlen(sch, 1);
++	return NET_XMIT_SUCCESS;
++}
++
++/* This is the specific function called from codel_dequeue()
++ * to dequeue a packet from queue. Note: backlog is handled in
++ * codel, we dont need to reduce it here.
++ */
++static struct sk_buff *dequeue(struct codel_vars *vars, struct Qdisc *sch)
++{
++	struct fq_codel_flow *flow;
++	struct sk_buff *skb = NULL;
++
++	flow = container_of(vars, struct fq_codel_flow, cvars);
++	if (flow->head) {
++		skb = dequeue_head(flow);
++		sch->qstats.backlog -= qdisc_pkt_len(skb);
++		sch->q.qlen--;
++	}
++	return skb;
++}
++
++static struct sk_buff *fq_codel_dequeue(struct Qdisc *sch)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct sk_buff *skb;
++	struct fq_codel_flow *flow;
++	struct list_head *head;
++	u32 prev_drop_count, prev_ecn_mark;
++
++begin:
++	head = &q->new_flows;
++	if (list_empty(head)) {
++		head = &q->old_flows;
++		if (list_empty(head))
++			return NULL;
++	}
++	flow = list_first_entry(head, struct fq_codel_flow, flowchain);
++
++	if (flow->deficit <= 0) {
++		flow->deficit += q->quantum;
++		list_move_tail(&flow->flowchain, &q->old_flows);
++		goto begin;
++	}
++
++	prev_drop_count = q->cstats.drop_count;
++	prev_ecn_mark = q->cstats.ecn_mark;
++
++	skb = codel_dequeue(sch, &q->cparams, &flow->cvars, &q->cstats,
++			    dequeue, &q->backlogs[flow - q->flows]);
++
++	flow->dropped += q->cstats.drop_count - prev_drop_count;
++	flow->dropped += q->cstats.ecn_mark - prev_ecn_mark;
++
++	if (!skb) {
++		/* force a pass through old_flows to prevent starvation */
++		if ((head == &q->new_flows) && !list_empty(&q->old_flows))
++			list_move_tail(&flow->flowchain, &q->old_flows);
++		else
++			list_del_init(&flow->flowchain);
++		goto begin;
++	}
++	qdisc_bstats_update(sch, skb);
++	flow->deficit -= qdisc_pkt_len(skb);
++	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,
++	 * or HTB crashes. Defer it for next round.
++	 */
++	if (q->cstats.drop_count && sch->q.qlen) {
++		qdisc_tree_decrease_qlen(sch, q->cstats.drop_count);
++		q->cstats.drop_count = 0;
++	}
++	return skb;
++}
++
++static void fq_codel_reset(struct Qdisc *sch)
++{
++	struct sk_buff *skb;
++
++	while ((skb = fq_codel_dequeue(sch)) != NULL)
++		kfree_skb(skb);
++}
++
++static const struct nla_policy fq_codel_policy[TCA_FQ_CODEL_MAX + 1] = {
++	[TCA_FQ_CODEL_TARGET]	= { .type = NLA_U32 },
++	[TCA_FQ_CODEL_LIMIT]	= { .type = NLA_U32 },
++	[TCA_FQ_CODEL_INTERVAL]	= { .type = NLA_U32 },
++	[TCA_FQ_CODEL_ECN]	= { .type = NLA_U32 },
++	[TCA_FQ_CODEL_FLOWS]	= { .type = NLA_U32 },
++	[TCA_FQ_CODEL_QUANTUM]	= { .type = NLA_U32 },
++};
++
++static int fq_codel_change(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct nlattr *tb[TCA_FQ_CODEL_MAX + 1];
++	int err;
++
++	if (!opt)
++		return -EINVAL;
++
++	err = nla_parse_nested(tb, TCA_FQ_CODEL_MAX, opt, fq_codel_policy);
++	if (err < 0)
++		return err;
++	if (tb[TCA_FQ_CODEL_FLOWS]) {
++		if (q->flows)
++			return -EINVAL;
++		q->flows_cnt = nla_get_u32(tb[TCA_FQ_CODEL_FLOWS]);
++		if (!q->flows_cnt ||
++		    q->flows_cnt > 65536)
++			return -EINVAL;
++	}
++	sch_tree_lock(sch);
++
++	if (tb[TCA_FQ_CODEL_TARGET]) {
++		u64 target = nla_get_u32(tb[TCA_FQ_CODEL_TARGET]);
++
++		q->cparams.target = (target * NSEC_PER_USEC) >> CODEL_SHIFT;
++	}
++
++	if (tb[TCA_FQ_CODEL_INTERVAL]) {
++		u64 interval = nla_get_u32(tb[TCA_FQ_CODEL_INTERVAL]);
++
++		q->cparams.interval = (interval * NSEC_PER_USEC) >> CODEL_SHIFT;
++	}
++
++	if (tb[TCA_FQ_CODEL_LIMIT])
++		sch->limit = nla_get_u32(tb[TCA_FQ_CODEL_LIMIT]);
++
++	if (tb[TCA_FQ_CODEL_ECN])
++		q->cparams.ecn = !!nla_get_u32(tb[TCA_FQ_CODEL_ECN]);
++
++	if (tb[TCA_FQ_CODEL_QUANTUM])
++		q->quantum = max(256U, nla_get_u32(tb[TCA_FQ_CODEL_QUANTUM]));
++
++	while (sch->q.qlen > sch->limit) {
++		struct sk_buff *skb = fq_codel_dequeue(sch);
++
++		kfree_skb(skb);
++		q->cstats.drop_count++;
++	}
++	qdisc_tree_decrease_qlen(sch, q->cstats.drop_count);
++	q->cstats.drop_count = 0;
++
++	sch_tree_unlock(sch);
++	return 0;
++}
++
++static void *fq_codel_zalloc(size_t sz)
++{
++	void *ptr = kzalloc(sz, GFP_KERNEL | __GFP_NOWARN);
++
++	if (!ptr)
++		ptr = vzalloc(sz);
++	return ptr;
++}
++
++static void fq_codel_free(void *addr)
++{
++	if (addr) {
++		if (is_vmalloc_addr(addr))
++			vfree(addr);
++		else
++			kfree(addr);
++	}
++}
++
++static void fq_codel_destroy(struct Qdisc *sch)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++
++	tcf_destroy_chain(&q->filter_list);
++	fq_codel_free(q->backlogs);
++	fq_codel_free(q->flows);
++}
++
++static int fq_codel_init(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	int i;
++
++	sch->limit = 10*1024;
++	q->flows_cnt = 1024;
++	q->quantum = psched_mtu(qdisc_dev(sch));
++	q->perturbation = net_random();
++	INIT_LIST_HEAD(&q->new_flows);
++	INIT_LIST_HEAD(&q->old_flows);
++	codel_params_init(&q->cparams);
++	codel_stats_init(&q->cstats);
++	q->cparams.ecn = true;
++
++	if (opt) {
++		int err = fq_codel_change(sch, opt);
++		if (err)
++			return err;
++	}
++
++	if (!q->flows) {
++		q->flows = fq_codel_zalloc(q->flows_cnt *
++					   sizeof(struct fq_codel_flow));
++		if (!q->flows)
++			return -ENOMEM;
++		q->backlogs = fq_codel_zalloc(q->flows_cnt * sizeof(u32));
++		if (!q->backlogs) {
++			fq_codel_free(q->flows);
++			return -ENOMEM;
++		}
++		for (i = 0; i < q->flows_cnt; i++) {
++			struct fq_codel_flow *flow = q->flows + i;
++
++			INIT_LIST_HEAD(&flow->flowchain);
++		}
++	}
++	if (sch->limit >= 1)
++		sch->flags |= TCQ_F_CAN_BYPASS;
++	else
++		sch->flags &= ~TCQ_F_CAN_BYPASS;
++	return 0;
++}
++
++static int fq_codel_dump(struct Qdisc *sch, struct sk_buff *skb)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct nlattr *opts;
++
++	opts = nla_nest_start(skb, TCA_OPTIONS);
++	if (opts == NULL)
++		goto nla_put_failure;
++
++	if (nla_put_u32(skb, TCA_FQ_CODEL_TARGET,
++			codel_time_to_us(q->cparams.target)) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_LIMIT,
++			sch->limit) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_INTERVAL,
++			codel_time_to_us(q->cparams.interval)) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_ECN,
++			q->cparams.ecn) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_QUANTUM,
++			q->quantum) ||
++	    nla_put_u32(skb, TCA_FQ_CODEL_FLOWS,
++			q->flows_cnt))
++		goto nla_put_failure;
++
++	nla_nest_end(skb, opts);
++	return skb->len;
++
++nla_put_failure:
++	return -1;
++}
++
++static int fq_codel_dump_stats(struct Qdisc *sch, struct gnet_dump *d)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	struct tc_fq_codel_xstats st = {
++		.type				= TCA_FQ_CODEL_XSTATS_QDISC,
++		.qdisc_stats.maxpacket		= q->cstats.maxpacket,
++		.qdisc_stats.drop_overlimit	= q->drop_overlimit,
++		.qdisc_stats.ecn_mark		= q->cstats.ecn_mark,
++		.qdisc_stats.new_flow_count	= q->new_flow_count,
++	};
++	struct list_head *pos;
++
++	list_for_each(pos, &q->new_flows)
++		st.qdisc_stats.new_flows_len++;
++
++	list_for_each(pos, &q->old_flows)
++		st.qdisc_stats.old_flows_len++;
++
++	return gnet_stats_copy_app(d, &st, sizeof(st));
++}
++
++static struct Qdisc *fq_codel_leaf(struct Qdisc *sch, unsigned long arg)
++{
++	return NULL;
++}
++
++static unsigned long fq_codel_get(struct Qdisc *sch, u32 classid)
++{
++	return 0;
++}
++
++static unsigned long fq_codel_bind(struct Qdisc *sch, unsigned long parent,
++			      u32 classid)
++{
++	/* we cannot bypass queue discipline anymore */
++	sch->flags &= ~TCQ_F_CAN_BYPASS;
++	return 0;
++}
++
++static void fq_codel_put(struct Qdisc *q, unsigned long cl)
++{
++}
++
++static struct tcf_proto **fq_codel_find_tcf(struct Qdisc *sch, unsigned long cl)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++
++	if (cl)
++		return NULL;
++	return &q->filter_list;
++}
++
++static int fq_codel_dump_class(struct Qdisc *sch, unsigned long cl,
++			  struct sk_buff *skb, struct tcmsg *tcm)
++{
++	tcm->tcm_handle |= TC_H_MIN(cl);
++	return 0;
++}
++
++static int fq_codel_dump_class_stats(struct Qdisc *sch, unsigned long cl,
++				     struct gnet_dump *d)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	u32 idx = cl - 1;
++	struct gnet_stats_queue qs = { 0 };
++	struct tc_fq_codel_xstats xstats;
++
++	if (idx < q->flows_cnt) {
++		const struct fq_codel_flow *flow = &q->flows[idx];
++		const struct sk_buff *skb = flow->head;
++
++		memset(&xstats, 0, sizeof(xstats));
++		xstats.type = TCA_FQ_CODEL_XSTATS_CLASS;
++		xstats.class_stats.deficit = flow->deficit;
++		xstats.class_stats.ldelay =
++			codel_time_to_us(flow->cvars.ldelay);
++		xstats.class_stats.count = flow->cvars.count;
++		xstats.class_stats.lastcount = flow->cvars.lastcount;
++		xstats.class_stats.dropping = flow->cvars.dropping;
++		if (flow->cvars.dropping) {
++			codel_tdiff_t delta = flow->cvars.drop_next -
++					      codel_get_time();
++
++			xstats.class_stats.drop_next = (delta >= 0) ?
++				codel_time_to_us(delta) :
++				-codel_time_to_us(-delta);
++		}
++		while (skb) {
++			qs.qlen++;
++			skb = skb->next;
++		}
++		qs.backlog = q->backlogs[idx];
++		qs.drops = flow->dropped;
++	}
++	if (gnet_stats_copy_queue(d, &qs) < 0)
++		return -1;
++	if (idx < q->flows_cnt)
++		return gnet_stats_copy_app(d, &xstats, sizeof(xstats));
++	return 0;
++}
++
++static void fq_codel_walk(struct Qdisc *sch, struct qdisc_walker *arg)
++{
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
++	unsigned int i;
++
++	if (arg->stop)
++		return;
++
++	for (i = 0; i < q->flows_cnt; i++) {
++		if (list_empty(&q->flows[i].flowchain) ||
++		    arg->count < arg->skip) {
++			arg->count++;
++			continue;
++		}
++		if (arg->fn(sch, i + 1, arg) < 0) {
++			arg->stop = 1;
++			break;
++		}
++		arg->count++;
++	}
++}
++
++static const struct Qdisc_class_ops fq_codel_class_ops = {
++	.leaf		=	fq_codel_leaf,
++	.get		=	fq_codel_get,
++	.put		=	fq_codel_put,
++	.tcf_chain	=	fq_codel_find_tcf,
++	.bind_tcf	=	fq_codel_bind,
++	.unbind_tcf	=	fq_codel_put,
++	.dump		=	fq_codel_dump_class,
++	.dump_stats	=	fq_codel_dump_class_stats,
++	.walk		=	fq_codel_walk,
++};
++
++static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
++	.cl_ops		=	&fq_codel_class_ops,
++	.id		=	"fq_codel",
++	.priv_size	=	sizeof(struct fq_codel_sched_data),
++	.enqueue	=	fq_codel_enqueue,
++	.dequeue	=	fq_codel_dequeue,
++	.peek		=	qdisc_peek_dequeued,
++	.drop		=	fq_codel_drop,
++	.init		=	fq_codel_init,
++	.reset		=	fq_codel_reset,
++	.destroy	=	fq_codel_destroy,
++	.change		=	fq_codel_change,
++	.dump		=	fq_codel_dump,
++	.dump_stats =	fq_codel_dump_stats,
++	.owner		=	THIS_MODULE,
++};
++
++static int __init fq_codel_module_init(void)
++{
++	return register_qdisc(&fq_codel_qdisc_ops);
++}
++
++static void __exit fq_codel_module_exit(void)
++{
++	unregister_qdisc(&fq_codel_qdisc_ops);
++}
++
++module_init(fq_codel_module_init)
++module_exit(fq_codel_module_exit)
++MODULE_AUTHOR("Eric Dumazet");
++MODULE_LICENSE("GPL");
Index: target/linux/generic/patches-3.3/950-vm_exports.patch
===================================================================
--- target/linux/generic/patches-3.3/950-vm_exports.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/950-vm_exports.patch	(working copy)
@@ -61,7 +61,7 @@
  {
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -3855,6 +3855,7 @@ int can_nice(const struct task_struct *p
+@@ -3854,6 +3854,7 @@ int can_nice(const struct task_struct *p
  	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
  		capable(CAP_SYS_NICE));
  }
Index: target/linux/generic/patches-3.3/811-pci_disable_usb_common_quirks.patch
===================================================================
--- target/linux/generic/patches-3.3/811-pci_disable_usb_common_quirks.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/811-pci_disable_usb_common_quirks.patch	(working copy)
@@ -1,7 +1,7 @@
 
 --- a/drivers/usb/host/pci-quirks.c
 +++ b/drivers/usb/host/pci-quirks.c
-@@ -431,6 +431,8 @@ reset_needed:
+@@ -432,6 +432,8 @@ reset_needed:
  }
  EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
  
@@ -10,9 +10,29 @@
  static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
  {
  	u16 cmd;
-@@ -898,3 +900,5 @@ static void __devinit quirk_usb_early_ha
+@@ -928,3 +930,5 @@ static void __devinit quirk_usb_early_ha
  	pci_disable_device(pdev);
  }
  DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
 +
 +#endif
+--- a/drivers/usb/host/pci-quirks.h
++++ b/drivers/usb/host/pci-quirks.h
+@@ -8,9 +8,17 @@ int usb_amd_find_chipset_info(void);
+ void usb_amd_dev_put(void);
+ void usb_amd_quirk_pll_disable(void);
+ void usb_amd_quirk_pll_enable(void);
++#if !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
+ bool usb_is_intel_switchable_xhci(struct pci_dev *pdev);
+ void usb_enable_xhci_ports(struct pci_dev *xhci_pdev);
+ #else
++static inline bool usb_is_intel_switchable_xhci(struct pci_dev *pdev)
++{
++	return false;
++}
++static inline void usb_enable_xhci_ports(struct pci_dev *xhci_pdev) {}
++#endif
++#else
+ static inline void usb_amd_quirk_pll_disable(void) {}
+ static inline void usb_amd_quirk_pll_enable(void) {}
+ static inline void usb_amd_dev_put(void) {}
Index: target/linux/generic/patches-3.3/653-disable_netlink_trim.patch
===================================================================
--- target/linux/generic/patches-3.3/653-disable_netlink_trim.patch	(revision 0)
+++ target/linux/generic/patches-3.3/653-disable_netlink_trim.patch	(revision 0)
@@ -0,0 +1,28 @@
+--- a/net/netlink/af_netlink.c
++++ b/net/netlink/af_netlink.c
+@@ -854,25 +854,7 @@ void netlink_detachskb(struct sock *sk,
+ 
+ static struct sk_buff *netlink_trim(struct sk_buff *skb, gfp_t allocation)
+ {
+-	int delta;
+-
+ 	skb_orphan(skb);
+-
+-	delta = skb->end - skb->tail;
+-	if (delta * 2 < skb->truesize)
+-		return skb;
+-
+-	if (skb_shared(skb)) {
+-		struct sk_buff *nskb = skb_clone(skb, allocation);
+-		if (!nskb)
+-			return skb;
+-		kfree_skb(skb);
+-		skb = nskb;
+-	}
+-
+-	if (!pskb_expand_head(skb, 0, -delta, allocation))
+-		skb->truesize -= delta;
+-
+ 	return skb;
+ }
+ 
Index: target/linux/generic/patches-3.3/750-hostap_txpower.patch
===================================================================
--- target/linux/generic/patches-3.3/750-hostap_txpower.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/750-hostap_txpower.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/hostap/hostap_ap.c
 +++ b/drivers/net/wireless/hostap/hostap_ap.c
-@@ -2340,13 +2340,13 @@ int prism2_ap_get_sta_qual(local_info_t 
+@@ -2340,13 +2340,13 @@ int prism2_ap_get_sta_qual(local_info_t
  		addr[count].sa_family = ARPHRD_ETHER;
  		memcpy(addr[count].sa_data, sta->addr, ETH_ALEN);
  		if (sta->last_rx_silence == 0)
Index: target/linux/generic/patches-3.3/921-use_preinit_as_init.patch
===================================================================
--- target/linux/generic/patches-3.3/921-use_preinit_as_init.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/921-use_preinit_as_init.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/init/main.c
 +++ b/init/main.c
-@@ -777,10 +777,7 @@ static noinline int init_post(void)
+@@ -774,10 +774,7 @@ static noinline int init_post(void)
  		printk(KERN_WARNING "Failed to execute %s.  Attempting "
  					"defaults...\n", execute_command);
  	}
Index: target/linux/generic/patches-3.3/027-bcma-add-missing-iounmap-on-error-path.patch
===================================================================
--- target/linux/generic/patches-3.3/027-bcma-add-missing-iounmap-on-error-path.patch	(revision 0)
+++ target/linux/generic/patches-3.3/027-bcma-add-missing-iounmap-on-error-path.patch	(revision 0)
@@ -0,0 +1,55 @@
+--- a/drivers/bcma/scan.c
++++ b/drivers/bcma/scan.c
+@@ -462,8 +462,10 @@ int bcma_bus_scan(struct bcma_bus *bus)
+ 	while (eromptr < eromend) {
+ 		struct bcma_device *other_core;
+ 		struct bcma_device *core = kzalloc(sizeof(*core), GFP_KERNEL);
+-		if (!core)
+-			return -ENOMEM;
++		if (!core) {
++			err = -ENOMEM;
++			goto out;
++		}
+ 		INIT_LIST_HEAD(&core->list);
+ 		core->bus = bus;
+ 
+@@ -478,7 +480,7 @@ int bcma_bus_scan(struct bcma_bus *bus)
+ 			} else if (err == -ESPIPE) {
+ 				break;
+ 			}
+-			return err;
++			goto out;
+ 		}
+ 
+ 		core->core_index = core_num++;
+@@ -494,10 +496,12 @@ int bcma_bus_scan(struct bcma_bus *bus)
+ 		list_add_tail(&core->list, &bus->cores);
+ 	}
+ 
++	err = 0;
++out:
+ 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
+ 		iounmap(eromptr);
+ 
+-	return 0;
++	return err;
+ }
+ 
+ int __init bcma_bus_scan_early(struct bcma_bus *bus,
+@@ -537,7 +541,7 @@ int __init bcma_bus_scan_early(struct bc
+ 		else if (err == -ESPIPE)
+ 			break;
+ 		else if (err < 0)
+-			return err;
++			goto out;
+ 
+ 		core->core_index = core_num++;
+ 		bus->nr_cores++;
+@@ -551,6 +555,7 @@ int __init bcma_bus_scan_early(struct bc
+ 		break;
+ 	}
+ 
++out:
+ 	if (bus->hosttype == BCMA_HOSTTYPE_SOC)
+ 		iounmap(eromptr);
+ 
Index: target/linux/generic/patches-3.3/930-crashlog.patch
===================================================================
--- target/linux/generic/patches-3.3/930-crashlog.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/930-crashlog.patch	(working copy)
@@ -1,15 +1,20 @@
 --- /dev/null
 +++ b/include/linux/crashlog.h
-@@ -0,0 +1,12 @@
+@@ -0,0 +1,17 @@
 +#ifndef __CRASHLOG_H
 +#define __CRASHLOG_H
 +
 +#ifdef CONFIG_CRASHLOG
-+void __init crashlog_init_mem(struct bootmem_data *bdata);
++void crashlog_init_bootmem(struct bootmem_data *bdata);
++void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
 +#else
-+static inline void crashlog_init_mem(struct bootmem_data *bdata)
++static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
 +{
 +}
++
++static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++}
 +#endif
 +
 +#endif
@@ -21,7 +26,7 @@
  
 +config CRASHLOG
 +	bool "Crash logging"
-+	depends on !NO_BOOTMEM && !HAVE_MEMBLOCK
++	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK) && !ARM
 +
  config BLK_DEV_INITRD
  	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
@@ -38,7 +43,7 @@
  
 --- /dev/null
 +++ b/kernel/crashlog.c
-@@ -0,0 +1,171 @@
+@@ -0,0 +1,190 @@
 +/*
 + * Crash information logger
 + * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
@@ -64,6 +69,7 @@
 +
 +#include <linux/module.h>
 +#include <linux/bootmem.h>
++#include <linux/memblock.h>
 +#include <linux/debugfs.h>
 +#include <linux/crashlog.h>
 +#include <linux/kmsg_dump.h>
@@ -96,7 +102,8 @@
 +
 +extern struct list_head *crashlog_modules;
 +
-+void __init crashlog_init_mem(bootmem_data_t *bdata)
++#ifndef CONFIG_NO_BOOTMEM
++void __init crashlog_init_bootmem(bootmem_data_t *bdata)
 +{
 +	unsigned long addr;
 +
@@ -111,7 +118,24 @@
 +	}
 +	crashlog_addr = addr;
 +}
++#endif
 +
++#ifdef CONFIG_HAVE_MEMBLOCK
++void __meminit crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++	if (crashlog_addr)
++		return;
++
++	addr += size - CRASHLOG_OFFSET;
++	if (memblock_reserve(addr, CRASHLOG_SIZE)) {
++		printk("Crashlog failed to allocate RAM at address 0x%lx\n", (unsigned long) addr);
++		return;
++	}
++
++	crashlog_addr = addr;
++}
++#endif
++
 +static void __init crashlog_copy(void)
 +{
 +	if (crashlog_buf->magic != CRASHLOG_MAGIC)
@@ -224,7 +248,7 @@
  	if (!bdata->node_bootmem_map)
  		return 0;
  
-+	crashlog_init_mem(bdata);
++	crashlog_init_bootmem(bdata);
  	start = bdata->node_min_pfn;
  	end = bdata->node_low_pfn;
  
@@ -240,3 +264,22 @@
  
  
  /* Block module loading/unloading? */
+--- a/mm/memblock.c
++++ b/mm/memblock.c
+@@ -19,6 +19,7 @@
+ #include <linux/debugfs.h>
+ #include <linux/seq_file.h>
+ #include <linux/memblock.h>
++#include <linux/crashlog.h>
+ 
+ static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
+ static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
+@@ -305,6 +306,8 @@ static void __init_memblock memblock_ins
+ 	memblock_set_region_node(rgn, nid);
+ 	type->cnt++;
+ 	type->total_size += size;
++	if (type == &memblock.memory && idx == 0)
++		crashlog_init_memblock(base, size);
+ }
+ 
+ /**
Index: target/linux/generic/patches-3.3/309-mips_fuse_workaround.patch
===================================================================
--- target/linux/generic/patches-3.3/309-mips_fuse_workaround.patch	(revision 0)
+++ target/linux/generic/patches-3.3/309-mips_fuse_workaround.patch	(revision 0)
@@ -0,0 +1,32 @@
+--- a/arch/mips/mm/cache.c
++++ b/arch/mips/mm/cache.c
+@@ -39,6 +39,7 @@ void (*__flush_kernel_vmap_range)(unsign
+ void (*__invalidate_kernel_vmap_range)(unsigned long vaddr, int size);
+ 
+ EXPORT_SYMBOL_GPL(__flush_kernel_vmap_range);
++EXPORT_SYMBOL(__flush_cache_all);
+ 
+ /* MIPS specific cache operations */
+ void (*flush_cache_sigtramp)(unsigned long addr);
+--- a/fs/fuse/dev.c
++++ b/fs/fuse/dev.c
+@@ -19,6 +19,9 @@
+ #include <linux/pipe_fs_i.h>
+ #include <linux/swap.h>
+ #include <linux/splice.h>
++#ifdef CONFIG_MIPS
++#include <asm/cacheflush.h>
++#endif
+ 
+ MODULE_ALIAS_MISCDEV(FUSE_MINOR);
+ MODULE_ALIAS("devname:fuse");
+@@ -655,6 +658,9 @@ static int fuse_copy_fill(struct fuse_co
+ static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)
+ {
+ 	unsigned ncpy = min(*size, cs->len);
++#ifdef CONFIG_MIPS
++	__flush_cache_all();
++#endif
+ 	if (val) {
+ 		if (cs->write)
+ 			memcpy(cs->buf, *val, ncpy);
Index: target/linux/generic/patches-3.3/070-gpio-add-flags-to-export-GPIOs-when-requesting.patch
===================================================================
--- target/linux/generic/patches-3.3/070-gpio-add-flags-to-export-GPIOs-when-requesting.patch	(revision 0)
+++ target/linux/generic/patches-3.3/070-gpio-add-flags-to-export-GPIOs-when-requesting.patch	(revision 0)
@@ -0,0 +1,68 @@
+From fc3a1f04f5040255cbc086c419e4237f29f89f88 Mon Sep 17 00:00:00 2001
+From: Wolfram Sang <w.sang@pengutronix.de>
+Date: Tue, 13 Dec 2011 18:34:01 +0100
+Subject: [PATCH] gpio: add flags to export GPIOs when requesting
+
+commit fc3a1f04f5040255cbc086c419e4237f29f89f88 upstream.
+
+Introduce new flags to automatically export GPIOs when using the convenience
+functions gpio_request_one() or gpio_request_array(). This eases support for
+custom boards where lots of GPIOs need to be exported for customer
+applications.
+
+Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
+Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
+---
+ Documentation/gpio.txt |    3 +++
+ drivers/gpio/gpiolib.c |   12 +++++++++++-
+ include/linux/gpio.h   |    5 +++++
+ 3 files changed, 19 insertions(+), 1 deletion(-)
+
+--- a/Documentation/gpio.txt
++++ b/Documentation/gpio.txt
+@@ -303,6 +303,9 @@ where 'flags' is currently defined to sp
+ 	* GPIOF_INIT_LOW	- as output, set initial level to LOW
+ 	* GPIOF_INIT_HIGH	- as output, set initial level to HIGH
+ 
++	* GPIOF_EXPORT_DIR_FIXED	- export gpio to sysfs, keep direction
++	* GPIOF_EXPORT_DIR_CHANGEABLE	- also export, allow changing direction
++
+ since GPIOF_INIT_* are only valid when configured as output, so group valid
+ combinations as:
+ 
+--- a/drivers/gpio/gpiolib.c
++++ b/drivers/gpio/gpiolib.c
+@@ -1289,8 +1289,18 @@ int gpio_request_one(unsigned gpio, unsi
+ 				(flags & GPIOF_INIT_HIGH) ? 1 : 0);
+ 
+ 	if (err)
+-		gpio_free(gpio);
++		goto free_gpio;
+ 
++	if (flags & GPIOF_EXPORT) {
++		err = gpio_export(gpio, flags & GPIOF_EXPORT_CHANGEABLE);
++		if (err)
++			goto free_gpio;
++	}
++
++	return 0;
++
++ free_gpio:
++	gpio_free(gpio);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(gpio_request_one);
+--- a/include/linux/gpio.h
++++ b/include/linux/gpio.h
+@@ -14,6 +14,11 @@
+ #define GPIOF_OUT_INIT_LOW	(GPIOF_DIR_OUT | GPIOF_INIT_LOW)
+ #define GPIOF_OUT_INIT_HIGH	(GPIOF_DIR_OUT | GPIOF_INIT_HIGH)
+ 
++#define GPIOF_EXPORT		(1 << 2)
++#define GPIOF_EXPORT_CHANGEABLE	(1 << 3)
++#define GPIOF_EXPORT_DIR_FIXED	(GPIOF_EXPORT)
++#define GPIOF_EXPORT_DIR_CHANGEABLE (GPIOF_EXPORT | GPIOF_EXPORT_CHANGEABLE)
++
+ /**
+  * struct gpio - a structure describing a GPIO with configuration
+  * @gpio:	the GPIO number
Index: target/linux/generic/patches-3.3/726-phy_rtl8366.patch
===================================================================
--- target/linux/generic/patches-3.3/726-phy_rtl8366.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/726-phy_rtl8366.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/phy/Kconfig
 +++ b/drivers/net/phy/Kconfig
-@@ -168,6 +168,31 @@ config MDIO_OCTEON
+@@ -168,6 +168,30 @@ config MDIO_OCTEON
  
  	  If in doubt, say Y.
  
@@ -13,6 +13,11 @@
 +
 +if RTL8366_SMI
 +
++config RTL8366_SMI_DEBUG_FS
++	bool "RTL8366 SMI interface debugfs support"
++        depends on DEBUG_FS
++        default n
++
 +config RTL8366S_PHY
 +	tristate "Driver for the Realtek RTL8366S switch"
 +	select SWCONFIG
@@ -21,12 +26,6 @@
 +	tristate "Driver for the Realtek RTL8366RB switch"
 +	select SWCONFIG
 +
-+config RTL8366S_PHY_DEBUG_FS
-+	bool "RTL8366 switch driver DEBUG_FS support"
-+	depends on RTL8366S_PHY || RTL8366RB_PHY
-+	depends on DEBUG_FS
-+	default n
-+
 +endif # RTL8366_SMI
 +
  endif # PHYLIB
Index: target/linux/generic/patches-3.3/026-bcma_pmu_regression.patch
===================================================================
--- target/linux/generic/patches-3.3/026-bcma_pmu_regression.patch	(revision 0)
+++ target/linux/generic/patches-3.3/026-bcma_pmu_regression.patch	(revision 0)
@@ -0,0 +1,29 @@
+--- a/drivers/bcma/driver_chipcommon_pmu.c
++++ b/drivers/bcma/driver_chipcommon_pmu.c
+@@ -110,7 +110,7 @@ void bcma_pmu_workarounds(struct bcma_dr
+ 		/* enable 12 mA drive strenth for 4313 and set chipControl
+ 		   register bit 1 */
+ 		bcma_chipco_chipctl_maskset(cc, 0,
+-					    BCMA_CCTRL_4313_12MA_LED_DRIVE,
++					    ~BCMA_CCTRL_4313_12MA_LED_DRIVE,
+ 					    BCMA_CCTRL_4313_12MA_LED_DRIVE);
+ 		break;
+ 	case BCMA_CHIP_ID_BCM4331:
+@@ -124,14 +124,14 @@ void bcma_pmu_workarounds(struct bcma_dr
+ 		   register bit 15 */
+ 		if (bus->chipinfo.rev == 0) {
+ 			bcma_cc_maskset32(cc, BCMA_CC_CHIPCTL,
+-					  BCMA_CCTRL_43224_GPIO_TOGGLE,
++					  ~BCMA_CCTRL_43224_GPIO_TOGGLE,
+ 					  BCMA_CCTRL_43224_GPIO_TOGGLE);
+ 			bcma_chipco_chipctl_maskset(cc, 0,
+-						    BCMA_CCTRL_43224A0_12MA_LED_DRIVE,
++						    ~BCMA_CCTRL_43224A0_12MA_LED_DRIVE,
+ 						    BCMA_CCTRL_43224A0_12MA_LED_DRIVE);
+ 		} else {
+ 			bcma_chipco_chipctl_maskset(cc, 0,
+-						    BCMA_CCTRL_43224B0_12MA_LED_DRIVE,
++						    ~BCMA_CCTRL_43224B0_12MA_LED_DRIVE,
+ 						    BCMA_CCTRL_43224B0_12MA_LED_DRIVE);
+ 		}
+ 		break;
Index: target/linux/generic/patches-3.3/865-gpiopwm.patch
===================================================================
--- target/linux/generic/patches-3.3/865-gpiopwm.patch	(revision 0)
+++ target/linux/generic/patches-3.3/865-gpiopwm.patch	(revision 0)
@@ -0,0 +1,21 @@
+--- a/drivers/Kconfig
++++ b/drivers/Kconfig
+@@ -60,6 +60,8 @@ source "drivers/pinctrl/Kconfig"
+ 
+ source "drivers/gpio/Kconfig"
+ 
++source "drivers/pwm/Kconfig"
++
+ source "drivers/w1/Kconfig"
+ 
+ source "drivers/power/Kconfig"
+--- a/drivers/Makefile
++++ b/drivers/Makefile
+@@ -8,6 +8,7 @@
+ # GPIO must come after pinctrl as gpios may need to mux pins etc
+ obj-y				+= pinctrl/
+ obj-y				+= gpio/
++obj-$(CONFIG_GENERIC_PWM)	+= pwm/
+ obj-$(CONFIG_PCI)		+= pci/
+ obj-$(CONFIG_PARISC)		+= parisc/
+ obj-$(CONFIG_RAPIDIO)		+= rapidio/
Index: target/linux/generic/patches-3.3/831-ledtrig_netdev.patch
===================================================================
--- target/linux/generic/patches-3.3/831-ledtrig_netdev.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/831-ledtrig_netdev.patch	(working copy)
@@ -14,7 +14,7 @@
  endif # NEW_LEDS
 --- a/drivers/leds/Makefile
 +++ b/drivers/leds/Makefile
-@@ -58,3 +58,4 @@ obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= 
+@@ -58,3 +58,4 @@ obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+=
  obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
  obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
  obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
Index: target/linux/generic/patches-3.3/045-codel-use-u16-field-instead-of-31bits-for-rec_inv_sq.patch
===================================================================
--- target/linux/generic/patches-3.3/045-codel-use-u16-field-instead-of-31bits-for-rec_inv_sq.patch	(revision 0)
+++ target/linux/generic/patches-3.3/045-codel-use-u16-field-instead-of-31bits-for-rec_inv_sq.patch	(revision 0)
@@ -0,0 +1,86 @@
+From 03333931c17d9c62ba4063d4e4fec1578c0729a7 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <eric.dumazet@gmail.com>
+Date: Sat, 12 May 2012 21:23:23 +0000
+Subject: [PATCH] codel: use u16 field instead of 31bits for rec_inv_sqrt
+
+commit 6ff272c9ad65eda219cd975b9da2dbc31cc812ee upstream.
+
+David pointed out gcc might generate poor code with 31bit fields.
+
+Using u16 is more than enough and permits a better code output.
+
+Also make the code intent more readable using constants, fixed point arithmetic
+not being trivial for everybody.
+
+Suggested-by: David Miller <davem@davemloft.net>
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/codel.h |   25 +++++++++++++++----------
+ 1 file changed, 15 insertions(+), 10 deletions(-)
+
+--- a/include/net/codel.h
++++ b/include/net/codel.h
+@@ -133,13 +133,17 @@ struct codel_params {
+ struct codel_vars {
+ 	u32		count;
+ 	u32		lastcount;
+-	bool		dropping:1;
+-	u32		rec_inv_sqrt:31;
++	bool		dropping;
++	u16		rec_inv_sqrt;
+ 	codel_time_t	first_above_time;
+ 	codel_time_t	drop_next;
+ 	codel_time_t	ldelay;
+ };
+ 
++#define REC_INV_SQRT_BITS (8 * sizeof(u16)) /* or sizeof_in_bits(rec_inv_sqrt) */
++/* needed shift to get a Q0.32 number from rec_inv_sqrt */
++#define REC_INV_SQRT_SHIFT (32 - REC_INV_SQRT_BITS)
++
+ /**
+  * struct codel_stats - contains codel shared variables and stats
+  * @maxpacket:	largest packet we've seen so far
+@@ -173,17 +177,18 @@ static void codel_stats_init(struct code
+  * http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Iterative_methods_for_reciprocal_square_roots
+  * new_invsqrt = (invsqrt / 2) * (3 - count * invsqrt^2)
+  *
+- * Here, invsqrt is a fixed point number (< 1.0), 31bit mantissa)
++ * Here, invsqrt is a fixed point number (< 1.0), 32bit mantissa, aka Q0.32
+  */
+ static void codel_Newton_step(struct codel_vars *vars)
+ {
+-	u32 invsqrt = vars->rec_inv_sqrt;
+-	u32 invsqrt2 = ((u64)invsqrt * invsqrt) >> 31;
+-	u64 val = (3LL << 31) - ((u64)vars->count * invsqrt2);
++	u32 invsqrt = ((u32)vars->rec_inv_sqrt) << REC_INV_SQRT_SHIFT;
++	u32 invsqrt2 = ((u64)invsqrt * invsqrt) >> 32;
++	u64 val = (3LL << 32) - ((u64)vars->count * invsqrt2);
+ 
+-	val = (val * invsqrt) >> 32;
++	val >>= 2; /* avoid overflow in following multiply */
++	val = (val * invsqrt) >> (32 - 2 + 1);
+ 
+-	vars->rec_inv_sqrt = val;
++	vars->rec_inv_sqrt = val >> REC_INV_SQRT_SHIFT;
+ }
+ 
+ /*
+@@ -195,7 +200,7 @@ static codel_time_t codel_control_law(co
+ 				      codel_time_t interval,
+ 				      u32 rec_inv_sqrt)
+ {
+-	return t + reciprocal_divide(interval, rec_inv_sqrt << 1);
++	return t + reciprocal_divide(interval, rec_inv_sqrt << REC_INV_SQRT_SHIFT);
+ }
+ 
+ 
+@@ -326,7 +331,7 @@ static struct sk_buff *codel_dequeue(str
+ 			codel_Newton_step(vars);
+ 		} else {
+ 			vars->count = 1;
+-			vars->rec_inv_sqrt = 0x7fffffff;
++			vars->rec_inv_sqrt = ~0U >> REC_INV_SQRT_SHIFT;
+ 		}
+ 		vars->lastcount = vars->count;
+ 		vars->drop_next = codel_control_law(now, params->interval,
Index: target/linux/generic/patches-3.3/212-x86_reloc_portability.patch
===================================================================
--- target/linux/generic/patches-3.3/212-x86_reloc_portability.patch	(revision 0)
+++ target/linux/generic/patches-3.3/212-x86_reloc_portability.patch	(revision 0)
@@ -0,0 +1,22 @@
+--- a/arch/x86/tools/relocs.c
++++ b/arch/x86/tools/relocs.c
+@@ -10,7 +10,18 @@
+ #define USE_BSD
+ #include <endian.h>
+ #include <regex.h>
+-#include <tools/le_byteshift.h>
++
++static inline void __put_unaligned_le16(uint16_t val, uint8_t *p)
++{
++	*p++ = val;
++	*p++ = val >> 8;
++}
++
++static inline void put_unaligned_le32(uint32_t val, uint8_t *p)
++{
++	__put_unaligned_le16(val >> 16, p + 2);
++	__put_unaligned_le16(val, p);
++}
+ 
+ static void die(char *fmt, ...);
+ 
Index: target/linux/generic/patches-3.3/541-ubifs-xz-decompression-support.patch
===================================================================
--- target/linux/generic/patches-3.3/541-ubifs-xz-decompression-support.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/541-ubifs-xz-decompression-support.patch	(working copy)
@@ -44,7 +44,7 @@
 +	.capi_name = "xz",
 +};
 +#else
-+static struct ubifs_compressor zlib_compr = {
++static struct ubifs_compressor xz_compr = {
 +	.compr_type = UBIFS_COMPR_XZ,
 +	.name = "xz",
 +};
Index: target/linux/generic/patches-3.3/920-unable_to_open_console.patch
===================================================================
--- target/linux/generic/patches-3.3/920-unable_to_open_console.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/920-unable_to_open_console.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/init/main.c
 +++ b/init/main.c
-@@ -815,7 +815,7 @@ static int __init kernel_init(void * unu
+@@ -816,7 +816,7 @@ static int __init kernel_init(void * unu
  
  	/* Open the /dev/console on the rootfs, this should never fail */
  	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
Index: target/linux/generic/patches-3.3/046-fq_codel-qdisc-backlog.patch
===================================================================
--- target/linux/generic/patches-3.3/046-fq_codel-qdisc-backlog.patch	(revision 0)
+++ target/linux/generic/patches-3.3/046-fq_codel-qdisc-backlog.patch	(revision 0)
@@ -0,0 +1,132 @@
+From 7bd90773f89001ea4960ed47676b550137f3facb Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Wed, 16 May 2012 04:39:09 +0000
+Subject: [PATCH] fq_codel: should use qdisc backlog as threshold
+
+commit 865ec5523dadbedefbc5710a68969f686a28d928 upstream.
+
+codel_should_drop() logic allows a packet being not dropped if queue
+size is under max packet size.
+
+In fq_codel, we have two possible backlogs : The qdisc global one, and
+the flow local one.
+
+The meaningful one for codel_should_drop() should be the global backlog,
+not the per flow one, so that thin flows can have a non zero drop/mark
+probability.
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: Dave Taht <dave.taht@bufferbloat.net>
+Cc: Kathleen Nichols <nichols@pollere.com>
+Cc: Van Jacobson <van@pollere.net>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/codel.h      |   15 +++++++--------
+ net/sched/sch_codel.c    |    4 ++--
+ net/sched/sch_fq_codel.c |    5 +++--
+ 3 files changed, 12 insertions(+), 12 deletions(-)
+
+--- a/include/net/codel.h
++++ b/include/net/codel.h
+@@ -205,7 +205,7 @@ static codel_time_t codel_control_law(co
+ 
+ 
+ static bool codel_should_drop(const struct sk_buff *skb,
+-			      unsigned int *backlog,
++			      struct Qdisc *sch,
+ 			      struct codel_vars *vars,
+ 			      struct codel_params *params,
+ 			      struct codel_stats *stats,
+@@ -219,13 +219,13 @@ static bool codel_should_drop(const stru
+ 	}
+ 
+ 	vars->ldelay = now - codel_get_enqueue_time(skb);
+-	*backlog -= qdisc_pkt_len(skb);
++	sch->qstats.backlog -= qdisc_pkt_len(skb);
+ 
+ 	if (unlikely(qdisc_pkt_len(skb) > stats->maxpacket))
+ 		stats->maxpacket = qdisc_pkt_len(skb);
+ 
+ 	if (codel_time_before(vars->ldelay, params->target) ||
+-	    *backlog <= stats->maxpacket) {
++	    sch->qstats.backlog <= stats->maxpacket) {
+ 		/* went below - stay below for at least interval */
+ 		vars->first_above_time = 0;
+ 		return false;
+@@ -249,8 +249,7 @@ static struct sk_buff *codel_dequeue(str
+ 				     struct codel_params *params,
+ 				     struct codel_vars *vars,
+ 				     struct codel_stats *stats,
+-				     codel_skb_dequeue_t dequeue_func,
+-				     u32 *backlog)
++				     codel_skb_dequeue_t dequeue_func)
+ {
+ 	struct sk_buff *skb = dequeue_func(vars, sch);
+ 	codel_time_t now;
+@@ -261,7 +260,7 @@ static struct sk_buff *codel_dequeue(str
+ 		return skb;
+ 	}
+ 	now = codel_get_time();
+-	drop = codel_should_drop(skb, backlog, vars, params, stats, now);
++	drop = codel_should_drop(skb, sch, vars, params, stats, now);
+ 	if (vars->dropping) {
+ 		if (!drop) {
+ 			/* sojourn time below target - leave dropping state */
+@@ -292,7 +291,7 @@ static struct sk_buff *codel_dequeue(str
+ 				qdisc_drop(skb, sch);
+ 				stats->drop_count++;
+ 				skb = dequeue_func(vars, sch);
+-				if (!codel_should_drop(skb, backlog,
++				if (!codel_should_drop(skb, sch,
+ 						       vars, params, stats, now)) {
+ 					/* leave dropping state */
+ 					vars->dropping = false;
+@@ -313,7 +312,7 @@ static struct sk_buff *codel_dequeue(str
+ 			stats->drop_count++;
+ 
+ 			skb = dequeue_func(vars, sch);
+-			drop = codel_should_drop(skb, backlog, vars, params,
++			drop = codel_should_drop(skb, sch, vars, params,
+ 						 stats, now);
+ 		}
+ 		vars->dropping = true;
+--- a/net/sched/sch_codel.c
++++ b/net/sched/sch_codel.c
+@@ -77,8 +77,8 @@ static struct sk_buff *codel_qdisc_deque
+ 	struct codel_sched_data *q = qdisc_priv(sch);
+ 	struct sk_buff *skb;
+ 
+-	skb = codel_dequeue(sch, &q->params, &q->vars, &q->stats,
+-			    dequeue, &sch->qstats.backlog);
++	skb = codel_dequeue(sch, &q->params, &q->vars, &q->stats, dequeue);
++
+ 	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,
+ 	 * or HTB crashes. Defer it for next round.
+ 	 */
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -217,13 +217,14 @@ static int fq_codel_enqueue(struct sk_bu
+  */
+ static struct sk_buff *dequeue(struct codel_vars *vars, struct Qdisc *sch)
+ {
++	struct fq_codel_sched_data *q = qdisc_priv(sch);
+ 	struct fq_codel_flow *flow;
+ 	struct sk_buff *skb = NULL;
+ 
+ 	flow = container_of(vars, struct fq_codel_flow, cvars);
+ 	if (flow->head) {
+ 		skb = dequeue_head(flow);
+-		sch->qstats.backlog -= qdisc_pkt_len(skb);
++		q->backlogs[flow - q->flows] -= qdisc_pkt_len(skb);
+ 		sch->q.qlen--;
+ 	}
+ 	return skb;
+@@ -256,7 +257,7 @@ begin:
+ 	prev_ecn_mark = q->cstats.ecn_mark;
+ 
+ 	skb = codel_dequeue(sch, &q->cparams, &flow->cvars, &q->cstats,
+-			    dequeue, &q->backlogs[flow - q->flows]);
++			    dequeue);
+ 
+ 	flow->dropped += q->cstats.drop_count - prev_drop_count;
+ 	flow->dropped += q->cstats.ecn_mark - prev_ecn_mark;
Index: target/linux/generic/patches-3.3/020-ssb_update.patch
===================================================================
--- target/linux/generic/patches-3.3/020-ssb_update.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/020-ssb_update.patch	(working copy)
@@ -1,3 +1,20 @@
+--- a/drivers/ssb/b43_pci_bridge.c
++++ b/drivers/ssb/b43_pci_bridge.c
+@@ -29,11 +29,14 @@ static const struct pci_device_id b43_pc
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4320) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4321) },
++	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4322) },
++	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43222) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4329) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x432b) },
++	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x432c) },
+ 	{ 0, },
+ };
+ MODULE_DEVICE_TABLE(pci, b43_pci_bridge_tbl);
 --- a/drivers/ssb/driver_chipcommon_pmu.c
 +++ b/drivers/ssb/driver_chipcommon_pmu.c
 @@ -13,6 +13,9 @@
@@ -149,16 +166,51 @@
  					   &clkctl_n, &clkctl_m);
 --- a/drivers/ssb/pci.c
 +++ b/drivers/ssb/pci.c
-@@ -331,7 +331,6 @@ static void sprom_extract_r123(struct ss
+@@ -178,6 +178,18 @@ err_pci:
+ #define SPEX(_outvar, _offset, _mask, _shift) \
+ 	SPEX16(_outvar, _offset, _mask, _shift)
+ 
++#define SPEX_ARRAY8(_field, _offset, _mask, _shift)	\
++	do {	\
++		SPEX(_field[0], _offset +  0, _mask, _shift);	\
++		SPEX(_field[1], _offset +  2, _mask, _shift);	\
++		SPEX(_field[2], _offset +  4, _mask, _shift);	\
++		SPEX(_field[3], _offset +  6, _mask, _shift);	\
++		SPEX(_field[4], _offset +  8, _mask, _shift);	\
++		SPEX(_field[5], _offset + 10, _mask, _shift);	\
++		SPEX(_field[6], _offset + 12, _mask, _shift);	\
++		SPEX(_field[7], _offset + 14, _mask, _shift);	\
++	} while (0)
++
+ 
+ static inline u8 ssb_crc8(u8 crc, u8 data)
  {
+@@ -331,7 +343,6 @@ static void sprom_extract_r123(struct ss
+ {
  	int i;
  	u16 v;
 -	s8 gain;
  	u16 loc[3];
  
  	if (out->revision == 3)			/* rev 3 moved MAC */
-@@ -390,20 +389,12 @@ static void sprom_extract_r123(struct ss
+@@ -361,8 +372,9 @@ static void sprom_extract_r123(struct ss
+ 	SPEX(et0mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET0M, 14);
+ 	SPEX(et1mdcport, SSB_SPROM1_ETHPHY, SSB_SPROM1_ETHPHY_ET1M, 15);
+ 	SPEX(board_rev, SSB_SPROM1_BINF, SSB_SPROM1_BINF_BREV, 0);
+-	SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
+-	     SSB_SPROM1_BINF_CCODE_SHIFT);
++	if (out->revision == 1)
++		SPEX(country_code, SSB_SPROM1_BINF, SSB_SPROM1_BINF_CCODE,
++		     SSB_SPROM1_BINF_CCODE_SHIFT);
+ 	SPEX(ant_available_a, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTA,
+ 	     SSB_SPROM1_BINF_ANTA_SHIFT);
+ 	SPEX(ant_available_bg, SSB_SPROM1_BINF, SSB_SPROM1_BINF_ANTBG,
+@@ -388,22 +400,16 @@ static void sprom_extract_r123(struct ss
+ 	SPEX(boardflags_lo, SSB_SPROM1_BFLLO, 0xFFFF, 0);
+ 	if (out->revision >= 2)
  		SPEX(boardflags_hi, SSB_SPROM2_BFLHI, 0xFFFF, 0);
++	SPEX(alpha2[0], SSB_SPROM1_CCODE, 0xff00, 8);
++	SPEX(alpha2[1], SSB_SPROM1_CCODE, 0x00ff, 0);
  
  	/* Extract the antenna gain values. */
 -	gain = r123_extract_antgain(out->revision, in,
@@ -184,7 +236,27 @@
  }
  
  /* Revs 4 5 and 8 have partially shared layout */
-@@ -504,16 +495,14 @@ static void sprom_extract_r45(struct ssb
+@@ -464,14 +470,17 @@ static void sprom_extract_r45(struct ssb
+ 	SPEX(et0phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET0A, 0);
+ 	SPEX(et1phyaddr, SSB_SPROM4_ETHPHY, SSB_SPROM4_ETHPHY_ET1A,
+ 	     SSB_SPROM4_ETHPHY_ET1A_SHIFT);
++	SPEX(board_rev, SSB_SPROM4_BOARDREV, 0xFFFF, 0);
+ 	if (out->revision == 4) {
+-		SPEX(country_code, SSB_SPROM4_CCODE, 0xFFFF, 0);
++		SPEX(alpha2[0], SSB_SPROM4_CCODE, 0xff00, 8);
++		SPEX(alpha2[1], SSB_SPROM4_CCODE, 0x00ff, 0);
+ 		SPEX(boardflags_lo, SSB_SPROM4_BFLLO, 0xFFFF, 0);
+ 		SPEX(boardflags_hi, SSB_SPROM4_BFLHI, 0xFFFF, 0);
+ 		SPEX(boardflags2_lo, SSB_SPROM4_BFL2LO, 0xFFFF, 0);
+ 		SPEX(boardflags2_hi, SSB_SPROM4_BFL2HI, 0xFFFF, 0);
+ 	} else {
+-		SPEX(country_code, SSB_SPROM5_CCODE, 0xFFFF, 0);
++		SPEX(alpha2[0], SSB_SPROM5_CCODE, 0xff00, 8);
++		SPEX(alpha2[1], SSB_SPROM5_CCODE, 0x00ff, 0);
+ 		SPEX(boardflags_lo, SSB_SPROM5_BFLLO, 0xFFFF, 0);
+ 		SPEX(boardflags_hi, SSB_SPROM5_BFLHI, 0xFFFF, 0);
+ 		SPEX(boardflags2_lo, SSB_SPROM5_BFL2LO, 0xFFFF, 0);
+@@ -504,16 +513,14 @@ static void sprom_extract_r45(struct ssb
  	}
  
  	/* Extract the antenna gain values. */
@@ -205,7 +277,7 @@
  
  	sprom_extract_r458(out, in);
  
-@@ -523,7 +512,13 @@ static void sprom_extract_r45(struct ssb
+@@ -523,14 +530,22 @@ static void sprom_extract_r45(struct ssb
  static void sprom_extract_r8(struct ssb_sprom *out, const u16 *in)
  {
  	int i;
@@ -220,7 +292,17 @@
  
  	/* extract the MAC address */
  	for (i = 0; i < 3; i++) {
-@@ -596,16 +591,46 @@ static void sprom_extract_r8(struct ssb_
+ 		v = in[SPOFF(SSB_SPROM8_IL0MAC) + i];
+ 		*(((__be16 *)out->il0mac) + i) = cpu_to_be16(v);
+ 	}
+-	SPEX(country_code, SSB_SPROM8_CCODE, 0xFFFF, 0);
++	SPEX(board_rev, SSB_SPROM8_BOARDREV, 0xFFFF, 0);
++	SPEX(alpha2[0], SSB_SPROM8_CCODE, 0xff00, 8);
++	SPEX(alpha2[1], SSB_SPROM8_CCODE, 0x00ff, 0);
+ 	SPEX(boardflags_lo, SSB_SPROM8_BFLLO, 0xFFFF, 0);
+ 	SPEX(boardflags_hi, SSB_SPROM8_BFLHI, 0xFFFF, 0);
+ 	SPEX(boardflags2_lo, SSB_SPROM8_BFL2LO, 0xFFFF, 0);
+@@ -596,16 +611,46 @@ static void sprom_extract_r8(struct ssb_
  	SPEX32(ofdm5ghpo, SSB_SPROM8_OFDM5GHPO, 0xFFFFFFFF, 0);
  
  	/* Extract the antenna gain values. */
@@ -273,6 +355,78 @@
  
  	/* Extract FEM info */
  	SPEX(fem.ghz2.tssipos, SSB_SPROM8_FEM2G,
+@@ -630,6 +675,63 @@ static void sprom_extract_r8(struct ssb_
+ 	SPEX(fem.ghz5.antswlut, SSB_SPROM8_FEM5G,
+ 		SSB_SROM8_FEM_ANTSWLUT, SSB_SROM8_FEM_ANTSWLUT_SHIFT);
+ 
++	SPEX(leddc_on_time, SSB_SPROM8_LEDDC, SSB_SPROM8_LEDDC_ON,
++	     SSB_SPROM8_LEDDC_ON_SHIFT);
++	SPEX(leddc_off_time, SSB_SPROM8_LEDDC, SSB_SPROM8_LEDDC_OFF,
++	     SSB_SPROM8_LEDDC_OFF_SHIFT);
++
++	SPEX(txchain, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_TXCHAIN,
++	     SSB_SPROM8_TXRXC_TXCHAIN_SHIFT);
++	SPEX(rxchain, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_RXCHAIN,
++	     SSB_SPROM8_TXRXC_RXCHAIN_SHIFT);
++	SPEX(antswitch, SSB_SPROM8_TXRXC, SSB_SPROM8_TXRXC_SWITCH,
++	     SSB_SPROM8_TXRXC_SWITCH_SHIFT);
++
++	SPEX(opo, SSB_SPROM8_OFDM2GPO, 0x00ff, 0);
++
++	SPEX_ARRAY8(mcs2gpo, SSB_SPROM8_2G_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5gpo, SSB_SPROM8_5G_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5glpo, SSB_SPROM8_5GL_MCSPO, ~0, 0);
++	SPEX_ARRAY8(mcs5ghpo, SSB_SPROM8_5GH_MCSPO, ~0, 0);
++
++	SPEX(rawtempsense, SSB_SPROM8_RAWTS, SSB_SPROM8_RAWTS_RAWTEMP,
++	     SSB_SPROM8_RAWTS_RAWTEMP_SHIFT);
++	SPEX(measpower, SSB_SPROM8_RAWTS, SSB_SPROM8_RAWTS_MEASPOWER,
++	     SSB_SPROM8_RAWTS_MEASPOWER_SHIFT);
++	SPEX(tempsense_slope, SSB_SPROM8_OPT_CORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMP_SLOPE,
++	     SSB_SPROM8_OPT_CORRX_TEMP_SLOPE_SHIFT);
++	SPEX(tempcorrx, SSB_SPROM8_OPT_CORRX, SSB_SPROM8_OPT_CORRX_TEMPCORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMPCORRX_SHIFT);
++	SPEX(tempsense_option, SSB_SPROM8_OPT_CORRX,
++	     SSB_SPROM8_OPT_CORRX_TEMP_OPTION,
++	     SSB_SPROM8_OPT_CORRX_TEMP_OPTION_SHIFT);
++	SPEX(freqoffset_corr, SSB_SPROM8_HWIQ_IQSWP,
++	     SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR,
++	     SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR_SHIFT);
++	SPEX(iqcal_swp_dis, SSB_SPROM8_HWIQ_IQSWP,
++	     SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP,
++	     SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP_SHIFT);
++	SPEX(hw_iqcal_en, SSB_SPROM8_HWIQ_IQSWP, SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL,
++	     SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL_SHIFT);
++
++	SPEX(bw40po, SSB_SPROM8_BW40PO, ~0, 0);
++	SPEX(cddpo, SSB_SPROM8_CDDPO, ~0, 0);
++	SPEX(stbcpo, SSB_SPROM8_STBCPO, ~0, 0);
++	SPEX(bwduppo, SSB_SPROM8_BWDUPPO, ~0, 0);
++
++	SPEX(tempthresh, SSB_SPROM8_THERMAL, SSB_SPROM8_THERMAL_TRESH,
++	     SSB_SPROM8_THERMAL_TRESH_SHIFT);
++	SPEX(tempoffset, SSB_SPROM8_THERMAL, SSB_SPROM8_THERMAL_OFFSET,
++	     SSB_SPROM8_THERMAL_OFFSET_SHIFT);
++	SPEX(phycal_tempdelta, SSB_SPROM8_TEMPDELTA,
++	     SSB_SPROM8_TEMPDELTA_PHYCAL,
++	     SSB_SPROM8_TEMPDELTA_PHYCAL_SHIFT);
++	SPEX(temps_period, SSB_SPROM8_TEMPDELTA, SSB_SPROM8_TEMPDELTA_PERIOD,
++	     SSB_SPROM8_TEMPDELTA_PERIOD_SHIFT);
++	SPEX(temps_hysteresis, SSB_SPROM8_TEMPDELTA,
++	     SSB_SPROM8_TEMPDELTA_HYSTERESIS,
++	     SSB_SPROM8_TEMPDELTA_HYSTERESIS_SHIFT);
+ 	sprom_extract_r458(out, in);
+ 
+ 	/* TODO - get remaining rev 8 stuff needed */
+@@ -759,7 +861,6 @@ static void ssb_pci_get_boardinfo(struct
+ {
+ 	bi->vendor = bus->host_pci->subsystem_vendor;
+ 	bi->type = bus->host_pci->subsystem_device;
+-	bi->rev = bus->host_pci->revision;
+ }
+ 
+ int ssb_pci_get_invariants(struct ssb_bus *bus,
 --- a/drivers/ssb/pcmcia.c
 +++ b/drivers/ssb/pcmcia.c
 @@ -676,14 +676,10 @@ static int ssb_pcmcia_do_get_invariants(
@@ -296,7 +450,16 @@
  		GOTO_ERROR_ON((tuple->TupleDataLen != 3) &&
 --- a/drivers/ssb/scan.c
 +++ b/drivers/ssb/scan.c
-@@ -318,6 +318,9 @@ int ssb_bus_scan(struct ssb_bus *bus,
+@@ -90,6 +90,8 @@ const char *ssb_core_name(u16 coreid)
+ 		return "ARM 1176";
+ 	case SSB_DEV_ARM_7TDMI:
+ 		return "ARM 7TDMI";
++	case SSB_DEV_ARM_CM3:
++		return "ARM Cortex M3";
+ 	}
+ 	return "UNKNOWN";
+ }
+@@ -318,6 +320,9 @@ int ssb_bus_scan(struct ssb_bus *bus,
  			bus->chip_package = 0;
  		}
  	}
@@ -414,7 +577,7 @@
  	} antenna_gain;
  
  	struct {
-@@ -103,7 +109,79 @@ struct ssb_sprom {
+@@ -103,14 +109,85 @@ struct ssb_sprom {
  		} ghz5;
  	} fem;
  
@@ -495,6 +658,21 @@
  };
  
  /* Information about the PCB the circuitry is soldered on. */
+ struct ssb_boardinfo {
+ 	u16 vendor;
+ 	u16 type;
+-	u8  rev;
+ };
+ 
+ 
+@@ -166,6 +243,7 @@ struct ssb_bus_ops {
+ #define SSB_DEV_MINI_MACPHY	0x823
+ #define SSB_DEV_ARM_1176	0x824
+ #define SSB_DEV_ARM_7TDMI	0x825
++#define SSB_DEV_ARM_CM3		0x82A
+ 
+ /* Vendor-ID values */
+ #define SSB_VENDOR_BROADCOM	0x4243
 --- a/include/linux/ssb/ssb_driver_gige.h
 +++ b/include/linux/ssb/ssb_driver_gige.h
 @@ -2,6 +2,7 @@
@@ -507,10 +685,96 @@
  
 --- a/include/linux/ssb/ssb_regs.h
 +++ b/include/linux/ssb/ssb_regs.h
-@@ -449,6 +449,39 @@
- #define SSB_SPROM8_TS_SLP_OPT_CORRX	0x00B6
- #define SSB_SPROM8_FOC_HWIQ_IQSWP	0x00B8
- #define SSB_SPROM8_PHYCAL_TEMPDELTA	0x00BA
+@@ -228,6 +228,7 @@
+ #define  SSB_SPROM1_AGAIN_BG_SHIFT	0
+ #define  SSB_SPROM1_AGAIN_A		0xFF00	/* A-PHY */
+ #define  SSB_SPROM1_AGAIN_A_SHIFT	8
++#define SSB_SPROM1_CCODE		0x0076
+ 
+ /* SPROM Revision 2 (inherits from rev 1) */
+ #define SSB_SPROM2_BFLHI		0x0038	/* Boardflags (high 16 bits) */
+@@ -267,6 +268,7 @@
+ #define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
+ 
+ /* SPROM Revision 4 */
++#define SSB_SPROM4_BOARDREV		0x0042	/* Board revision */
+ #define SSB_SPROM4_BFLLO		0x0044	/* Boardflags (low 16 bits) */
+ #define SSB_SPROM4_BFLHI		0x0046  /* Board Flags Hi */
+ #define SSB_SPROM4_BFL2LO		0x0048	/* Board flags 2 (low 16 bits) */
+@@ -389,6 +391,11 @@
+ #define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
+ #define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
+ #define  SSB_SPROM8_GPIOB_P3_SHIFT	8
++#define SSB_SPROM8_LEDDC		0x009A
++#define  SSB_SPROM8_LEDDC_ON		0xFF00	/* oncount */
++#define  SSB_SPROM8_LEDDC_ON_SHIFT	8
++#define  SSB_SPROM8_LEDDC_OFF		0x00FF	/* offcount */
++#define  SSB_SPROM8_LEDDC_OFF_SHIFT	0
+ #define SSB_SPROM8_ANTAVAIL		0x009C  /* Antenna available bitfields*/
+ #define  SSB_SPROM8_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
+ #define  SSB_SPROM8_ANTAVAIL_A_SHIFT	8
+@@ -404,6 +411,13 @@
+ #define  SSB_SPROM8_AGAIN2_SHIFT	0
+ #define  SSB_SPROM8_AGAIN3		0xFF00	/* Antenna 3 */
+ #define  SSB_SPROM8_AGAIN3_SHIFT	8
++#define SSB_SPROM8_TXRXC		0x00A2
++#define  SSB_SPROM8_TXRXC_TXCHAIN	0x000f
++#define  SSB_SPROM8_TXRXC_TXCHAIN_SHIFT	0
++#define  SSB_SPROM8_TXRXC_RXCHAIN	0x00f0
++#define  SSB_SPROM8_TXRXC_RXCHAIN_SHIFT	4
++#define  SSB_SPROM8_TXRXC_SWITCH	0xff00
++#define  SSB_SPROM8_TXRXC_SWITCH_SHIFT	8
+ #define SSB_SPROM8_RSSIPARM2G		0x00A4	/* RSSI params for 2GHz */
+ #define  SSB_SPROM8_RSSISMF2G		0x000F
+ #define  SSB_SPROM8_RSSISMC2G		0x00F0
+@@ -430,6 +444,7 @@
+ #define  SSB_SPROM8_TRI5GH_SHIFT	8
+ #define SSB_SPROM8_RXPO			0x00AC  /* RX power offsets */
+ #define  SSB_SPROM8_RXPO2G		0x00FF	/* 2GHz RX power offset */
++#define  SSB_SPROM8_RXPO2G_SHIFT	0
+ #define  SSB_SPROM8_RXPO5G		0xFF00	/* 5GHz RX power offset */
+ #define  SSB_SPROM8_RXPO5G_SHIFT	8
+ #define SSB_SPROM8_FEM2G		0x00AE
+@@ -445,10 +460,71 @@
+ #define  SSB_SROM8_FEM_ANTSWLUT		0xF800
+ #define  SSB_SROM8_FEM_ANTSWLUT_SHIFT	11
+ #define SSB_SPROM8_THERMAL		0x00B2
+-#define SSB_SPROM8_MPWR_RAWTS		0x00B4
+-#define SSB_SPROM8_TS_SLP_OPT_CORRX	0x00B6
+-#define SSB_SPROM8_FOC_HWIQ_IQSWP	0x00B8
+-#define SSB_SPROM8_PHYCAL_TEMPDELTA	0x00BA
++#define  SSB_SPROM8_THERMAL_OFFSET	0x00ff
++#define  SSB_SPROM8_THERMAL_OFFSET_SHIFT	0
++#define  SSB_SPROM8_THERMAL_TRESH	0xff00
++#define  SSB_SPROM8_THERMAL_TRESH_SHIFT	8
++/* Temp sense related entries */
++#define SSB_SPROM8_RAWTS		0x00B4
++#define  SSB_SPROM8_RAWTS_RAWTEMP	0x01ff
++#define  SSB_SPROM8_RAWTS_RAWTEMP_SHIFT	0
++#define  SSB_SPROM8_RAWTS_MEASPOWER	0xfe00
++#define  SSB_SPROM8_RAWTS_MEASPOWER_SHIFT	9
++#define SSB_SPROM8_OPT_CORRX		0x00B6
++#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE	0x00ff
++#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE_SHIFT	0
++#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX	0xfc00
++#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX_SHIFT	10
++#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION	0x0300
++#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION_SHIFT	8
++/* FOC: freiquency offset correction, HWIQ: H/W IOCAL enable, IQSWP: IQ CAL swap disable */
++#define SSB_SPROM8_HWIQ_IQSWP		0x00B8
++#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR	0x000f
++#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR_SHIFT	0
++#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP	0x0010
++#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP_SHIFT	4
++#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL	0x0020
++#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL_SHIFT	5
++#define SSB_SPROM8_TEMPDELTA		0x00BA
++#define  SSB_SPROM8_TEMPDELTA_PHYCAL	0x00ff
++#define  SSB_SPROM8_TEMPDELTA_PHYCAL_SHIFT	0
++#define  SSB_SPROM8_TEMPDELTA_PERIOD	0x0f00
++#define  SSB_SPROM8_TEMPDELTA_PERIOD_SHIFT	8
++#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS	0xf000
++#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS_SHIFT	12
 +
 +/* There are 4 blocks with power info sharing the same layout */
 +#define SSB_SROM8_PWR_INFO_CORE0	0x00C0
@@ -547,7 +811,7 @@
  #define SSB_SPROM8_MAXP_BG		0x00C0  /* Max Power 2GHz in path 1 */
  #define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power 2GHz */
  #define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
-@@ -473,6 +506,7 @@
+@@ -473,12 +549,23 @@
  #define SSB_SPROM8_PA1HIB0		0x00D8	/* 5.8GHz power amp settings */
  #define SSB_SPROM8_PA1HIB1		0x00DA
  #define SSB_SPROM8_PA1HIB2		0x00DC
@@ -555,3 +819,19 @@
  #define SSB_SPROM8_CCK2GPO		0x0140	/* CCK power offset */
  #define SSB_SPROM8_OFDM2GPO		0x0142	/* 2.4GHz OFDM power offset */
  #define SSB_SPROM8_OFDM5GPO		0x0146	/* 5.3GHz OFDM power offset */
+ #define SSB_SPROM8_OFDM5GLPO		0x014A	/* 5.2GHz OFDM power offset */
+ #define SSB_SPROM8_OFDM5GHPO		0x014E	/* 5.8GHz OFDM power offset */
+ 
++#define SSB_SPROM8_2G_MCSPO		0x0152
++#define SSB_SPROM8_5G_MCSPO		0x0162
++#define SSB_SPROM8_5GL_MCSPO		0x0172
++#define SSB_SPROM8_5GH_MCSPO		0x0182
++
++#define SSB_SPROM8_CDDPO		0x0192
++#define SSB_SPROM8_STBCPO		0x0194
++#define SSB_SPROM8_BW40PO		0x0196
++#define SSB_SPROM8_BWDUPPO		0x0198
++
+ /* Values for boardflags_lo read from SPROM */
+ #define SSB_BFL_BTCOEXIST		0x0001	/* implements Bluetooth coexistance */
+ #define SSB_BFL_PACTRL			0x0002	/* GPIO 9 controlling the PA */
Index: target/linux/generic/patches-3.3/655-increase_skb_pad.patch
===================================================================
--- target/linux/generic/patches-3.3/655-increase_skb_pad.patch	(revision 0)
+++ target/linux/generic/patches-3.3/655-increase_skb_pad.patch	(revision 0)
@@ -0,0 +1,11 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -1558,7 +1558,7 @@ static inline int pskb_network_may_pull(
+  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
+  */
+ #ifndef NET_SKB_PAD
+-#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
++#define NET_SKB_PAD	max(48, L1_CACHE_BYTES)
+ #endif
+ 
+ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
Index: target/linux/generic/patches-3.3/060-tcp-ecn-dont-delay-ACKS-after-CE.patch
===================================================================
--- target/linux/generic/patches-3.3/060-tcp-ecn-dont-delay-ACKS-after-CE.patch	(revision 0)
+++ target/linux/generic/patches-3.3/060-tcp-ecn-dont-delay-ACKS-after-CE.patch	(revision 0)
@@ -0,0 +1,61 @@
+From patchwork Mon Aug  6 21:04:43 2012
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+Subject: [net-next] tcp: ecn: dont delay ACKS after CE
+Date: Mon, 06 Aug 2012 11:04:43 -0000
+From: Eric Dumazet <eric.dumazet@gmail.com>
+X-Patchwork-Id: 175453
+Message-Id: <1344287083.26674.83.camel@edumazet-glaptop>
+To: David Miller <davem@davemloft.net>
+Cc: netdev <netdev@vger.kernel.org>,
+	Neal Cardwell <ncardwell@google.com>
+
+From: Eric Dumazet <edumazet@google.com>
+
+While playing with CoDel and ECN marking, I discovered a
+non optimal behavior of receiver of CE (Congestion Encountered)
+segments.
+
+In pathological cases, sender has reduced its cwnd to low values,
+and receiver delays its ACK (by 40 ms).
+
+While RFC 3168 6.1.3 (The TCP Receiver) doesn't explicitly recommend
+to send immediate ACKS, we believe its better to not delay ACKS, because
+a CE segment should give same signal than a dropped segment, and its
+quite important to reduce RTT to give ECE/CWR signals as fast as
+possible.
+
+Note we already call tcp_enter_quickack_mode() from TCP_ECN_check_ce()
+if we receive a retransmit, for the same reason.
+
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: Neal Cardwell <ncardwell@google.com>
+Acked-by: Neal Cardwell <ncardwell@google.com>
+
+---
+net/ipv4/tcp_input.c |    6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+
+
+--
+To unsubscribe from this list: send the line "unsubscribe netdev" in
+the body of a message to majordomo@vger.kernel.org
+More majordomo info at  http://vger.kernel.org/majordomo-info.html
+
+--- a/net/ipv4/tcp_input.c
++++ b/net/ipv4/tcp_input.c
+@@ -231,7 +231,11 @@ static inline void TCP_ECN_check_ce(stru
+ 			tcp_enter_quickack_mode((struct sock *)tp);
+ 		break;
+ 	case INET_ECN_CE:
+-		tp->ecn_flags |= TCP_ECN_DEMAND_CWR;
++		if (!(tp->ecn_flags & TCP_ECN_DEMAND_CWR)) {
++			/* Better not delay acks, sender can have a very low cwnd */
++			tcp_enter_quickack_mode((struct sock *)tp);
++			tp->ecn_flags |= TCP_ECN_DEMAND_CWR;
++		}
+ 		/* fallinto */
+ 	default:
+ 		tp->ecn_flags |= TCP_ECN_SEEN;
Index: target/linux/generic/patches-3.3/051-rng_git_backport-remove_irqf_sample_random.patch
===================================================================
--- target/linux/generic/patches-3.3/051-rng_git_backport-remove_irqf_sample_random.patch	(revision 0)
+++ target/linux/generic/patches-3.3/051-rng_git_backport-remove_irqf_sample_random.patch	(revision 0)
@@ -0,0 +1,543 @@
+--- a/arch/arm/mach-omap1/board-palmz71.c
++++ b/arch/arm/mach-omap1/board-palmz71.c
+@@ -291,8 +291,7 @@ palmz71_gpio_setup(int early)
+ 		}
+ 		gpio_direction_input(PALMZ71_USBDETECT_GPIO);
+ 		if (request_irq(gpio_to_irq(PALMZ71_USBDETECT_GPIO),
+-				palmz71_powercable, IRQF_SAMPLE_RANDOM,
+-				"palmz71-cable", 0))
++				palmz71_powercable, 0, "palmz71-cable", 0))
+ 			printk(KERN_ERR
+ 					"IRQ request for power cable failed!\n");
+ 		palmz71_powercable(gpio_to_irq(PALMZ71_USBDETECT_GPIO), 0);
+--- a/arch/arm/mach-pxa/lubbock.c
++++ b/arch/arm/mach-pxa/lubbock.c
+@@ -455,7 +455,7 @@ static int lubbock_mci_init(struct devic
+ 	init_timer(&mmc_timer);
+ 	mmc_timer.data = (unsigned long) data;
+ 	return request_irq(LUBBOCK_SD_IRQ, lubbock_detect_int,
+-			IRQF_SAMPLE_RANDOM, "lubbock-sd-detect", data);
++			   0, "lubbock-sd-detect", data);
+ }
+ 
+ static int lubbock_mci_get_ro(struct device *dev)
+--- a/arch/arm/mach-pxa/magician.c
++++ b/arch/arm/mach-pxa/magician.c
+@@ -617,9 +617,8 @@ static struct platform_device bq24022 =
+ static int magician_mci_init(struct device *dev,
+ 				irq_handler_t detect_irq, void *data)
+ {
+-	return request_irq(IRQ_MAGICIAN_SD, detect_irq,
+-				IRQF_DISABLED | IRQF_SAMPLE_RANDOM,
+-				"mmc card detect", data);
++	return request_irq(IRQ_MAGICIAN_SD, detect_irq, IRQF_DISABLED,
++			   "mmc card detect", data);
+ }
+ 
+ static void magician_mci_exit(struct device *dev, void *data)
+--- a/arch/arm/mach-pxa/trizeps4.c
++++ b/arch/arm/mach-pxa/trizeps4.c
+@@ -332,8 +332,8 @@ static int trizeps4_mci_init(struct devi
+ 	int err;
+ 
+ 	err = request_irq(TRIZEPS4_MMC_IRQ, mci_detect_int,
+-		IRQF_DISABLED | IRQF_TRIGGER_RISING | IRQF_SAMPLE_RANDOM,
+-		"MMC card detect", data);
++			  IRQF_DISABLED | IRQF_TRIGGER_RISING,
++			  "MMC card detect", data);
+ 	if (err) {
+ 		printk(KERN_ERR "trizeps4_mci_init: MMC/SD: can't request"
+ 						"MMC card detect IRQ\n");
+--- a/arch/ia64/kernel/irq_ia64.c
++++ b/arch/ia64/kernel/irq_ia64.c
+@@ -23,7 +23,6 @@
+ #include <linux/ioport.h>
+ #include <linux/kernel_stat.h>
+ #include <linux/ptrace.h>
+-#include <linux/random.h>	/* for rand_initialize_irq() */
+ #include <linux/signal.h>
+ #include <linux/smp.h>
+ #include <linux/threads.h>
+--- a/arch/sparc/kernel/ldc.c
++++ b/arch/sparc/kernel/ldc.c
+@@ -1250,14 +1250,12 @@ int ldc_bind(struct ldc_channel *lp, con
+ 	snprintf(lp->rx_irq_name, LDC_IRQ_NAME_MAX, "%s RX", name);
+ 	snprintf(lp->tx_irq_name, LDC_IRQ_NAME_MAX, "%s TX", name);
+ 
+-	err = request_irq(lp->cfg.rx_irq, ldc_rx,
+-			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED,
++	err = request_irq(lp->cfg.rx_irq, ldc_rx, IRQF_DISABLED,
+ 			  lp->rx_irq_name, lp);
+ 	if (err)
+ 		return err;
+ 
+-	err = request_irq(lp->cfg.tx_irq, ldc_tx,
+-			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED,
++	err = request_irq(lp->cfg.tx_irq, ldc_tx, IRQF_DISABLED,
+ 			  lp->tx_irq_name, lp);
+ 	if (err) {
+ 		free_irq(lp->cfg.rx_irq, lp);
+--- a/arch/um/drivers/line.c
++++ b/arch/um/drivers/line.c
+@@ -371,7 +371,7 @@ static irqreturn_t line_write_interrupt(
+ int line_setup_irq(int fd, int input, int output, struct line *line, void *data)
+ {
+ 	const struct line_driver *driver = line->driver;
+-	int err = 0, flags = IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM;
++	int err = 0, flags = IRQF_DISABLED | IRQF_SHARED;
+ 
+ 	if (input)
+ 		err = um_request_irq(driver->read_irq, fd, IRQ_READ,
+@@ -807,7 +807,7 @@ void register_winch_irq(int fd, int tty_
+ 				   .stack	= stack });
+ 
+ 	if (um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,
+-			   IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
++			   IRQF_DISABLED | IRQF_SHARED,
+ 			   "winch", winch) < 0) {
+ 		printk(KERN_ERR "register_winch_irq - failed to register "
+ 		       "IRQ\n");
+--- a/arch/um/drivers/mconsole_kern.c
++++ b/arch/um/drivers/mconsole_kern.c
+@@ -773,7 +773,7 @@ static int __init mconsole_init(void)
+ 	register_reboot_notifier(&reboot_notifier);
+ 
+ 	err = um_request_irq(MCONSOLE_IRQ, sock, IRQ_READ, mconsole_interrupt,
+-			     IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
++			     IRQF_DISABLED | IRQF_SHARED,
+ 			     "mconsole", (void *)sock);
+ 	if (err) {
+ 		printk(KERN_ERR "Failed to get IRQ for management console\n");
+--- a/arch/um/drivers/port_kern.c
++++ b/arch/um/drivers/port_kern.c
+@@ -100,7 +100,7 @@ static int port_accept(struct port_list
+ 		  .port 	= port });
+ 
+ 	if (um_request_irq(TELNETD_IRQ, socket[0], IRQ_READ, pipe_interrupt,
+-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
++			  IRQF_DISABLED | IRQF_SHARED,
+ 			  "telnetd", conn)) {
+ 		printk(KERN_ERR "port_accept : failed to get IRQ for "
+ 		       "telnetd\n");
+@@ -184,7 +184,7 @@ void *port_data(int port_num)
+ 	}
+ 
+ 	if (um_request_irq(ACCEPT_IRQ, fd, IRQ_READ, port_interrupt,
+-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
++			  IRQF_DISABLED | IRQF_SHARED,
+ 			  "port", port)) {
+ 		printk(KERN_ERR "Failed to get IRQ for port %d\n", port_num);
+ 		goto out_close;
+--- a/arch/um/drivers/random.c
++++ b/arch/um/drivers/random.c
+@@ -131,8 +131,7 @@ static int __init rng_init (void)
+ 	random_fd = err;
+ 
+ 	err = um_request_irq(RANDOM_IRQ, random_fd, IRQ_READ, random_interrupt,
+-			     IRQF_DISABLED | IRQF_SAMPLE_RANDOM, "random",
+-			     NULL);
++			     IRQF_DISABLED, "random", NULL);
+ 	if (err)
+ 		goto err_out_cleanup_hw;
+ 
+--- a/arch/um/drivers/xterm_kern.c
++++ b/arch/um/drivers/xterm_kern.c
+@@ -50,8 +50,7 @@ int xterm_fd(int socket, int *pid_out)
+ 	init_completion(&data->ready);
+ 
+ 	err = um_request_irq(XTERM_IRQ, socket, IRQ_READ, xterm_interrupt,
+-			     IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+-			     "xterm", data);
++			     IRQF_DISABLED | IRQF_SHARED, "xterm", data);
+ 	if (err) {
+ 		printk(KERN_ERR "xterm_fd : failed to get IRQ for xterm, "
+ 		       "err = %d\n",  err);
+--- a/arch/um/kernel/sigio.c
++++ b/arch/um/kernel/sigio.c
+@@ -25,8 +25,7 @@ int write_sigio_irq(int fd)
+ 	int err;
+ 
+ 	err = um_request_irq(SIGIO_WRITE_IRQ, fd, IRQ_READ, sigio_interrupt,
+-			     IRQF_DISABLED|IRQF_SAMPLE_RANDOM, "write sigio",
+-			     NULL);
++			     IRQF_DISABLED, "write sigio", NULL);
+ 	if (err) {
+ 		printk(KERN_ERR "write_sigio_irq : um_request_irq failed, "
+ 		       "err = %d\n", err);
+--- a/Documentation/feature-removal-schedule.txt
++++ b/Documentation/feature-removal-schedule.txt
+@@ -71,20 +71,6 @@ Who:	Luis R. Rodriguez <lrodriguez@ather
+ 
+ ---------------------------
+ 
+-What:	IRQF_SAMPLE_RANDOM
+-Check:	IRQF_SAMPLE_RANDOM
+-When:	July 2009
+-
+-Why:	Many of IRQF_SAMPLE_RANDOM users are technically bogus as entropy
+-	sources in the kernel's current entropy model. To resolve this, every
+-	input point to the kernel's entropy pool needs to better document the
+-	type of entropy source it actually is. This will be replaced with
+-	additional add_*_randomness functions in drivers/char/random.c
+-
+-Who:	Robin Getz <rgetz@blackfin.uclinux.org> & Matt Mackall <mpm@selenic.com>
+-
+----------------------------
+-
+ What:	The ieee80211_regdom module parameter
+ When:	March 2010 / desktop catchup
+ 
+--- a/drivers/block/xen-blkfront.c
++++ b/drivers/block/xen-blkfront.c
+@@ -852,9 +852,8 @@ static int setup_blkring(struct xenbus_d
+ 	if (err)
+ 		goto fail;
+ 
+-	err = bind_evtchn_to_irqhandler(info->evtchn,
+-					blkif_interrupt,
+-					IRQF_SAMPLE_RANDOM, "blkif", info);
++	err = bind_evtchn_to_irqhandler(info->evtchn, blkif_interrupt, 0,
++					"blkif", info);
+ 	if (err <= 0) {
+ 		xenbus_dev_fatal(dev, err,
+ 				 "bind_evtchn_to_irqhandler failed");
+--- a/drivers/char/random.c
++++ b/drivers/char/random.c
+@@ -633,43 +633,6 @@ struct timer_rand_state {
+ 	unsigned dont_count_entropy:1;
+ };
+ 
+-#ifndef CONFIG_GENERIC_HARDIRQS
+-
+-static struct timer_rand_state *irq_timer_state[NR_IRQS];
+-
+-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
+-{
+-	return irq_timer_state[irq];
+-}
+-
+-static void set_timer_rand_state(unsigned int irq,
+-				 struct timer_rand_state *state)
+-{
+-	irq_timer_state[irq] = state;
+-}
+-
+-#else
+-
+-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
+-{
+-	struct irq_desc *desc;
+-
+-	desc = irq_to_desc(irq);
+-
+-	return desc->timer_rand_state;
+-}
+-
+-static void set_timer_rand_state(unsigned int irq,
+-				 struct timer_rand_state *state)
+-{
+-	struct irq_desc *desc;
+-
+-	desc = irq_to_desc(irq);
+-
+-	desc->timer_rand_state = state;
+-}
+-#endif
+-
+ /*
+  * Add device- or boot-specific data to the input and nonblocking
+  * pools to help initialize them to unique values.
+@@ -1131,24 +1094,6 @@ static int rand_initialize(void)
+ }
+ module_init(rand_initialize);
+ 
+-void rand_initialize_irq(int irq)
+-{
+-	struct timer_rand_state *state;
+-
+-	state = get_timer_rand_state(irq);
+-
+-	if (state)
+-		return;
+-
+-	/*
+-	 * If kzalloc returns null, we just won't use that entropy
+-	 * source.
+-	 */
+-	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
+-	if (state)
+-		set_timer_rand_state(irq, state);
+-}
+-
+ #ifdef CONFIG_BLOCK
+ void rand_initialize_disk(struct gendisk *disk)
+ {
+--- a/drivers/crypto/n2_core.c
++++ b/drivers/crypto/n2_core.c
+@@ -1607,8 +1607,7 @@ static int spu_map_ino(struct platform_d
+ 
+ 	sprintf(p->irq_name, "%s-%d", irq_name, index);
+ 
+-	return request_irq(p->irq, handler, IRQF_SAMPLE_RANDOM,
+-			   p->irq_name, p);
++	return request_irq(p->irq, handler, 0, p->irq_name, p);
+ }
+ 
+ static struct kmem_cache *queue_cache[2];
+--- a/drivers/hv/vmbus_drv.c
++++ b/drivers/hv/vmbus_drv.c
+@@ -545,8 +545,7 @@ static int vmbus_bus_init(int irq)
+ 	if (ret)
+ 		goto err_cleanup;
+ 
+-	ret = request_irq(irq, vmbus_isr, IRQF_SAMPLE_RANDOM,
+-			driver_name, hv_acpi_dev);
++	ret = request_irq(irq, vmbus_isr, 0, driver_name, hv_acpi_dev);
+ 
+ 	if (ret != 0) {
+ 		pr_err("Unable to request IRQ %d\n",
+--- a/drivers/i2c/busses/i2c-pmcmsp.c
++++ b/drivers/i2c/busses/i2c-pmcmsp.c
+@@ -306,8 +306,7 @@ static int __devinit pmcmsptwi_probe(str
+ 	pmcmsptwi_data.irq = platform_get_irq(pldev, 0);
+ 	if (pmcmsptwi_data.irq) {
+ 		rc = request_irq(pmcmsptwi_data.irq, &pmcmsptwi_interrupt,
+-			IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+-			pldev->name, &pmcmsptwi_data);
++				 IRQF_SHARED, pldev->name, &pmcmsptwi_data);
+ 		if (rc == 0) {
+ 			/*
+ 			 * Enable 'DONE' interrupt only.
+--- a/drivers/input/serio/hp_sdc.c
++++ b/drivers/input/serio/hp_sdc.c
+@@ -879,7 +879,7 @@ static int __init hp_sdc_init(void)
+ #endif
+ 
+ 	errstr = "IRQ not available for";
+-	if (request_irq(hp_sdc.irq, &hp_sdc_isr, IRQF_SHARED|IRQF_SAMPLE_RANDOM,
++	if (request_irq(hp_sdc.irq, &hp_sdc_isr, IRQF_SHARED,
+ 			"HP SDC", &hp_sdc))
+ 		goto err1;
+ 
+--- a/drivers/mfd/ab3100-core.c
++++ b/drivers/mfd/ab3100-core.c
+@@ -937,9 +937,6 @@ static int __devinit ab3100_probe(struct
+ 
+ 	err = request_threaded_irq(client->irq, NULL, ab3100_irq_handler,
+ 				IRQF_ONESHOT, "ab3100-core", ab3100);
+-	/* This real unpredictable IRQ is of course sampled for entropy */
+-	rand_initialize_irq(client->irq);
+-
+ 	if (err)
+ 		goto exit_no_irq;
+ 
+--- a/drivers/mfd/tps65010.c
++++ b/drivers/mfd/tps65010.c
+@@ -563,8 +563,7 @@ static int tps65010_probe(struct i2c_cli
+ 	 */
+ 	if (client->irq > 0) {
+ 		status = request_irq(client->irq, tps65010_irq,
+-			IRQF_SAMPLE_RANDOM | IRQF_TRIGGER_FALLING,
+-			DRIVER_NAME, tps);
++			IRQF_TRIGGER_FALLING, DRIVER_NAME, tps);
+ 		if (status < 0) {
+ 			dev_dbg(&client->dev, "can't get IRQ %d, err %d\n",
+ 					client->irq, status);
+--- a/drivers/net/ethernet/broadcom/tg3.c
++++ b/drivers/net/ethernet/broadcom/tg3.c
+@@ -9415,7 +9415,7 @@ static int tg3_test_interrupt(struct tg3
+ 	}
+ 
+ 	err = request_irq(tnapi->irq_vec, tg3_test_isr,
+-			  IRQF_SHARED | IRQF_SAMPLE_RANDOM, dev->name, tnapi);
++			  IRQF_SHARED, dev->name, tnapi);
+ 	if (err)
+ 		return err;
+ 
+--- a/drivers/power/pda_power.c
++++ b/drivers/power/pda_power.c
+@@ -24,11 +24,7 @@
+ 
+ static inline unsigned int get_irq_flags(struct resource *res)
+ {
+-	unsigned int flags = IRQF_SAMPLE_RANDOM | IRQF_SHARED;
+-
+-	flags |= res->flags & IRQF_TRIGGER_MASK;
+-
+-	return flags;
++	return IRQF_SHARED | (res->flags & IRQF_TRIGGER_MASK);
+ }
+ 
+ static struct device *dev;
+--- a/drivers/tty/serial/uartlite.c
++++ b/drivers/tty/serial/uartlite.c
+@@ -216,8 +216,7 @@ static int ulite_startup(struct uart_por
+ {
+ 	int ret;
+ 
+-	ret = request_irq(port->irq, ulite_isr,
+-			  IRQF_SHARED | IRQF_SAMPLE_RANDOM, "uartlite", port);
++	ret = request_irq(port->irq, ulite_isr, IRQF_SHARED, "uartlite", port);
+ 	if (ret)
+ 		return ret;
+ 
+--- a/drivers/usb/gadget/goku_udc.c
++++ b/drivers/usb/gadget/goku_udc.c
+@@ -1839,7 +1839,7 @@ static int goku_probe(struct pci_dev *pd
+ 	/* init to known state, then setup irqs */
+ 	udc_reset(dev);
+ 	udc_reinit (dev);
+-	if (request_irq(pdev->irq, goku_irq, IRQF_SHARED/*|IRQF_SAMPLE_RANDOM*/,
++	if (request_irq(pdev->irq, goku_irq, IRQF_SHARED,
+ 			driver_name, dev) != 0) {
+ 		DBG(dev, "request interrupt %d failed\n", pdev->irq);
+ 		retval = -EBUSY;
+--- a/drivers/usb/gadget/omap_udc.c
++++ b/drivers/usb/gadget/omap_udc.c
+@@ -2943,7 +2943,7 @@ known:
+ 
+ 	/* USB general purpose IRQ:  ep0, state changes, dma, etc */
+ 	status = request_irq(pdev->resource[1].start, omap_udc_irq,
+-			IRQF_SAMPLE_RANDOM, driver_name, udc);
++			     0, driver_name, udc);
+ 	if (status != 0) {
+ 		ERR("can't get irq %d, err %d\n",
+ 			(int) pdev->resource[1].start, status);
+@@ -2952,7 +2952,7 @@ known:
+ 
+ 	/* USB "non-iso" IRQ (PIO for all but ep0) */
+ 	status = request_irq(pdev->resource[2].start, omap_udc_pio_irq,
+-			IRQF_SAMPLE_RANDOM, "omap_udc pio", udc);
++			     0, "omap_udc pio", udc);
+ 	if (status != 0) {
+ 		ERR("can't get irq %d, err %d\n",
+ 			(int) pdev->resource[2].start, status);
+--- a/drivers/usb/gadget/pxa25x_udc.c
++++ b/drivers/usb/gadget/pxa25x_udc.c
+@@ -2202,19 +2202,15 @@ static int __init pxa25x_udc_probe(struc
+ 
+ #ifdef CONFIG_ARCH_LUBBOCK
+ 	if (machine_is_lubbock()) {
+-		retval = request_irq(LUBBOCK_USB_DISC_IRQ,
+-				lubbock_vbus_irq,
+-				IRQF_SAMPLE_RANDOM,
+-				driver_name, dev);
++		retval = request_irq(LUBBOCK_USB_DISC_IRQ, lubbock_vbus_irq,
++				     0, driver_name, dev);
+ 		if (retval != 0) {
+ 			pr_err("%s: can't get irq %i, err %d\n",
+ 				driver_name, LUBBOCK_USB_DISC_IRQ, retval);
+ 			goto err_irq_lub;
+ 		}
+-		retval = request_irq(LUBBOCK_USB_IRQ,
+-				lubbock_vbus_irq,
+-				IRQF_SAMPLE_RANDOM,
+-				driver_name, dev);
++		retval = request_irq(LUBBOCK_USB_IRQ, lubbock_vbus_irq,
++				     0, driver_name, dev);
+ 		if (retval != 0) {
+ 			pr_err("%s: can't get irq %i, err %d\n",
+ 				driver_name, LUBBOCK_USB_IRQ, retval);
+--- a/drivers/usb/otg/gpio_vbus.c
++++ b/drivers/usb/otg/gpio_vbus.c
+@@ -51,8 +51,7 @@ struct gpio_vbus_data {
+  * edges might be workable.
+  */
+ #define VBUS_IRQ_FLAGS \
+-	( IRQF_SAMPLE_RANDOM | IRQF_SHARED \
+-	| IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING )
++	( IRQF_SHARED | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING )
+ 
+ 
+ /* interface to regulator framework */
+@@ -253,7 +252,7 @@ static int __init gpio_vbus_probe(struct
+ 	if (res) {
+ 		irq = res->start;
+ 		res->flags &= IRQF_TRIGGER_MASK;
+-		res->flags |= IRQF_SAMPLE_RANDOM | IRQF_SHARED;
++		res->flags |= IRQF_SHARED;
+ 	} else
+ 		irq = gpio_to_irq(gpio);
+ 
+--- a/drivers/usb/otg/isp1301_omap.c
++++ b/drivers/usb/otg/isp1301_omap.c
+@@ -1567,7 +1567,6 @@ isp1301_probe(struct i2c_client *i2c, co
+ 		isp->irq_type = IRQF_TRIGGER_FALLING;
+ 	}
+ 
+-	isp->irq_type |= IRQF_SAMPLE_RANDOM;
+ 	status = request_irq(i2c->irq, isp1301_irq,
+ 			isp->irq_type, DRIVER_NAME, isp);
+ 	if (status < 0) {
+--- a/include/linux/interrupt.h
++++ b/include/linux/interrupt.h
+@@ -44,7 +44,6 @@
+  *
+  * IRQF_DISABLED - keep irqs disabled when calling the action handler.
+  *                 DEPRECATED. This flag is a NOOP and scheduled to be removed
+- * IRQF_SAMPLE_RANDOM - irq is used to feed the random generator
+  * IRQF_SHARED - allow sharing the irq among several devices
+  * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
+  * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
+@@ -63,7 +62,6 @@
+  *                resume time.
+  */
+ #define IRQF_DISABLED		0x00000020
+-#define IRQF_SAMPLE_RANDOM	0x00000040
+ #define IRQF_SHARED		0x00000080
+ #define IRQF_PROBE_SHARED	0x00000100
+ #define __IRQF_TIMER		0x00000200
+--- a/include/linux/irqdesc.h
++++ b/include/linux/irqdesc.h
+@@ -39,7 +39,6 @@ struct module;
+  */
+ struct irq_desc {
+ 	struct irq_data		irq_data;
+-	struct timer_rand_state *timer_rand_state;
+ 	unsigned int __percpu	*kstat_irqs;
+ 	irq_flow_handler_t	handle_irq;
+ #ifdef CONFIG_IRQ_PREFLOW_FASTEOI
+--- a/include/linux/random.h
++++ b/include/linux/random.h
+@@ -48,8 +48,6 @@ struct rnd_state {
+ 
+ #ifdef __KERNEL__
+ 
+-extern void rand_initialize_irq(int irq);
+-
+ extern void add_device_randomness(const void *, unsigned int);
+ extern void add_input_randomness(unsigned int type, unsigned int code,
+ 				 unsigned int value);
+--- a/kernel/irq/manage.c
++++ b/kernel/irq/manage.c
+@@ -891,22 +891,6 @@ __setup_irq(unsigned int irq, struct irq
+ 		return -ENOSYS;
+ 	if (!try_module_get(desc->owner))
+ 		return -ENODEV;
+-	/*
+-	 * Some drivers like serial.c use request_irq() heavily,
+-	 * so we have to be careful not to interfere with a
+-	 * running system.
+-	 */
+-	if (new->flags & IRQF_SAMPLE_RANDOM) {
+-		/*
+-		 * This function might sleep, we want to call it first,
+-		 * outside of the atomic block.
+-		 * Yes, this might clear the entropy pool if the wrong
+-		 * driver is attempted to be loaded, without actually
+-		 * installing a new handler, but is this really a problem,
+-		 * only the sysadmin is able to do this.
+-		 */
+-		rand_initialize_irq(irq);
+-	}
+ 
+ 	/*
+ 	 * Check whether the interrupt nests into another interrupt
+@@ -1342,7 +1326,6 @@ EXPORT_SYMBOL(free_irq);
+  *	Flags:
+  *
+  *	IRQF_SHARED		Interrupt is shared
+- *	IRQF_SAMPLE_RANDOM	The interrupt can be used for entropy
+  *	IRQF_TRIGGER_*		Specify active edge(s) or level
+  *
+  */
Index: target/linux/generic/patches-3.3/477-mtd-m25p80-add-support-for-the-EON-EN25Q64-chip.patch
===================================================================
--- target/linux/generic/patches-3.3/477-mtd-m25p80-add-support-for-the-EON-EN25Q64-chip.patch	(revision 0)
+++ target/linux/generic/patches-3.3/477-mtd-m25p80-add-support-for-the-EON-EN25Q64-chip.patch	(revision 0)
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -677,6 +677,7 @@ static const struct spi_device_id m25p_i
+ 	{ "en25p32", INFO(0x1c2016, 0, 64 * 1024,  64, 0) },
+ 	{ "en25q32b", INFO(0x1c3016, 0, 64 * 1024,  64, 0) },
+ 	{ "en25p64", INFO(0x1c2017, 0, 64 * 1024, 128, 0) },
++	{ "en25q64", INFO(0x1c3017, 0, 64 * 1024, 128, SECT_4K) },
+ 
+ 	/* Intel/Numonyx -- xxxs33b */
+ 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
Index: target/linux/generic/patches-3.3/941-ocf_20120127.patch
===================================================================
--- target/linux/generic/patches-3.3/941-ocf_20120127.patch	(revision 0)
+++ target/linux/generic/patches-3.3/941-ocf_20120127.patch	(revision 0)
@@ -0,0 +1,164 @@
+--- a/drivers/char/random.c
++++ b/drivers/char/random.c
+@@ -131,6 +131,9 @@
+  *	void add_interrupt_randomness(int irq, int irq_flags);
+  * 	void add_disk_randomness(struct gendisk *disk);
+  *
++ *      void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
++ *      int random_input_wait(void);
++ *
+  * add_input_randomness() uses the input layer interrupt timing, as well as
+  * the event type information from the hardware.
+  *
+@@ -152,6 +155,13 @@
+  * seek times do not make for good sources of entropy, as their seek
+  * times are usually fairly consistent.
+  *
++ * random_input_words() just provides a raw block of entropy to the input
++ * pool, such as from a hardware entropy generator.
++ *
++ * random_input_wait() suspends the caller until such time as the
++ * entropy pool falls below the write threshold, and returns a count of how
++ * much entropy (in bits) is needed to sustain the pool.
++ *
+  * All of these routines try to estimate how many bits of randomness a
+  * particular randomness source.  They do this by keeping track of the
+  * first and second order deltas of the event timings.
+@@ -796,6 +806,63 @@ void add_disk_randomness(struct gendisk
+ }
+ #endif
+ 
++/*
++ * random_input_words - add bulk entropy to pool
++ *
++ * @buf: buffer to add
++ * @wordcount: number of __u32 words to add
++ * @ent_count: total amount of entropy (in bits) to credit
++ *
++ * this provides bulk input of entropy to the input pool
++ *
++ */
++void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
++{
++	mix_pool_bytes(&input_pool, buf, wordcount*4, NULL);
++
++	credit_entropy_bits(&input_pool, ent_count);
++
++	DEBUG_ENT("crediting %d bits => %d\n",
++		  ent_count, input_pool.entropy_count);
++	/*
++	 * Wake up waiting processes if we have enough
++	 * entropy.
++	 */
++	if (input_pool.entropy_count >= random_read_wakeup_thresh)
++		wake_up_interruptible(&random_read_wait);
++}
++EXPORT_SYMBOL(random_input_words);
++
++/*
++ * random_input_wait - wait until random needs entropy
++ *
++ * this function sleeps until the /dev/random subsystem actually
++ * needs more entropy, and then return the amount of entropy
++ * that it would be nice to have added to the system.
++ */
++int random_input_wait(void)
++{
++	int count;
++
++	wait_event_interruptible(random_write_wait, 
++			 input_pool.entropy_count < random_write_wakeup_thresh);
++
++	count = random_write_wakeup_thresh - input_pool.entropy_count;
++
++        /* likely we got woken up due to a signal */
++	if (count <= 0) count = random_read_wakeup_thresh; 
++
++	DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
++		  count,
++		  input_pool.entropy_count, random_write_wakeup_thresh);
++
++	return count;
++}
++EXPORT_SYMBOL(random_input_wait);
++
++
++#define EXTRACT_SIZE 10
++
+ /*********************************************************************
+  *
+  * Entropy extraction routines
+--- a/fs/fcntl.c
++++ b/fs/fcntl.c
+@@ -142,6 +142,7 @@ SYSCALL_DEFINE1(dup, unsigned int, filde
+ 	}
+ 	return ret;
+ }
++EXPORT_SYMBOL(sys_dup);
+ 
+ #define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | O_DIRECT | O_NOATIME)
+ 
+--- a/include/linux/miscdevice.h
++++ b/include/linux/miscdevice.h
+@@ -19,6 +19,7 @@
+ #define APOLLO_MOUSE_MINOR	7
+ #define PC110PAD_MINOR		9
+ /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
++#define CRYPTODEV_MINOR		70	/* /dev/crypto */
+ #define WATCHDOG_MINOR		130	/* Watchdog timer     */
+ #define TEMP_MINOR		131	/* Temperature Sensor */
+ #define RTC_MINOR		135
+--- a/include/linux/random.h
++++ b/include/linux/random.h
+@@ -34,6 +34,30 @@
+ /* Clear the entropy pool and associated counters.  (Superuser only.) */
+ #define RNDCLEARPOOL	_IO( 'R', 0x06 )
+ 
++#ifdef CONFIG_FIPS_RNG
++
++/* Size of seed value - equal to AES blocksize */
++#define AES_BLOCK_SIZE_BYTES	16
++#define SEED_SIZE_BYTES			AES_BLOCK_SIZE_BYTES
++/* Size of AES key */
++#define KEY_SIZE_BYTES		16
++
++/* ioctl() structure used by FIPS 140-2 Tests */
++struct rand_fips_test {
++	unsigned char key[KEY_SIZE_BYTES];			/* Input */
++	unsigned char datetime[SEED_SIZE_BYTES];	/* Input */
++	unsigned char seed[SEED_SIZE_BYTES];		/* Input */
++	unsigned char result[SEED_SIZE_BYTES];		/* Output */
++};
++
++/* FIPS 140-2 RNG Variable Seed Test. (Superuser only.) */
++#define RNDFIPSVST	_IOWR('R', 0x10, struct rand_fips_test)
++
++/* FIPS 140-2 RNG Monte Carlo Test. (Superuser only.) */
++#define RNDFIPSMCT	_IOWR('R', 0x11, struct rand_fips_test)
++
++#endif /* #ifdef CONFIG_FIPS_RNG */
++
+ struct rand_pool_info {
+ 	int	entropy_count;
+ 	int	buf_size;
+@@ -53,6 +77,10 @@ extern void add_input_randomness(unsigne
+ 				 unsigned int value);
+ extern void add_interrupt_randomness(int irq, int irq_flags);
+ 
++extern void random_input_words(__u32 *buf, size_t wordcount, int ent_count);
++extern int random_input_wait(void);
++#define HAS_RANDOM_INPUT_WAIT 1
++
+ extern void get_random_bytes(void *buf, int nbytes);
+ extern void get_random_bytes_arch(void *buf, int nbytes);
+ void generate_random_uuid(unsigned char uuid_out[16]);
+--- a/kernel/pid.c
++++ b/kernel/pid.c
+@@ -430,6 +430,7 @@ struct task_struct *find_task_by_vpid(pi
+ {
+ 	return find_task_by_pid_ns(vnr, current->nsproxy->pid_ns);
+ }
++EXPORT_SYMBOL(find_task_by_vpid);
+ 
+ struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
+ {
Index: target/linux/generic/patches-3.3/202-reduce_module_size.patch
===================================================================
--- target/linux/generic/patches-3.3/202-reduce_module_size.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/202-reduce_module_size.patch	(working copy)
@@ -5,7 +5,7 @@
  KBUILD_AFLAGS_MODULE  := -DMODULE
  KBUILD_CFLAGS_MODULE  := -DMODULE
 -KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
-+KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
++KBUILD_LDFLAGS_MODULE = -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
  
  # Read KERNELRELEASE from include/config/kernel.release (if it exists)
  KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
Index: target/linux/generic/patches-3.3/980-update_arm_machtypes.patch
===================================================================
--- target/linux/generic/patches-3.3/980-update_arm_machtypes.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/980-update_arm_machtypes.patch	(working copy)
@@ -3335,7 +3335,7 @@
  pluto			MACH_PLUTO		PLUTO			3869
  acfx100			MACH_ACFX100		ACFX100			3870
  msm8625_rumi3		MACH_MSM8625_RUMI3	MSM8625_RUMI3		3871
-@@ -1161,6 +3833,8 @@ valente_wx		MACH_VALENTE_WX		VALENTE_WX	
+@@ -1161,6 +3833,8 @@ valente_wx		MACH_VALENTE_WX		VALENTE_WX
  huangshans		MACH_HUANGSHANS		HUANGSHANS		3879
  bosphorus1		MACH_BOSPHORUS1		BOSPHORUS1		3880
  prima			MACH_PRIMA		PRIMA			3881
Index: target/linux/generic/patches-3.3/050-rng_git_backport.patch
===================================================================
--- target/linux/generic/patches-3.3/050-rng_git_backport.patch	(revision 0)
+++ target/linux/generic/patches-3.3/050-rng_git_backport.patch	(revision 0)
@@ -0,0 +1,783 @@
+--- a/drivers/char/random.c
++++ b/drivers/char/random.c
+@@ -125,21 +125,26 @@
+  * The current exported interfaces for gathering environmental noise
+  * from the devices are:
+  *
++ *	void add_device_randomness(const void *buf, unsigned int size);
+  * 	void add_input_randomness(unsigned int type, unsigned int code,
+  *                                unsigned int value);
+- * 	void add_interrupt_randomness(int irq);
++ *	void add_interrupt_randomness(int irq, int irq_flags);
+  * 	void add_disk_randomness(struct gendisk *disk);
+  *
+  * add_input_randomness() uses the input layer interrupt timing, as well as
+  * the event type information from the hardware.
+  *
+- * add_interrupt_randomness() uses the inter-interrupt timing as random
+- * inputs to the entropy pool.  Note that not all interrupts are good
+- * sources of randomness!  For example, the timer interrupts is not a
+- * good choice, because the periodicity of the interrupts is too
+- * regular, and hence predictable to an attacker.  Network Interface
+- * Controller interrupts are a better measure, since the timing of the
+- * NIC interrupts are more unpredictable.
++ * add_interrupt_randomness() uses the interrupt timing as random
++ * inputs to the entropy pool. Using the cycle counters and the irq source
++ * as inputs, it feeds the randomness roughly once a second.
++ *
++ * add_device_randomness() is for adding data to the random pool that
++ * is likely to differ between two devices (or possibly even per boot).
++ * This would be things like MAC addresses or serial numbers, or the
++ * read-out of the RTC. This does *not* add any actual entropy to the
++ * pool, but it initializes the pool to different values for devices
++ * that might otherwise be identical and have very little entropy
++ * available to them (particularly common in the embedded world).
+  *
+  * add_disk_randomness() uses what amounts to the seek time of block
+  * layer request events, on a per-disk_devt basis, as input to the
+@@ -248,6 +253,7 @@
+ #include <linux/percpu.h>
+ #include <linux/cryptohash.h>
+ #include <linux/fips.h>
++#include <linux/ptrace.h>
+ 
+ #ifdef CONFIG_GENERIC_HARDIRQS
+ # include <linux/irq.h>
+@@ -256,8 +262,12 @@
+ #include <asm/processor.h>
+ #include <asm/uaccess.h>
+ #include <asm/irq.h>
++#include <asm/irq_regs.h>
+ #include <asm/io.h>
+ 
++#define CREATE_TRACE_POINTS
++#include <trace/events/random.h>
++
+ /*
+  * Configuration information
+  */
+@@ -420,8 +430,10 @@ struct entropy_store {
+ 	/* read-write data: */
+ 	spinlock_t lock;
+ 	unsigned add_ptr;
++	unsigned input_rotate;
+ 	int entropy_count;
+-	int input_rotate;
++	int entropy_total;
++	unsigned int initialized:1;
+ 	__u8 last_data[EXTRACT_SIZE];
+ };
+ 
+@@ -454,6 +466,10 @@ static struct entropy_store nonblocking_
+ 	.pool = nonblocking_pool_data
+ };
+ 
++static __u32 const twist_table[8] = {
++	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
++	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
++
+ /*
+  * This function adds bytes into the entropy "pool".  It does not
+  * update the entropy estimate.  The caller should call
+@@ -464,29 +480,24 @@ static struct entropy_store nonblocking_
+  * it's cheap to do so and helps slightly in the expected case where
+  * the entropy is concentrated in the low-order bits.
+  */
+-static void mix_pool_bytes_extract(struct entropy_store *r, const void *in,
+-				   int nbytes, __u8 out[64])
++static void _mix_pool_bytes(struct entropy_store *r, const void *in,
++			    int nbytes, __u8 out[64])
+ {
+-	static __u32 const twist_table[8] = {
+-		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
+-		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
+ 	unsigned long i, j, tap1, tap2, tap3, tap4, tap5;
+ 	int input_rotate;
+ 	int wordmask = r->poolinfo->poolwords - 1;
+ 	const char *bytes = in;
+ 	__u32 w;
+-	unsigned long flags;
+ 
+-	/* Taps are constant, so we can load them without holding r->lock.  */
+ 	tap1 = r->poolinfo->tap1;
+ 	tap2 = r->poolinfo->tap2;
+ 	tap3 = r->poolinfo->tap3;
+ 	tap4 = r->poolinfo->tap4;
+ 	tap5 = r->poolinfo->tap5;
+ 
+-	spin_lock_irqsave(&r->lock, flags);
+-	input_rotate = r->input_rotate;
+-	i = r->add_ptr;
++	smp_rmb();
++	input_rotate = ACCESS_ONCE(r->input_rotate);
++	i = ACCESS_ONCE(r->add_ptr);
+ 
+ 	/* mix one byte at a time to simplify size handling and churn faster */
+ 	while (nbytes--) {
+@@ -513,19 +524,61 @@ static void mix_pool_bytes_extract(struc
+ 		input_rotate += i ? 7 : 14;
+ 	}
+ 
+-	r->input_rotate = input_rotate;
+-	r->add_ptr = i;
++	ACCESS_ONCE(r->input_rotate) = input_rotate;
++	ACCESS_ONCE(r->add_ptr) = i;
++	smp_wmb();
+ 
+ 	if (out)
+ 		for (j = 0; j < 16; j++)
+ 			((__u32 *)out)[j] = r->pool[(i - j) & wordmask];
++}
++
++static void __mix_pool_bytes(struct entropy_store *r, const void *in,
++			     int nbytes, __u8 out[64])
++{
++	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
++	_mix_pool_bytes(r, in, nbytes, out);
++}
+ 
++static void mix_pool_bytes(struct entropy_store *r, const void *in,
++			   int nbytes, __u8 out[64])
++{
++	unsigned long flags;
++
++	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
++	spin_lock_irqsave(&r->lock, flags);
++	_mix_pool_bytes(r, in, nbytes, out);
+ 	spin_unlock_irqrestore(&r->lock, flags);
+ }
+ 
+-static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
++struct fast_pool {
++	__u32		pool[4];
++	unsigned long	last;
++	unsigned short	count;
++	unsigned char	rotate;
++	unsigned char	last_timer_intr;
++};
++
++/*
++ * This is a fast mixing routine used by the interrupt randomness
++ * collector.  It's hardcoded for an 128 bit pool and assumes that any
++ * locks that might be needed are taken by the caller.
++ */
++static void fast_mix(struct fast_pool *f, const void *in, int nbytes)
+ {
+-       mix_pool_bytes_extract(r, in, bytes, NULL);
++	const char	*bytes = in;
++	__u32		w;
++	unsigned	i = f->count;
++	unsigned	input_rotate = f->rotate;
++
++	while (nbytes--) {
++		w = rol32(*bytes++, input_rotate & 31) ^ f->pool[i & 3] ^
++			f->pool[(i + 1) & 3];
++		f->pool[i & 3] = (w >> 3) ^ twist_table[w & 7];
++		input_rotate += (i++ & 3) ? 7 : 14;
++	}
++	f->count = i;
++	f->rotate = input_rotate;
+ }
+ 
+ /*
+@@ -533,30 +586,38 @@ static void mix_pool_bytes(struct entrop
+  */
+ static void credit_entropy_bits(struct entropy_store *r, int nbits)
+ {
+-	unsigned long flags;
+-	int entropy_count;
++	int entropy_count, orig;
+ 
+ 	if (!nbits)
+ 		return;
+ 
+-	spin_lock_irqsave(&r->lock, flags);
+-
+ 	DEBUG_ENT("added %d entropy credits to %s\n", nbits, r->name);
+-	entropy_count = r->entropy_count;
++retry:
++	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+ 	entropy_count += nbits;
++
+ 	if (entropy_count < 0) {
+ 		DEBUG_ENT("negative entropy/overflow\n");
+ 		entropy_count = 0;
+ 	} else if (entropy_count > r->poolinfo->POOLBITS)
+ 		entropy_count = r->poolinfo->POOLBITS;
+-	r->entropy_count = entropy_count;
++	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
++		goto retry;
++
++	if (!r->initialized && nbits > 0) {
++		r->entropy_total += nbits;
++		if (r->entropy_total > 128)
++			r->initialized = 1;
++	}
++
++	trace_credit_entropy_bits(r->name, nbits, entropy_count,
++				  r->entropy_total, _RET_IP_);
+ 
+ 	/* should we wake readers? */
+ 	if (r == &input_pool && entropy_count >= random_read_wakeup_thresh) {
+ 		wake_up_interruptible(&random_read_wait);
+ 		kill_fasync(&fasync, SIGIO, POLL_IN);
+ 	}
+-	spin_unlock_irqrestore(&r->lock, flags);
+ }
+ 
+ /*********************************************************************
+@@ -609,6 +670,25 @@ static void set_timer_rand_state(unsigne
+ }
+ #endif
+ 
++/*
++ * Add device- or boot-specific data to the input and nonblocking
++ * pools to help initialize them to unique values.
++ *
++ * None of this adds any entropy, it is meant to avoid the
++ * problem of the nonblocking pool having similar initial state
++ * across largely identical devices.
++ */
++void add_device_randomness(const void *buf, unsigned int size)
++{
++	unsigned long time = get_cycles() ^ jiffies;
++
++	mix_pool_bytes(&input_pool, buf, size, NULL);
++	mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
++	mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
++	mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
++}
++EXPORT_SYMBOL(add_device_randomness);
++
+ static struct timer_rand_state input_timer_state;
+ 
+ /*
+@@ -637,13 +717,9 @@ static void add_timer_randomness(struct
+ 		goto out;
+ 
+ 	sample.jiffies = jiffies;
+-
+-	/* Use arch random value, fall back to cycles */
+-	if (!arch_get_random_int(&sample.cycles))
+-		sample.cycles = get_cycles();
+-
++	sample.cycles = get_cycles();
+ 	sample.num = num;
+-	mix_pool_bytes(&input_pool, &sample, sizeof(sample));
++	mix_pool_bytes(&input_pool, &sample, sizeof(sample), NULL);
+ 
+ 	/*
+ 	 * Calculate number of bits of randomness we probably added.
+@@ -700,17 +776,48 @@ void add_input_randomness(unsigned int t
+ }
+ EXPORT_SYMBOL_GPL(add_input_randomness);
+ 
+-void add_interrupt_randomness(int irq)
++static DEFINE_PER_CPU(struct fast_pool, irq_randomness);
++
++void add_interrupt_randomness(int irq, int irq_flags)
+ {
+-	struct timer_rand_state *state;
++	struct entropy_store	*r;
++	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
++	struct pt_regs		*regs = get_irq_regs();
++	unsigned long		now = jiffies;
++	__u32			input[4], cycles = get_cycles();
++
++	input[0] = cycles ^ jiffies;
++	input[1] = irq;
++	if (regs) {
++		__u64 ip = instruction_pointer(regs);
++		input[2] = ip;
++		input[3] = ip >> 32;
++	}
+ 
+-	state = get_timer_rand_state(irq);
++	fast_mix(fast_pool, input, sizeof(input));
+ 
+-	if (state == NULL)
++	if ((fast_pool->count & 1023) &&
++	    !time_after(now, fast_pool->last + HZ))
+ 		return;
+ 
+-	DEBUG_ENT("irq event %d\n", irq);
+-	add_timer_randomness(state, 0x100 + irq);
++	fast_pool->last = now;
++
++	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
++	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
++	/*
++	 * If we don't have a valid cycle counter, and we see
++	 * back-to-back timer interrupts, then skip giving credit for
++	 * any entropy.
++	 */
++	if (cycles == 0) {
++		if (irq_flags & __IRQF_TIMER) {
++			if (fast_pool->last_timer_intr)
++				return;
++			fast_pool->last_timer_intr = 1;
++		} else
++			fast_pool->last_timer_intr = 0;
++	}
++	credit_entropy_bits(r, 1);
+ }
+ 
+ #ifdef CONFIG_BLOCK
+@@ -742,7 +849,11 @@ static ssize_t extract_entropy(struct en
+  */
+ static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
+ {
+-	__u32 tmp[OUTPUT_POOL_WORDS];
++	union {
++		__u32	tmp[OUTPUT_POOL_WORDS];
++		long	hwrand[4];
++	} u;
++	int	i;
+ 
+ 	if (r->pull && r->entropy_count < nbytes * 8 &&
+ 	    r->entropy_count < r->poolinfo->POOLBITS) {
+@@ -753,17 +864,22 @@ static void xfer_secondary_pool(struct e
+ 		/* pull at least as many as BYTES as wakeup BITS */
+ 		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
+ 		/* but never more than the buffer size */
+-		bytes = min_t(int, bytes, sizeof(tmp));
++		bytes = min_t(int, bytes, sizeof(u.tmp));
+ 
+ 		DEBUG_ENT("going to reseed %s with %d bits "
+ 			  "(%d of %d requested)\n",
+ 			  r->name, bytes * 8, nbytes * 8, r->entropy_count);
+ 
+-		bytes = extract_entropy(r->pull, tmp, bytes,
++		bytes = extract_entropy(r->pull, u.tmp, bytes,
+ 					random_read_wakeup_thresh / 8, rsvd);
+-		mix_pool_bytes(r, tmp, bytes);
++		mix_pool_bytes(r, u.tmp, bytes, NULL);
+ 		credit_entropy_bits(r, bytes*8);
+ 	}
++	for (i = 0; i < 4; i++)
++		if (arch_get_random_long(&u.hwrand[i]))
++			break;
++	if (i)
++		mix_pool_bytes(r, &u.hwrand, i * sizeof(u.hwrand[0]), 0);
+ }
+ 
+ /*
+@@ -822,9 +938,11 @@ static void extract_buf(struct entropy_s
+ 	int i;
+ 	__u32 hash[5], workspace[SHA_WORKSPACE_WORDS];
+ 	__u8 extract[64];
++	unsigned long flags;
+ 
+ 	/* Generate a hash across the pool, 16 words (512 bits) at a time */
+ 	sha_init(hash);
++	spin_lock_irqsave(&r->lock, flags);
+ 	for (i = 0; i < r->poolinfo->poolwords; i += 16)
+ 		sha_transform(hash, (__u8 *)(r->pool + i), workspace);
+ 
+@@ -837,7 +955,8 @@ static void extract_buf(struct entropy_s
+ 	 * brute-forcing the feedback as hard as brute-forcing the
+ 	 * hash.
+ 	 */
+-	mix_pool_bytes_extract(r, hash, sizeof(hash), extract);
++	__mix_pool_bytes(r, hash, sizeof(hash), extract);
++	spin_unlock_irqrestore(&r->lock, flags);
+ 
+ 	/*
+ 	 * To avoid duplicates, we atomically extract a portion of the
+@@ -860,12 +979,12 @@ static void extract_buf(struct entropy_s
+ }
+ 
+ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
+-			       size_t nbytes, int min, int reserved)
++				 size_t nbytes, int min, int reserved)
+ {
+ 	ssize_t ret = 0, i;
+ 	__u8 tmp[EXTRACT_SIZE];
+-	unsigned long flags;
+ 
++	trace_extract_entropy(r->name, nbytes, r->entropy_count, _RET_IP_);
+ 	xfer_secondary_pool(r, nbytes);
+ 	nbytes = account(r, nbytes, min, reserved);
+ 
+@@ -873,6 +992,8 @@ static ssize_t extract_entropy(struct en
+ 		extract_buf(r, tmp);
+ 
+ 		if (fips_enabled) {
++			unsigned long flags;
++
+ 			spin_lock_irqsave(&r->lock, flags);
+ 			if (!memcmp(tmp, r->last_data, EXTRACT_SIZE))
+ 				panic("Hardware RNG duplicated output!\n");
+@@ -898,6 +1019,7 @@ static ssize_t extract_entropy_user(stru
+ 	ssize_t ret = 0, i;
+ 	__u8 tmp[EXTRACT_SIZE];
+ 
++	trace_extract_entropy_user(r->name, nbytes, r->entropy_count, _RET_IP_);
+ 	xfer_secondary_pool(r, nbytes);
+ 	nbytes = account(r, nbytes, 0, 0);
+ 
+@@ -931,17 +1053,35 @@ static ssize_t extract_entropy_user(stru
+ 
+ /*
+  * This function is the exported kernel interface.  It returns some
+- * number of good random numbers, suitable for seeding TCP sequence
+- * numbers, etc.
++ * number of good random numbers, suitable for key generation, seeding
++ * TCP sequence numbers, etc.  It does not use the hw random number
++ * generator, if available; use get_random_bytes_arch() for that.
+  */
+ void get_random_bytes(void *buf, int nbytes)
+ {
++	extract_entropy(&nonblocking_pool, buf, nbytes, 0, 0);
++}
++EXPORT_SYMBOL(get_random_bytes);
++
++/*
++ * This function will use the architecture-specific hardware random
++ * number generator if it is available.  The arch-specific hw RNG will
++ * almost certainly be faster than what we can do in software, but it
++ * is impossible to verify that it is implemented securely (as
++ * opposed, to, say, the AES encryption of a sequence number using a
++ * key known by the NSA).  So it's useful if we need the speed, but
++ * only if we're willing to trust the hardware manufacturer not to
++ * have put in a back door.
++ */
++void get_random_bytes_arch(void *buf, int nbytes)
++{
+ 	char *p = buf;
+ 
++	trace_get_random_bytes(nbytes, _RET_IP_);
+ 	while (nbytes) {
+ 		unsigned long v;
+ 		int chunk = min(nbytes, (int)sizeof(unsigned long));
+-		
++
+ 		if (!arch_get_random_long(&v))
+ 			break;
+ 		
+@@ -950,9 +1090,11 @@ void get_random_bytes(void *buf, int nby
+ 		nbytes -= chunk;
+ 	}
+ 
+-	extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
++	if (nbytes)
++		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
+ }
+-EXPORT_SYMBOL(get_random_bytes);
++EXPORT_SYMBOL(get_random_bytes_arch);
++
+ 
+ /*
+  * init_std_data - initialize pool with system data
+@@ -966,21 +1108,18 @@ EXPORT_SYMBOL(get_random_bytes);
+ static void init_std_data(struct entropy_store *r)
+ {
+ 	int i;
+-	ktime_t now;
+-	unsigned long flags;
++	ktime_t now = ktime_get_real();
++	unsigned long rv;
+ 
+-	spin_lock_irqsave(&r->lock, flags);
+ 	r->entropy_count = 0;
+-	spin_unlock_irqrestore(&r->lock, flags);
+-
+-	now = ktime_get_real();
+-	mix_pool_bytes(r, &now, sizeof(now));
+-	for (i = r->poolinfo->POOLBYTES; i > 0; i -= sizeof flags) {
+-		if (!arch_get_random_long(&flags))
++	r->entropy_total = 0;
++	mix_pool_bytes(r, &now, sizeof(now), NULL);
++	for (i = r->poolinfo->POOLBYTES; i > 0; i -= sizeof(rv)) {
++		if (!arch_get_random_long(&rv))
+ 			break;
+-		mix_pool_bytes(r, &flags, sizeof(flags));
++		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
+ 	}
+-	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
++	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
+ }
+ 
+ static int rand_initialize(void)
+@@ -1117,7 +1256,7 @@ write_pool(struct entropy_store *r, cons
+ 		count -= bytes;
+ 		p += bytes;
+ 
+-		mix_pool_bytes(r, buf, bytes);
++		mix_pool_bytes(r, buf, bytes, NULL);
+ 		cond_resched();
+ 	}
+ 
+@@ -1274,6 +1413,7 @@ static int proc_do_uuid(ctl_table *table
+ }
+ 
+ static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
++extern ctl_table random_table[];
+ ctl_table random_table[] = {
+ 	{
+ 		.procname	= "poolsize",
+@@ -1339,7 +1479,7 @@ late_initcall(random_int_secret_init);
+  * value is not cryptographically secure but for several uses the cost of
+  * depleting entropy is too high
+  */
+-DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
++static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
+ unsigned int get_random_int(void)
+ {
+ 	__u32 *hash;
+--- a/drivers/mfd/ab3100-core.c
++++ b/drivers/mfd/ab3100-core.c
+@@ -409,8 +409,6 @@ static irqreturn_t ab3100_irq_handler(in
+ 	u32 fatevent;
+ 	int err;
+ 
+-	add_interrupt_randomness(irq);
+-
+ 	err = ab3100_get_register_page_interruptible(ab3100, AB3100_EVENTA1,
+ 				       event_regs, 3);
+ 	if (err)
+--- a/drivers/usb/core/hub.c
++++ b/drivers/usb/core/hub.c
+@@ -24,6 +24,7 @@
+ #include <linux/kthread.h>
+ #include <linux/mutex.h>
+ #include <linux/freezer.h>
++#include <linux/random.h>
+ 
+ #include <asm/uaccess.h>
+ #include <asm/byteorder.h>
+@@ -1896,6 +1897,14 @@ int usb_new_device(struct usb_device *ud
+ 	/* Tell the world! */
+ 	announce_device(udev);
+ 
++	if (udev->serial)
++		add_device_randomness(udev->serial, strlen(udev->serial));
++	if (udev->product)
++		add_device_randomness(udev->product, strlen(udev->product));
++	if (udev->manufacturer)
++		add_device_randomness(udev->manufacturer,
++				      strlen(udev->manufacturer));
++
+ 	device_enable_async_suspend(&udev->dev);
+ 	/* Register the device.  The device driver is responsible
+ 	 * for configuring the device and invoking the add-device
+--- a/include/linux/random.h
++++ b/include/linux/random.h
+@@ -50,11 +50,13 @@ struct rnd_state {
+ 
+ extern void rand_initialize_irq(int irq);
+ 
++extern void add_device_randomness(const void *, unsigned int);
+ extern void add_input_randomness(unsigned int type, unsigned int code,
+ 				 unsigned int value);
+-extern void add_interrupt_randomness(int irq);
++extern void add_interrupt_randomness(int irq, int irq_flags);
+ 
+ extern void get_random_bytes(void *buf, int nbytes);
++extern void get_random_bytes_arch(void *buf, int nbytes);
+ void generate_random_uuid(unsigned char uuid_out[16]);
+ 
+ #ifndef MODULE
+--- /dev/null
++++ b/include/trace/events/random.h
+@@ -0,0 +1,134 @@
++#undef TRACE_SYSTEM
++#define TRACE_SYSTEM random
++
++#if !defined(_TRACE_RANDOM_H) || defined(TRACE_HEADER_MULTI_READ)
++#define _TRACE_RANDOM_H
++
++#include <linux/writeback.h>
++#include <linux/tracepoint.h>
++
++DECLARE_EVENT_CLASS(random__mix_pool_bytes,
++	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
++
++	TP_ARGS(pool_name, bytes, IP),
++
++	TP_STRUCT__entry(
++		__field( const char *,	pool_name		)
++		__field(	  int,	bytes			)
++		__field(unsigned long,	IP			)
++	),
++
++	TP_fast_assign(
++		__entry->pool_name	= pool_name;
++		__entry->bytes		= bytes;
++		__entry->IP		= IP;
++	),
++
++	TP_printk("%s pool: bytes %d caller %pF",
++		  __entry->pool_name, __entry->bytes, (void *)__entry->IP)
++);
++
++DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes,
++	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
++
++	TP_ARGS(pool_name, bytes, IP)
++);
++
++DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes_nolock,
++	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
++
++	TP_ARGS(pool_name, bytes, IP)
++);
++
++TRACE_EVENT(credit_entropy_bits,
++	TP_PROTO(const char *pool_name, int bits, int entropy_count,
++		 int entropy_total, unsigned long IP),
++
++	TP_ARGS(pool_name, bits, entropy_count, entropy_total, IP),
++
++	TP_STRUCT__entry(
++		__field( const char *,	pool_name		)
++		__field(	  int,	bits			)
++		__field(	  int,	entropy_count		)
++		__field(	  int,	entropy_total		)
++		__field(unsigned long,	IP			)
++	),
++
++	TP_fast_assign(
++		__entry->pool_name	= pool_name;
++		__entry->bits		= bits;
++		__entry->entropy_count	= entropy_count;
++		__entry->entropy_total	= entropy_total;
++		__entry->IP		= IP;
++	),
++
++	TP_printk("%s pool: bits %d entropy_count %d entropy_total %d "
++		  "caller %pF", __entry->pool_name, __entry->bits,
++		  __entry->entropy_count, __entry->entropy_total,
++		  (void *)__entry->IP)
++);
++
++TRACE_EVENT(get_random_bytes,
++	TP_PROTO(int nbytes, unsigned long IP),
++
++	TP_ARGS(nbytes, IP),
++
++	TP_STRUCT__entry(
++		__field(	  int,	nbytes			)
++		__field(unsigned long,	IP			)
++	),
++
++	TP_fast_assign(
++		__entry->nbytes		= nbytes;
++		__entry->IP		= IP;
++	),
++
++	TP_printk("nbytes %d caller %pF", __entry->nbytes, (void *)__entry->IP)
++);
++
++DECLARE_EVENT_CLASS(random__extract_entropy,
++	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
++		 unsigned long IP),
++
++	TP_ARGS(pool_name, nbytes, entropy_count, IP),
++
++	TP_STRUCT__entry(
++		__field( const char *,	pool_name		)
++		__field(	  int,	nbytes			)
++		__field(	  int,	entropy_count		)
++		__field(unsigned long,	IP			)
++	),
++
++	TP_fast_assign(
++		__entry->pool_name	= pool_name;
++		__entry->nbytes		= nbytes;
++		__entry->entropy_count	= entropy_count;
++		__entry->IP		= IP;
++	),
++
++	TP_printk("%s pool: nbytes %d entropy_count %d caller %pF",
++		  __entry->pool_name, __entry->nbytes, __entry->entropy_count,
++		  (void *)__entry->IP)
++);
++
++
++DEFINE_EVENT(random__extract_entropy, extract_entropy,
++	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
++		 unsigned long IP),
++
++	TP_ARGS(pool_name, nbytes, entropy_count, IP)
++);
++
++DEFINE_EVENT(random__extract_entropy, extract_entropy_user,
++	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
++		 unsigned long IP),
++
++	TP_ARGS(pool_name, nbytes, entropy_count, IP)
++);
++
++
++
++#endif /* _TRACE_RANDOM_H */
++
++/* This part must be outside protection */
++#include <trace/define_trace.h>
+--- a/kernel/irq/handle.c
++++ b/kernel/irq/handle.c
+@@ -117,7 +117,7 @@ irqreturn_t
+ handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)
+ {
+ 	irqreturn_t retval = IRQ_NONE;
+-	unsigned int random = 0, irq = desc->irq_data.irq;
++	unsigned int flags = 0, irq = desc->irq_data.irq;
+ 
+ 	do {
+ 		irqreturn_t res;
+@@ -145,7 +145,7 @@ handle_irq_event_percpu(struct irq_desc
+ 
+ 			/* Fall through to add to randomness */
+ 		case IRQ_HANDLED:
+-			random |= action->flags;
++			flags |= action->flags;
+ 			break;
+ 
+ 		default:
+@@ -156,8 +156,7 @@ handle_irq_event_percpu(struct irq_desc
+ 		action = action->next;
+ 	} while (action);
+ 
+-	if (random & IRQF_SAMPLE_RANDOM)
+-		add_interrupt_randomness(irq);
++	add_interrupt_randomness(irq, flags);
+ 
+ 	if (!noirqdebug)
+ 		note_interrupt(irq, desc, retval);
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -1176,6 +1176,7 @@ static int __dev_open(struct net_device
+ 		net_dmaengine_get();
+ 		dev_set_rx_mode(dev);
+ 		dev_activate(dev);
++		add_device_randomness(dev->dev_addr, dev->addr_len);
+ 	}
+ 
+ 	return ret;
+@@ -4823,6 +4824,7 @@ int dev_set_mac_address(struct net_devic
+ 	err = ops->ndo_set_mac_address(dev, sa);
+ 	if (!err)
+ 		call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
++	add_device_randomness(dev->dev_addr, dev->addr_len);
+ 	return err;
+ }
+ EXPORT_SYMBOL(dev_set_mac_address);
+@@ -5602,6 +5604,7 @@ int register_netdevice(struct net_device
+ 	dev_init_scheduler(dev);
+ 	dev_hold(dev);
+ 	list_netdevice(dev);
++	add_device_randomness(dev->dev_addr, dev->addr_len);
+ 
+ 	/* Notify protocols, that a new device appeared. */
+ 	ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);
+--- a/net/core/rtnetlink.c
++++ b/net/core/rtnetlink.c
+@@ -1371,6 +1371,7 @@ static int do_setlink(struct net_device
+ 			goto errout;
+ 		send_addr_notify = 1;
+ 		modified = 1;
++		add_device_randomness(dev->dev_addr, dev->addr_len);
+ 	}
+ 
+ 	if (tb[IFLA_MTU]) {
Index: target/linux/generic/patches-3.3/252-mv_cesa_depends.patch
===================================================================
--- target/linux/generic/patches-3.3/252-mv_cesa_depends.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/252-mv_cesa_depends.patch	(working copy)
@@ -6,5 +6,5 @@
  	select CRYPTO_AES
 +	select CRYPTO_HASH2
  	select CRYPTO_BLKCIPHER2
+ 	select CRYPTO_HASH
  	help
- 	  This driver allows you to utilize the Cryptographic Engines and
Index: target/linux/generic/patches-3.3/830-ledtrig_morse.patch
===================================================================
--- target/linux/generic/patches-3.3/830-ledtrig_morse.patch	(revision 31639)
+++ target/linux/generic/patches-3.3/830-ledtrig_morse.patch	(working copy)
@@ -11,7 +11,7 @@
  endif # NEW_LEDS
 --- a/drivers/leds/Makefile
 +++ b/drivers/leds/Makefile
-@@ -57,3 +57,4 @@ obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= 
+@@ -57,3 +57,4 @@ obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+=
  obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
  obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
  obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
Index: target/linux/generic/patches-3.3/048-spi-Dont-call-prepare-unprepare-transfer-if-not-popu.patch
===================================================================
--- target/linux/generic/patches-3.3/048-spi-Dont-call-prepare-unprepare-transfer-if-not-popu.patch	(revision 0)
+++ target/linux/generic/patches-3.3/048-spi-Dont-call-prepare-unprepare-transfer-if-not-popu.patch	(revision 0)
@@ -0,0 +1,39 @@
+From 7dfd2bd70228d1f8d468d58cb3d12ecd618479ed Mon Sep 17 00:00:00 2001
+From: Shubhrajyoti D <shubhrajyoti@ti.com>
+Date: Thu, 10 May 2012 19:20:41 +0530
+Subject: [PATCH] spi: Dont call prepare/unprepare transfer if not populated
+
+Currently the prepare/unprepare transfer are called unconditionally.
+The assumption is that every driver using the spi core queue infrastructure
+has to populate the prepare and unprepare functions. This encourages
+drivers to populate empty functions to prevent crashing.
+This patch prevents the call to prepare/unprepare if not populated.
+
+Signed-off-by: Shubhrajyoti D <shubhrajyoti@ti.com>
+Acked-by: Linus Walleij <linus.walleij@linaro.org>
+[grant.likely: fix whitespace defect]
+Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
+---
+ drivers/spi/spi.c |    4 ++--
+ 1 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/spi/spi.c
++++ b/drivers/spi/spi.c
+@@ -530,7 +530,7 @@ static void spi_pump_messages(struct kth
+ 	/* Lock queue and check for queue work */
+ 	spin_lock_irqsave(&master->queue_lock, flags);
+ 	if (list_empty(&master->queue) || !master->running) {
+-		if (master->busy) {
++		if (master->busy && master->unprepare_transfer_hardware) {
+ 			ret = master->unprepare_transfer_hardware(master);
+ 			if (ret) {
+ 				dev_err(&master->dev,
+@@ -559,7 +559,7 @@ static void spi_pump_messages(struct kth
+ 		master->busy = true;
+ 	spin_unlock_irqrestore(&master->queue_lock, flags);
+ 
+-	if (!was_busy) {
++	if (!was_busy && master->prepare_transfer_hardware) {
+ 		ret = master->prepare_transfer_hardware(master);
+ 		if (ret) {
+ 			dev_err(&master->dev,
Index: target/linux/generic/patches-3.3/041-codel-use-Newton-method-instead-of-sqrt-and-divides.patch
===================================================================
--- target/linux/generic/patches-3.3/041-codel-use-Newton-method-instead-of-sqrt-and-divides.patch	(revision 0)
+++ target/linux/generic/patches-3.3/041-codel-use-Newton-method-instead-of-sqrt-and-divides.patch	(revision 0)
@@ -0,0 +1,185 @@
+From 4a8056dfeef49b306ad6af24a5563d7d6867aae0 Mon Sep 17 00:00:00 2001
+From: Eric Dumazet <edumazet@google.com>
+Date: Sat, 12 May 2012 03:32:13 +0000
+Subject: [PATCH] codel: use Newton method instead of sqrt() and divides
+
+commit 536edd67109df5e0cdb2c4ee759e9bade7976367 upstream.
+
+As Van pointed out, interval/sqrt(count) can be implemented using
+multiplies only.
+
+http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Iterative_methods_for_reciprocal_square_roots
+
+This patch implements the Newton method and reciprocal divide.
+
+Total cost is 15 cycles instead of 120 on my Corei5 machine (64bit
+kernel).
+
+There is a small 'error' for count values < 5, but we don't really care.
+
+I reuse a hole in struct codel_vars :
+ - pack the dropping boolean into one bit
+ - use 31bit to store the reciprocal value of sqrt(count).
+
+Suggested-by: Van Jacobson <van@pollere.net>
+Signed-off-by: Eric Dumazet <edumazet@google.com>
+Cc: Dave Taht <dave.taht@bufferbloat.net>
+Cc: Kathleen Nichols <nichols@pollere.com>
+Cc: Tom Herbert <therbert@google.com>
+Cc: Matt Mathis <mattmathis@google.com>
+Cc: Yuchung Cheng <ycheng@google.com>
+Cc: Nandita Dukkipati <nanditad@google.com>
+Cc: Stephen Hemminger <shemminger@vyatta.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/codel.h |   68 ++++++++++++++++++++++++++++-----------------------
+ 1 file changed, 37 insertions(+), 31 deletions(-)
+
+--- a/include/net/codel.h
++++ b/include/net/codel.h
+@@ -46,6 +46,7 @@
+ #include <linux/skbuff.h>
+ #include <net/pkt_sched.h>
+ #include <net/inet_ecn.h>
++#include <linux/reciprocal_div.h>
+ 
+ /* Controlling Queue Delay (CoDel) algorithm
+  * =========================================
+@@ -123,6 +124,7 @@ struct codel_params {
+  *			entered dropping state
+  * @lastcount:		count at entry to dropping state
+  * @dropping:		set to true if in dropping state
++ * @rec_inv_sqrt:	reciprocal value of sqrt(count) >> 1
+  * @first_above_time:	when we went (or will go) continuously above target
+  *			for interval
+  * @drop_next:		time to drop next packet, or when we dropped last
+@@ -131,7 +133,8 @@ struct codel_params {
+ struct codel_vars {
+ 	u32		count;
+ 	u32		lastcount;
+-	bool		dropping;
++	bool		dropping:1;
++	u32		rec_inv_sqrt:31;
+ 	codel_time_t	first_above_time;
+ 	codel_time_t	drop_next;
+ 	codel_time_t	ldelay;
+@@ -158,11 +161,7 @@ static void codel_params_init(struct cod
+ 
+ static void codel_vars_init(struct codel_vars *vars)
+ {
+-	vars->drop_next = 0;
+-	vars->first_above_time = 0;
+-	vars->dropping = false; /* exit dropping state */
+-	vars->count = 0;
+-	vars->lastcount = 0;
++	memset(vars, 0, sizeof(*vars));
+ }
+ 
+ static void codel_stats_init(struct codel_stats *stats)
+@@ -170,38 +169,37 @@ static void codel_stats_init(struct code
+ 	stats->maxpacket = 256;
+ }
+ 
+-/* return interval/sqrt(x) with good precision
+- * relies on int_sqrt(unsigned long x) kernel implementation
++/*
++ * http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Iterative_methods_for_reciprocal_square_roots
++ * new_invsqrt = (invsqrt / 2) * (3 - count * invsqrt^2)
++ *
++ * Here, invsqrt is a fixed point number (< 1.0), 31bit mantissa)
+  */
+-static u32 codel_inv_sqrt(u32 _interval, u32 _x)
++static void codel_Newton_step(struct codel_vars *vars)
+ {
+-	u64 interval = _interval;
+-	unsigned long x = _x;
+-
+-	/* Scale operands for max precision */
++	u32 invsqrt = vars->rec_inv_sqrt;
++	u32 invsqrt2 = ((u64)invsqrt * invsqrt) >> 31;
++	u64 val = (3LL << 31) - ((u64)vars->count * invsqrt2);
+ 
+-#if BITS_PER_LONG == 64
+-	x <<= 32; /* On 64bit arches, we can prescale x by 32bits */
+-	interval <<= 16;
+-#endif
++	val = (val * invsqrt) >> 32;
+ 
+-	while (x < (1UL << (BITS_PER_LONG - 2))) {
+-		x <<= 2;
+-		interval <<= 1;
+-	}
+-	do_div(interval, int_sqrt(x));
+-	return (u32)interval;
++	vars->rec_inv_sqrt = val;
+ }
+ 
++/*
++ * CoDel control_law is t + interval/sqrt(count)
++ * We maintain in rec_inv_sqrt the reciprocal value of sqrt(count) to avoid
++ * both sqrt() and divide operation.
++ */
+ static codel_time_t codel_control_law(codel_time_t t,
+ 				      codel_time_t interval,
+-				      u32 count)
++				      u32 rec_inv_sqrt)
+ {
+-	return t + codel_inv_sqrt(interval, count);
++	return t + reciprocal_divide(interval, rec_inv_sqrt << 1);
+ }
+ 
+ 
+-static bool codel_should_drop(struct sk_buff *skb,
++static bool codel_should_drop(const struct sk_buff *skb,
+ 			      unsigned int *backlog,
+ 			      struct codel_vars *vars,
+ 			      struct codel_params *params,
+@@ -274,14 +272,16 @@ static struct sk_buff *codel_dequeue(str
+ 			 */
+ 			while (vars->dropping &&
+ 			       codel_time_after_eq(now, vars->drop_next)) {
+-				if (++vars->count == 0) /* avoid zero divides */
+-					vars->count = ~0U;
++				vars->count++; /* dont care of possible wrap
++						* since there is no more divide
++						*/
++				codel_Newton_step(vars);
+ 				if (params->ecn && INET_ECN_set_ce(skb)) {
+ 					stats->ecn_mark++;
+ 					vars->drop_next =
+ 						codel_control_law(vars->drop_next,
+ 								  params->interval,
+-								  vars->count);
++								  vars->rec_inv_sqrt);
+ 					goto end;
+ 				}
+ 				qdisc_drop(skb, sch);
+@@ -296,7 +296,7 @@ static struct sk_buff *codel_dequeue(str
+ 					vars->drop_next =
+ 						codel_control_law(vars->drop_next,
+ 								  params->interval,
+-								  vars->count);
++								  vars->rec_inv_sqrt);
+ 				}
+ 			}
+ 		}
+@@ -319,12 +319,18 @@ static struct sk_buff *codel_dequeue(str
+ 		if (codel_time_before(now - vars->drop_next,
+ 				      16 * params->interval)) {
+ 			vars->count = (vars->count - vars->lastcount) | 1;
++			/* we dont care if rec_inv_sqrt approximation
++			 * is not very precise :
++			 * Next Newton steps will correct it quadratically.
++			 */
++			codel_Newton_step(vars);
+ 		} else {
+ 			vars->count = 1;
++			vars->rec_inv_sqrt = 0x7fffffff;
+ 		}
+ 		vars->lastcount = vars->count;
+ 		vars->drop_next = codel_control_law(now, params->interval,
+-						    vars->count);
++						    vars->rec_inv_sqrt);
+ 	}
+ end:
+ 	return skb;
Index: target/linux/generic/patches-3.3/047-spi_message_queue.patch
===================================================================
--- target/linux/generic/patches-3.3/047-spi_message_queue.patch	(revision 0)
+++ target/linux/generic/patches-3.3/047-spi_message_queue.patch	(revision 0)
@@ -0,0 +1,603 @@
+commit ffbbdd21329f3e15eeca6df2d4bc11c04d9d91c0
+Author: Linus Walleij <linus.walleij@linaro.org>
+Date:   Wed Feb 22 10:05:38 2012 +0100
+
+    spi: create a message queueing infrastructure
+    
+    This rips the message queue in the PL022 driver out and pushes
+    it into (optional) common infrastructure. Drivers that want to
+    use the message pumping thread will need to define the new
+    per-messags transfer methods and leave the deprecated transfer()
+    method as NULL.
+    
+    Most of the design is described in the documentation changes that
+    are included in this patch.
+    
+    Since there is a queue that need to be stopped when the system
+    is suspending/resuming, two new calls are implemented for the
+    device drivers to call in their suspend()/resume() functions:
+    spi_master_suspend() and spi_master_resume().
+    
+    ChangeLog v1->v2:
+    - Remove Kconfig entry and do not make the queue support optional
+      at all, instead be more agressive and have it as part of the
+      compulsory infrastructure.
+    - If the .transfer() method is implemented, delete print a small
+      deprecation notice and do not start the transfer pump.
+    - Fix a bitrotted comment.
+    ChangeLog v2->v3:
+    - Fix up a problematic sequence courtesy of Chris Blair.
+    - Stop rather than destroy the queue on suspend() courtesy of
+      Chris Blair.
+    
+    Signed-off-by: Chris Blair <chris.blair@stericsson.com>
+    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+    Tested-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
+    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
+    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
+
+[Florian: dropped the changes on drivers/spi/spi-pl022.c, removed
+the dev_info() about unqueued drivers still using the master function]
+
+--- a/Documentation/spi/spi-summary
++++ b/Documentation/spi/spi-summary
+@@ -1,7 +1,7 @@
+ Overview of Linux kernel SPI support
+ ====================================
+ 
+-21-May-2007
++02-Feb-2012
+ 
+ What is SPI?
+ ------------
+@@ -483,9 +483,9 @@ also initialize its own internal state.
+ and those methods.)
+ 
+ After you initialize the spi_master, then use spi_register_master() to
+-publish it to the rest of the system.  At that time, device nodes for
+-the controller and any predeclared spi devices will be made available,
+-and the driver model core will take care of binding them to drivers.
++publish it to the rest of the system. At that time, device nodes for the
++controller and any predeclared spi devices will be made available, and
++the driver model core will take care of binding them to drivers.
+ 
+ If you need to remove your SPI controller driver, spi_unregister_master()
+ will reverse the effect of spi_register_master().
+@@ -521,21 +521,53 @@ SPI MASTER METHODS
+ 		** When you code setup(), ASSUME that the controller
+ 		** is actively processing transfers for another device.
+ 
+-    master->transfer(struct spi_device *spi, struct spi_message *message)
+-    	This must not sleep.  Its responsibility is arrange that the
+-	transfer happens and its complete() callback is issued.  The two
+-	will normally happen later, after other transfers complete, and
+-	if the controller is idle it will need to be kickstarted.
+-
+     master->cleanup(struct spi_device *spi)
+ 	Your controller driver may use spi_device.controller_state to hold
+ 	state it dynamically associates with that device.  If you do that,
+ 	be sure to provide the cleanup() method to free that state.
+ 
++    master->prepare_transfer_hardware(struct spi_master *master)
++	This will be called by the queue mechanism to signal to the driver
++	that a message is coming in soon, so the subsystem requests the
++	driver to prepare the transfer hardware by issuing this call.
++	This may sleep.
++
++    master->unprepare_transfer_hardware(struct spi_master *master)
++	This will be called by the queue mechanism to signal to the driver
++	that there are no more messages pending in the queue and it may
++	relax the hardware (e.g. by power management calls). This may sleep.
++
++    master->transfer_one_message(struct spi_master *master,
++				 struct spi_message *mesg)
++	The subsystem calls the driver to transfer a single message while
++	queuing transfers that arrive in the meantime. When the driver is
++	finished with this message, it must call
++	spi_finalize_current_message() so the subsystem can issue the next
++	transfer. This may sleep.
++
++    DEPRECATED METHODS
++
++    master->transfer(struct spi_device *spi, struct spi_message *message)
++	This must not sleep. Its responsibility is arrange that the
++	transfer happens and its complete() callback is issued. The two
++	will normally happen later, after other transfers complete, and
++	if the controller is idle it will need to be kickstarted. This
++	method is not used on queued controllers and must be NULL if
++	transfer_one_message() and (un)prepare_transfer_hardware() are
++	implemented.
++
+ 
+ SPI MESSAGE QUEUE
+ 
+-The bulk of the driver will be managing the I/O queue fed by transfer().
++If you are happy with the standard queueing mechanism provided by the
++SPI subsystem, just implement the queued methods specified above. Using
++the message queue has the upside of centralizing a lot of code and
++providing pure process-context execution of methods. The message queue
++can also be elevated to realtime priority on high-priority SPI traffic.
++
++Unless the queueing mechanism in the SPI subsystem is selected, the bulk
++of the driver will be managing the I/O queue fed by the now deprecated
++function transfer().
+ 
+ That queue could be purely conceptual.  For example, a driver used only
+ for low-frequency sensor access might be fine using synchronous PIO.
+@@ -561,4 +593,6 @@ Stephen Street
+ Mark Underwood
+ Andrew Victor
+ Vitaly Wool
+-
++Grant Likely
++Mark Brown
++Linus Walleij
+--- a/drivers/spi/spi.c
++++ b/drivers/spi/spi.c
+@@ -30,6 +30,9 @@
+ #include <linux/of_spi.h>
+ #include <linux/pm_runtime.h>
+ #include <linux/export.h>
++#include <linux/sched.h>
++#include <linux/delay.h>
++#include <linux/kthread.h>
+ 
+ static void spidev_release(struct device *dev)
+ {
+@@ -507,6 +510,293 @@ spi_register_board_info(struct spi_board
+ 
+ /*-------------------------------------------------------------------------*/
+ 
++/**
++ * spi_pump_messages - kthread work function which processes spi message queue
++ * @work: pointer to kthread work struct contained in the master struct
++ *
++ * This function checks if there is any spi message in the queue that
++ * needs processing and if so call out to the driver to initialize hardware
++ * and transfer each message.
++ *
++ */
++static void spi_pump_messages(struct kthread_work *work)
++{
++	struct spi_master *master =
++		container_of(work, struct spi_master, pump_messages);
++	unsigned long flags;
++	bool was_busy = false;
++	int ret;
++
++	/* Lock queue and check for queue work */
++	spin_lock_irqsave(&master->queue_lock, flags);
++	if (list_empty(&master->queue) || !master->running) {
++		if (master->busy) {
++			ret = master->unprepare_transfer_hardware(master);
++			if (ret) {
++				dev_err(&master->dev,
++					"failed to unprepare transfer hardware\n");
++				return;
++			}
++		}
++		master->busy = false;
++		spin_unlock_irqrestore(&master->queue_lock, flags);
++		return;
++	}
++
++	/* Make sure we are not already running a message */
++	if (master->cur_msg) {
++		spin_unlock_irqrestore(&master->queue_lock, flags);
++		return;
++	}
++	/* Extract head of queue */
++	master->cur_msg =
++	    list_entry(master->queue.next, struct spi_message, queue);
++
++	list_del_init(&master->cur_msg->queue);
++	if (master->busy)
++		was_busy = true;
++	else
++		master->busy = true;
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++
++	if (!was_busy) {
++		ret = master->prepare_transfer_hardware(master);
++		if (ret) {
++			dev_err(&master->dev,
++				"failed to prepare transfer hardware\n");
++			return;
++		}
++	}
++
++	ret = master->transfer_one_message(master, master->cur_msg);
++	if (ret) {
++		dev_err(&master->dev,
++			"failed to transfer one message from queue\n");
++		return;
++	}
++}
++
++static int spi_init_queue(struct spi_master *master)
++{
++	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
++
++	INIT_LIST_HEAD(&master->queue);
++	spin_lock_init(&master->queue_lock);
++
++	master->running = false;
++	master->busy = false;
++
++	init_kthread_worker(&master->kworker);
++	master->kworker_task = kthread_run(kthread_worker_fn,
++					   &master->kworker,
++					   dev_name(&master->dev));
++	if (IS_ERR(master->kworker_task)) {
++		dev_err(&master->dev, "failed to create message pump task\n");
++		return -ENOMEM;
++	}
++	init_kthread_work(&master->pump_messages, spi_pump_messages);
++
++	/*
++	 * Master config will indicate if this controller should run the
++	 * message pump with high (realtime) priority to reduce the transfer
++	 * latency on the bus by minimising the delay between a transfer
++	 * request and the scheduling of the message pump thread. Without this
++	 * setting the message pump thread will remain at default priority.
++	 */
++	if (master->rt) {
++		dev_info(&master->dev,
++			"will run message pump with realtime priority\n");
++		sched_setscheduler(master->kworker_task, SCHED_FIFO, &param);
++	}
++
++	return 0;
++}
++
++/**
++ * spi_get_next_queued_message() - called by driver to check for queued
++ * messages
++ * @master: the master to check for queued messages
++ *
++ * If there are more messages in the queue, the next message is returned from
++ * this call.
++ */
++struct spi_message *spi_get_next_queued_message(struct spi_master *master)
++{
++	struct spi_message *next;
++	unsigned long flags;
++
++	/* get a pointer to the next message, if any */
++	spin_lock_irqsave(&master->queue_lock, flags);
++	if (list_empty(&master->queue))
++		next = NULL;
++	else
++		next = list_entry(master->queue.next,
++				  struct spi_message, queue);
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++
++	return next;
++}
++EXPORT_SYMBOL_GPL(spi_get_next_queued_message);
++
++/**
++ * spi_finalize_current_message() - the current message is complete
++ * @master: the master to return the message to
++ *
++ * Called by the driver to notify the core that the message in the front of the
++ * queue is complete and can be removed from the queue.
++ */
++void spi_finalize_current_message(struct spi_master *master)
++{
++	struct spi_message *mesg;
++	unsigned long flags;
++
++	spin_lock_irqsave(&master->queue_lock, flags);
++	mesg = master->cur_msg;
++	master->cur_msg = NULL;
++
++	queue_kthread_work(&master->kworker, &master->pump_messages);
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++
++	mesg->state = NULL;
++	if (mesg->complete)
++		mesg->complete(mesg->context);
++}
++EXPORT_SYMBOL_GPL(spi_finalize_current_message);
++
++static int spi_start_queue(struct spi_master *master)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&master->queue_lock, flags);
++
++	if (master->running || master->busy) {
++		spin_unlock_irqrestore(&master->queue_lock, flags);
++		return -EBUSY;
++	}
++
++	master->running = true;
++	master->cur_msg = NULL;
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++
++	queue_kthread_work(&master->kworker, &master->pump_messages);
++
++	return 0;
++}
++
++static int spi_stop_queue(struct spi_master *master)
++{
++	unsigned long flags;
++	unsigned limit = 500;
++	int ret = 0;
++
++	spin_lock_irqsave(&master->queue_lock, flags);
++
++	/*
++	 * This is a bit lame, but is optimized for the common execution path.
++	 * A wait_queue on the master->busy could be used, but then the common
++	 * execution path (pump_messages) would be required to call wake_up or
++	 * friends on every SPI message. Do this instead.
++	 */
++	while ((!list_empty(&master->queue) || master->busy) && limit--) {
++		spin_unlock_irqrestore(&master->queue_lock, flags);
++		msleep(10);
++		spin_lock_irqsave(&master->queue_lock, flags);
++	}
++
++	if (!list_empty(&master->queue) || master->busy)
++		ret = -EBUSY;
++	else
++		master->running = false;
++
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++
++	if (ret) {
++		dev_warn(&master->dev,
++			 "could not stop message queue\n");
++		return ret;
++	}
++	return ret;
++}
++
++static int spi_destroy_queue(struct spi_master *master)
++{
++	int ret;
++
++	ret = spi_stop_queue(master);
++
++	/*
++	 * flush_kthread_worker will block until all work is done.
++	 * If the reason that stop_queue timed out is that the work will never
++	 * finish, then it does no good to call flush/stop thread, so
++	 * return anyway.
++	 */
++	if (ret) {
++		dev_err(&master->dev, "problem destroying queue\n");
++		return ret;
++	}
++
++	flush_kthread_worker(&master->kworker);
++	kthread_stop(master->kworker_task);
++
++	return 0;
++}
++
++/**
++ * spi_queued_transfer - transfer function for queued transfers
++ * @spi: spi device which is requesting transfer
++ * @msg: spi message which is to handled is queued to driver queue
++ */
++static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
++{
++	struct spi_master *master = spi->master;
++	unsigned long flags;
++
++	spin_lock_irqsave(&master->queue_lock, flags);
++
++	if (!master->running) {
++		spin_unlock_irqrestore(&master->queue_lock, flags);
++		return -ESHUTDOWN;
++	}
++	msg->actual_length = 0;
++	msg->status = -EINPROGRESS;
++
++	list_add_tail(&msg->queue, &master->queue);
++	if (master->running && !master->busy)
++		queue_kthread_work(&master->kworker, &master->pump_messages);
++
++	spin_unlock_irqrestore(&master->queue_lock, flags);
++	return 0;
++}
++
++static int spi_master_initialize_queue(struct spi_master *master)
++{
++	int ret;
++
++	master->queued = true;
++	master->transfer = spi_queued_transfer;
++
++	/* Initialize and start queue */
++	ret = spi_init_queue(master);
++	if (ret) {
++		dev_err(&master->dev, "problem initializing queue\n");
++		goto err_init_queue;
++	}
++	ret = spi_start_queue(master);
++	if (ret) {
++		dev_err(&master->dev, "problem starting queue\n");
++		goto err_start_queue;
++	}
++
++	return 0;
++
++err_start_queue:
++err_init_queue:
++	spi_destroy_queue(master);
++	return ret;
++}
++
++/*-------------------------------------------------------------------------*/
++
+ static void spi_master_release(struct device *dev)
+ {
+ 	struct spi_master *master;
+@@ -522,6 +812,7 @@ static struct class spi_master_class = {
+ };
+ 
+ 
++
+ /**
+  * spi_alloc_master - allocate SPI master controller
+  * @dev: the controller, possibly using the platform_bus
+@@ -621,6 +912,15 @@ int spi_register_master(struct spi_maste
+ 	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
+ 			dynamic ? " (dynamic)" : "");
+ 
++	/* If we're using a queued driver, start the queue */
++	if (!master->transfer) {
++		status = spi_master_initialize_queue(master);
++		if (status) {
++			device_unregister(&master->dev);
++			goto done;
++		}
++	}
++
+ 	mutex_lock(&board_lock);
+ 	list_add_tail(&master->list, &spi_master_list);
+ 	list_for_each_entry(bi, &board_list, list)
+@@ -636,7 +936,6 @@ done:
+ }
+ EXPORT_SYMBOL_GPL(spi_register_master);
+ 
+-
+ static int __unregister(struct device *dev, void *null)
+ {
+ 	spi_unregister_device(to_spi_device(dev));
+@@ -657,6 +956,11 @@ void spi_unregister_master(struct spi_ma
+ {
+ 	int dummy;
+ 
++	if (master->queued) {
++		if (spi_destroy_queue(master))
++			dev_err(&master->dev, "queue remove failed\n");
++	}
++
+ 	mutex_lock(&board_lock);
+ 	list_del(&master->list);
+ 	mutex_unlock(&board_lock);
+@@ -666,6 +970,37 @@ void spi_unregister_master(struct spi_ma
+ }
+ EXPORT_SYMBOL_GPL(spi_unregister_master);
+ 
++int spi_master_suspend(struct spi_master *master)
++{
++	int ret;
++
++	/* Basically no-ops for non-queued masters */
++	if (!master->queued)
++		return 0;
++
++	ret = spi_stop_queue(master);
++	if (ret)
++		dev_err(&master->dev, "queue stop failed\n");
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(spi_master_suspend);
++
++int spi_master_resume(struct spi_master *master)
++{
++	int ret;
++
++	if (!master->queued)
++		return 0;
++
++	ret = spi_start_queue(master);
++	if (ret)
++		dev_err(&master->dev, "queue restart failed\n");
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(spi_master_resume);
++
+ static int __spi_master_match(struct device *dev, void *data)
+ {
+ 	struct spi_master *m;
+--- a/include/linux/spi/spi.h
++++ b/include/linux/spi/spi.h
+@@ -22,6 +22,7 @@
+ #include <linux/device.h>
+ #include <linux/mod_devicetable.h>
+ #include <linux/slab.h>
++#include <linux/kthread.h>
+ 
+ /*
+  * INTERFACES between SPI master-side drivers and SPI infrastructure.
+@@ -235,6 +236,27 @@ static inline void spi_unregister_driver
+  *	the device whose settings are being modified.
+  * @transfer: adds a message to the controller's transfer queue.
+  * @cleanup: frees controller-specific state
++ * @queued: whether this master is providing an internal message queue
++ * @kworker: thread struct for message pump
++ * @kworker_task: pointer to task for message pump kworker thread
++ * @pump_messages: work struct for scheduling work to the message pump
++ * @queue_lock: spinlock to syncronise access to message queue
++ * @queue: message queue
++ * @cur_msg: the currently in-flight message
++ * @busy: message pump is busy
++ * @running: message pump is running
++ * @rt: whether this queue is set to run as a realtime task
++ * @prepare_transfer_hardware: a message will soon arrive from the queue
++ *	so the subsystem requests the driver to prepare the transfer hardware
++ *	by issuing this call
++ * @transfer_one_message: the subsystem calls the driver to transfer a single
++ *	message while queuing transfers that arrive in the meantime. When the
++ *	driver is finished with this message, it must call
++ *	spi_finalize_current_message() so the subsystem can issue the next
++ *	transfer
++ * @prepare_transfer_hardware: there are currently no more messages on the
++ *	queue so the subsystem notifies the driver that it may relax the
++ *	hardware by issuing this call
+  *
+  * Each SPI master controller can communicate with one or more @spi_device
+  * children.  These make a small bus, sharing MOSI, MISO and SCK signals
+@@ -318,6 +340,28 @@ struct spi_master {
+ 
+ 	/* called on release() to free memory provided by spi_master */
+ 	void			(*cleanup)(struct spi_device *spi);
++
++	/*
++	 * These hooks are for drivers that want to use the generic
++	 * master transfer queueing mechanism. If these are used, the
++	 * transfer() function above must NOT be specified by the driver.
++	 * Over time we expect SPI drivers to be phased over to this API.
++	 */
++	bool				queued;
++	struct kthread_worker		kworker;
++	struct task_struct		*kworker_task;
++	struct kthread_work		pump_messages;
++	spinlock_t			queue_lock;
++	struct list_head		queue;
++	struct spi_message		*cur_msg;
++	bool				busy;
++	bool				running;
++	bool				rt;
++
++	int (*prepare_transfer_hardware)(struct spi_master *master);
++	int (*transfer_one_message)(struct spi_master *master,
++				    struct spi_message *mesg);
++	int (*unprepare_transfer_hardware)(struct spi_master *master);
+ };
+ 
+ static inline void *spi_master_get_devdata(struct spi_master *master)
+@@ -343,6 +387,13 @@ static inline void spi_master_put(struct
+ 		put_device(&master->dev);
+ }
+ 
++/* PM calls that need to be issued by the driver */
++extern int spi_master_suspend(struct spi_master *master);
++extern int spi_master_resume(struct spi_master *master);
++
++/* Calls the driver make to interact with the message queue */
++extern struct spi_message *spi_get_next_queued_message(struct spi_master *master);
++extern void spi_finalize_current_message(struct spi_master *master);
+ 
+ /* the spi driver core manages memory for the spi_master classdev */
+ extern struct spi_master *
Index: target/linux/generic/files/include/linux/rt2x00_platform.h
===================================================================
--- target/linux/generic/files/include/linux/rt2x00_platform.h	(revision 31639)
+++ target/linux/generic/files/include/linux/rt2x00_platform.h	(working copy)
@@ -14,9 +14,11 @@
 
 struct rt2x00_platform_data {
 	char *eeprom_file_name;
+	const u8 *mac_address;
 
 	int disable_2ghz;
 	int disable_5ghz;
+	int clk_is_20mhz;
 };
 
 #endif /* _RT2X00_PLATFORM_H */
Index: target/linux/generic/files/include/linux/ath9k_platform.h
===================================================================
--- target/linux/generic/files/include/linux/ath9k_platform.h	(revision 31639)
+++ target/linux/generic/files/include/linux/ath9k_platform.h	(working copy)
@@ -31,6 +31,9 @@
 
 	bool endian_check;
 	bool is_clk_25mhz;
+	bool disable_2ghz;
+	bool disable_5ghz;
+
 	int (*get_mac_revision)(void);
 	int (*external_reset)(void);
 
Index: target/linux/generic/config-3.3
===================================================================
--- target/linux/generic/config-3.3	(revision 31639)
+++ target/linux/generic/config-3.3	(working copy)
@@ -47,6 +47,7 @@
 # CONFIG_ARCH_CLPS711X is not set
 # CONFIG_ARCH_CNS3XXX is not set
 # CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
 # CONFIG_ARCH_DOVE is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
@@ -55,6 +56,8 @@
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_GEMINI is not set
 # CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
 # CONFIG_ARCH_HIGHBANK is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_IOP13XX is not set
@@ -76,6 +79,7 @@
 # CONFIG_ARCH_NUC93X is not set
 # CONFIG_ARCH_OMAP is not set
 # CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
 # CONFIG_ARCH_PICOXCELL is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PRIMA2 is not set
@@ -90,6 +94,7 @@
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_ARCH_TCC_926 is not set
 # CONFIG_ARCH_TEGRA is not set
 # CONFIG_ARCH_U300 is not set
@@ -132,6 +137,7 @@
 # CONFIG_ATL2 is not set
 # CONFIG_ATM is not set
 # CONFIG_ATMEL is not set
+# CONFIG_ATMEL_PWM is not set
 # CONFIG_ATM_AMBASSADOR is not set
 # CONFIG_ATM_BR2684 is not set
 CONFIG_ATM_BR2684_IPFILTER=y
@@ -249,6 +255,7 @@
 # CONFIG_BLK_DEV_NVME is not set
 # CONFIG_BLK_DEV_OFFBOARD is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PIIX is not set
@@ -285,6 +292,7 @@
 CONFIG_BOOT_RAW=y
 # CONFIG_BPQETHER is not set
 CONFIG_BQL=y
+CONFIG_BRANCH_PROFILE_NONE=y
 # CONFIG_BRCMFMAC is not set
 CONFIG_BRIDGE=y
 # CONFIG_BRIDGE_EBT_802_3 is not set
@@ -402,6 +410,7 @@
 # CONFIG_CODE_PATCHING_SELFTEST is not set
 # CONFIG_COMEDI is not set
 # CONFIG_COMPACTION is not set
+# CONFIG_COMPAL_LAPTOP is not set
 # CONFIG_COMPAT_BRK is not set
 # CONFIG_CONFIGFS_FS is not set
 # CONFIG_CONNECTOR is not set
@@ -417,10 +426,10 @@
 # CONFIG_CRAMFS is not set
 CONFIG_CRASHLOG=y
 # CONFIG_CRASH_DUMP is not set
-# CONFIG_CRC8 is not set
 # CONFIG_CRC16 is not set
 CONFIG_CRC32=y
 # CONFIG_CRC7 is not set
+# CONFIG_CRC8 is not set
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC_ITU_T is not set
 # CONFIG_CRC_T10DIF is not set
@@ -503,8 +512,8 @@
 # CONFIG_CRYPTO_VMAC is not set
 # CONFIG_CRYPTO_WP512 is not set
 # CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_XTS is not set
 # CONFIG_CRYPTO_XZ is not set
-# CONFIG_CRYPTO_XTS is not set
 # CONFIG_CRYPTO_ZLIB is not set
 # CONFIG_CRYSTALHD is not set
 # CONFIG_CS5535_MFGPT is not set
@@ -523,6 +532,7 @@
 # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
 CONFIG_DEBUG_FS=y
 # CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_HIGHMEM is not set
 # CONFIG_DEBUG_ICEDCC is not set
 # CONFIG_DEBUG_INFO is not set
 CONFIG_DEBUG_INFO_REDUCED=y
@@ -540,8 +550,8 @@
 # CONFIG_DEBUG_NX_TEST is not set
 # CONFIG_DEBUG_OBJECTS is not set
 # CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
 # CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
 # CONFIG_DEBUG_PREEMPT is not set
 # CONFIG_DEBUG_RODATA is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
@@ -557,6 +567,7 @@
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
 # CONFIG_DECNET is not set
+CONFIG_DEFAULT_CUBIC=y
 CONFIG_DEFAULT_DEADLINE=y
 CONFIG_DEFAULT_HOSTNAME="(none)"
 CONFIG_DEFAULT_IOSCHED="deadline"
@@ -566,8 +577,7 @@
 # CONFIG_DEFAULT_RENO is not set
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_TCP_CONG="westwood"
-CONFIG_DEFAULT_WESTWOOD=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 # CONFIG_DEPRECATED_PARAM_STRUCT is not set
 # CONFIG_DETECT_HUNG_TASK is not set
@@ -590,13 +600,13 @@
 # CONFIG_DMA_SHARED_BUFFER is not set
 # CONFIG_DM_DEBUG is not set
 # CONFIG_DM_DELAY is not set
+# CONFIG_DM_FLAKEY is not set
 # CONFIG_DM_LOG_USERSPACE is not set
-# CONFIG_DM_FLAKEY is not set
 # CONFIG_DM_MULTIPATH is not set
 # CONFIG_DM_RAID is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
 # CONFIG_DM_UEVENT is not set
 # CONFIG_DM_ZERO is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
 # CONFIG_DNET is not set
 # CONFIG_DNOTIFY is not set
 CONFIG_DQL=y
@@ -606,6 +616,7 @@
 # CONFIG_DTLK is not set
 # CONFIG_DUMMY is not set
 # CONFIG_DVB_CORE is not set
+# CONFIG_DW_WATCHDOG is not set
 # CONFIG_DX_SEP is not set
 # CONFIG_DYNAMIC_DEBUG is not set
 # CONFIG_E100 is not set
@@ -644,6 +655,7 @@
 CONFIG_ETHERNET=y
 # CONFIG_ETHOC is not set
 CONFIG_EVENTFD=y
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
 # CONFIG_EWRK3 is not set
 CONFIG_EXPERIMENTAL=y
 CONFIG_EXPERT=y
@@ -673,6 +685,7 @@
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_ARC is not set
 # CONFIG_FB_ARK is not set
+# CONFIG_FB_ARMCLCD is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_ATY is not set
 # CONFIG_FB_ATY128 is not set
@@ -713,6 +726,7 @@
 # CONFIG_FB_S3 is not set
 # CONFIG_FB_SAVAGE is not set
 # CONFIG_FB_SIS is not set
+# CONFIG_FB_SM7XX is not set
 # CONFIG_FB_SMSCUFX is not set
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_SYS_COPYAREA is not set
@@ -720,6 +734,7 @@
 # CONFIG_FB_SYS_FOPS is not set
 # CONFIG_FB_SYS_IMAGEBLIT is not set
 # CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_TMIO is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_UDL is not set
 # CONFIG_FB_VGA16 is not set
@@ -727,6 +742,7 @@
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_VT8623 is not set
+# CONFIG_FB_XGI is not set
 # CONFIG_FCOE is not set
 # CONFIG_FCOE_FNIC is not set
 # CONFIG_FDDI is not set
@@ -736,6 +752,7 @@
 CONFIG_FILE_LOCKING=y
 # CONFIG_FIREWIRE is not set
 # CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_FIRMWARE_EDID is not set
 # CONFIG_FIRMWARE_IN_KERNEL is not set
 # CONFIG_FIXED_PHY is not set
 CONFIG_FLATMEM=y
@@ -771,9 +788,11 @@
 # CONFIG_GAMEPORT is not set
 # CONFIG_GCOV_KERNEL is not set
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_CPU_DEVICES is not set
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_IRQ_PROBE=y
+# CONFIG_GENERIC_PWM is not set
 CONFIG_GENERIC_TIME=y
 # CONFIG_GFS2_FS is not set
 # CONFIG_GIGASET_CAPI is not set
@@ -825,6 +844,7 @@
 # CONFIG_HID is not set
 # CONFIG_HIDRAW is not set
 # CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
 # CONFIG_HID_ACRUX_FF is not set
 # CONFIG_HID_APPLE is not set
 # CONFIG_HID_BELKIN is not set
@@ -877,7 +897,6 @@
 # CONFIG_HID_WIIMOTE is not set
 # CONFIG_HID_ZEROPLUS is not set
 # CONFIG_HID_ZYDACRON is not set
-# CONFIG_HID_ACRUX is not set
 # CONFIG_HIGHMEM is not set
 CONFIG_HIGH_RES_TIMERS=y
 # CONFIG_HIPPI is not set
@@ -901,8 +920,10 @@
 # CONFIG_HVC_DCC is not set
 # CONFIG_HVC_UDBG is not set
 # CONFIG_HWMON is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
 # CONFIG_HWMON_VID is not set
 # CONFIG_HWSPINLOCK_OMAP is not set
+CONFIG_HW_PERF_EVENTS=y
 # CONFIG_HW_RANDOM is not set
 # CONFIG_HW_RANDOM_AMD is not set
 # CONFIG_HW_RANDOM_GEODE is not set
@@ -949,6 +970,7 @@
 # CONFIG_I2C_ISCH is not set
 # CONFIG_I2C_MPC is not set
 # CONFIG_I2C_MUX is not set
+# CONFIG_I2C_MV64XXX is not set
 # CONFIG_I2C_NFORCE2 is not set
 # CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PARPORT is not set
@@ -956,8 +978,9 @@
 # CONFIG_I2C_PCA_ISA is not set
 # CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SCMI is not set
 # CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_SCMI is not set
 # CONFIG_I2C_SIS5595 is not set
 # CONFIG_I2C_SIS630 is not set
 # CONFIG_I2C_SIS96X is not set
@@ -965,6 +988,7 @@
 # CONFIG_I2C_STUB is not set
 # CONFIG_I2C_TAOS_EVM is not set
 # CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VERSATILE is not set
 # CONFIG_I2C_VIA is not set
 # CONFIG_I2C_VIAPRO is not set
 # CONFIG_I2C_XILINX is not set
@@ -983,11 +1007,11 @@
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_ICS932S401 is not set
 # CONFIG_IDE is not set
+# CONFIG_IDEAPAD_LAPTOP is not set
 # CONFIG_IDE_GD is not set
 # CONFIG_IDE_PHISON is not set
 # CONFIG_IDE_PROC_FS is not set
 # CONFIG_IDE_TASK_IOCTL is not set
-# CONFIG_IDEAPAD_LAPTOP is not set
 # CONFIG_IEEE802154 is not set
 # CONFIG_IFB is not set
 # CONFIG_IGB is not set
@@ -1062,8 +1086,8 @@
 # CONFIG_INPUT_ATI_REMOTE2 is not set
 # CONFIG_INPUT_ATLAS_BTNS is not set
 # CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_CM109 is not set
 # CONFIG_INPUT_CMA3000 is not set
-# CONFIG_INPUT_CM109 is not set
 # CONFIG_INPUT_EVBUG is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_FF_MEMLESS is not set
@@ -1089,16 +1113,14 @@
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_UINPUT is not set
 # CONFIG_INPUT_WISTRON_BTNS is not set
-# CONFIG_INTEL_MID_PTI is not set
 # CONFIG_INPUT_YEALINK is not set
 # CONFIG_INTEL_IDLE is not set
 # CONFIG_INTEL_MID_PTI is not set
+# CONFIG_INTEL_OAKTRAIL is not set
 # CONFIG_IOMMU_SUPPORT is not set
 # CONFIG_IOSCHED_CFQ is not set
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_NOOP=y
-# CONFIG_IP_FIB_TRIE_STATS is not set
-# CONFIG_IP_SET is not set
 # CONFIG_IP1000 is not set
 # CONFIG_IP17XX_PHY is not set
 # CONFIG_IP6_NF_FILTER is not set
@@ -1111,8 +1133,8 @@
 # CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
 # CONFIG_IP6_NF_MATCH_MH is not set
 # CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
 # CONFIG_IP6_NF_MATCH_RT is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
 # CONFIG_IP6_NF_QUEUE is not set
 # CONFIG_IP6_NF_RAW is not set
 # CONFIG_IP6_NF_TARGET_HL is not set
@@ -1146,6 +1168,7 @@
 # CONFIG_IPX is not set
 CONFIG_IP_ADVANCED_ROUTER=y
 # CONFIG_IP_DCCP is not set
+# CONFIG_IP_FIB_TRIE_STATS is not set
 CONFIG_IP_MROUTE=y
 CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
 CONFIG_IP_MULTICAST=y
@@ -1178,6 +1201,7 @@
 CONFIG_IP_ROUTE_MULTIPATH=y
 CONFIG_IP_ROUTE_VERBOSE=y
 # CONFIG_IP_SCTP is not set
+# CONFIG_IP_SET is not set
 # CONFIG_IP_VS is not set
 # CONFIG_IRDA is not set
 # CONFIG_IRQSOFF_TRACER is not set
@@ -1192,8 +1216,6 @@
 # CONFIG_IR_SONY_DECODER is not set
 # CONFIG_IR_STREAMZAP is not set
 # CONFIG_ISCSI_BOOT_SYSFS is not set
-# CONFIG_SCSI_CXGB3_ISCSI is not set
-# CONFIG_SCSI_CXGB4_ISCSI is not set
 # CONFIG_ISCSI_TCP is not set
 CONFIG_ISDN=y
 # CONFIG_ISDN_AUDIO is not set
@@ -1303,6 +1325,7 @@
 # CONFIG_LEDS_BD2802 is not set
 CONFIG_LEDS_CLASS=y
 # CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_GPIO is not set
 CONFIG_LEDS_GPIO_OF=y
 CONFIG_LEDS_GPIO_PLATFORM=y
 # CONFIG_LEDS_INTEL_SS4200 is not set
@@ -1311,6 +1334,7 @@
 # CONFIG_LEDS_LP5521 is not set
 # CONFIG_LEDS_LP5523 is not set
 # CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_NET5501 is not set
 # CONFIG_LEDS_OT200 is not set
 # CONFIG_LEDS_PCA9532 is not set
 # CONFIG_LEDS_PCA955X is not set
@@ -1355,7 +1379,7 @@
 # CONFIG_LOGIRUMBLEPAD2_FF is not set
 # CONFIG_LOGITECH_FF is not set
 # CONFIG_LOGO is not set
-CONFIG_LOG_BUF_SHIFT=14
+CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LOONGSON_MC146818 is not set
 # CONFIG_LP486E is not set
 # CONFIG_LPC_SCH is not set
@@ -1384,8 +1408,8 @@
 # CONFIG_MARVELL_PHY is not set
 # CONFIG_MAX63XX_WATCHDOG is not set
 # CONFIG_MD is not set
+# CONFIG_MDIO_BITBANG is not set
 # CONFIG_MD_FAULTY is not set
-# CONFIG_MDIO_BITBANG is not set
 # CONFIG_MEDIA_ATTACH is not set
 # CONFIG_MEDIA_CONTROLLER is not set
 # CONFIG_MEDIA_SUPPORT is not set
@@ -1400,8 +1424,8 @@
 # CONFIG_MFD_ASIC3 is not set
 # CONFIG_MFD_CORE is not set
 # CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_DA9052_I2C is not set
 # CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9052_I2C is not set
 # CONFIG_MFD_JANZ_CMODIO is not set
 # CONFIG_MFD_MAX8925 is not set
 # CONFIG_MFD_MAX8997 is not set
@@ -1424,13 +1448,13 @@
 # CONFIG_MFD_TPS65912_I2C is not set
 # CONFIG_MFD_TPS65912_SPI is not set
 # CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_MFD_WM831X is not set
 # CONFIG_MFD_WM831X_I2C is not set
 # CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8400 is not set
 # CONFIG_MFD_WM8994 is not set
-# CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_MG_DISK is not set
 # CONFIG_MICREL_KS8995MA is not set
 # CONFIG_MICREL_PHY is not set
@@ -1438,6 +1462,7 @@
 CONFIG_MII=y
 # CONFIG_MIKROTIK_RB532 is not set
 # CONFIG_MINIX_FS is not set
+# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
 # CONFIG_MINIX_SUBPARTITION is not set
 # CONFIG_MIPS_ALCHEMY is not set
 # CONFIG_MIPS_COBALT is not set
@@ -1455,6 +1480,7 @@
 # CONFIG_MISDN_SPEEDFAX is not set
 # CONFIG_MISDN_W6692 is not set
 # CONFIG_MKISS is not set
+# CONFIG_MLX4_CORE is not set
 # CONFIG_MLX4_EN is not set
 # CONFIG_MMC is not set
 # CONFIG_MMC_ARMMMCI is not set
@@ -1494,6 +1520,7 @@
 # CONFIG_MSDOS_FS is not set
 CONFIG_MSDOS_PARTITION=y
 # CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_MSI_LAPTOP is not set
 CONFIG_MTD=y
 # CONFIG_MTD_ABSENT is not set
 # CONFIG_MTD_AFS_PARTS is not set
@@ -1529,6 +1556,7 @@
 # CONFIG_MTD_GPIO_ADDR is not set
 # CONFIG_MTD_INTEL_VR_NOR is not set
 # CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_LATCH_ADDR is not set
 # CONFIG_MTD_LPDDR is not set
 # CONFIG_MTD_M25P80 is not set
 CONFIG_MTD_MAP_BANK_WIDTH_1=y
@@ -1541,6 +1569,7 @@
 # CONFIG_MTD_MYLOADER_PARTS is not set
 # CONFIG_MTD_NAND is not set
 # CONFIG_MTD_NAND_AMS_DELTA is not set
+# CONFIG_MTD_NAND_AR934X is not set
 # CONFIG_MTD_NAND_ATMEL is not set
 # CONFIG_MTD_NAND_AU1550 is not set
 # CONFIG_MTD_NAND_AUTCPU12 is not set
@@ -1599,7 +1628,6 @@
 # CONFIG_MTD_PHYSMAP is not set
 # CONFIG_MTD_PHYSMAP_COMPAT is not set
 # CONFIG_MTD_PLATRAM is not set
-# CONFIG_MTD_LATCH_ADDR is not set
 # CONFIG_MTD_PMC551 is not set
 # CONFIG_MTD_RAM is not set
 CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
@@ -1639,7 +1667,6 @@
 # CONFIG_NETFILTER_NETLINK_ACCT is not set
 # CONFIG_NETFILTER_NETLINK_LOG is not set
 # CONFIG_NETFILTER_NETLINK_QUEUE is not set
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
 # CONFIG_NETFILTER_TPROXY is not set
 # CONFIG_NETFILTER_XTABLES is not set
 # CONFIG_NETFILTER_XT_CONNMARK is not set
@@ -1652,8 +1679,8 @@
 # CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
 # CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
 # CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
 # CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
 # CONFIG_NETFILTER_XT_MATCH_DSCP is not set
 # CONFIG_NETFILTER_XT_MATCH_ECN is not set
 # CONFIG_NETFILTER_XT_MATCH_ESP is not set
@@ -1686,6 +1713,7 @@
 # CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
 # CONFIG_NETFILTER_XT_MATCH_TIME is not set
 # CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
 # CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
 # CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
 # CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
@@ -1769,17 +1797,19 @@
 # CONFIG_NET_SCH_ATM is not set
 # CONFIG_NET_SCH_CBQ is not set
 # CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_CODEL is not set
 # CONFIG_NET_SCH_DRR is not set
 # CONFIG_NET_SCH_DSMARK is not set
 # CONFIG_NET_SCH_ESFQ is not set
 CONFIG_NET_SCH_ESFQ_NFCT=y
 CONFIG_NET_SCH_FIFO=y
+# CONFIG_NET_SCH_FQ_CODEL is not set
 # CONFIG_NET_SCH_GRED is not set
 # CONFIG_NET_SCH_HFSC is not set
 # CONFIG_NET_SCH_HTB is not set
 # CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_MQPRIO is not set
 # CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_MQPRIO is not set
 # CONFIG_NET_SCH_NETEM is not set
 # CONFIG_NET_SCH_PRIO is not set
 # CONFIG_NET_SCH_QFQ is not set
@@ -1809,9 +1839,9 @@
 CONFIG_NET_VENDOR_FREESCALE=y
 CONFIG_NET_VENDOR_FUJITSU=y
 CONFIG_NET_VENDOR_HP=y
+CONFIG_NET_VENDOR_I825XX=y
 CONFIG_NET_VENDOR_IBM=y
 CONFIG_NET_VENDOR_INTEL=y
-CONFIG_NET_VENDOR_I825XX=y
 CONFIG_NET_VENDOR_MARVELL=y
 CONFIG_NET_VENDOR_MELLANOX=y
 CONFIG_NET_VENDOR_MICREL=y
@@ -1821,8 +1851,8 @@
 CONFIG_NET_VENDOR_NVIDIA=y
 CONFIG_NET_VENDOR_OKI=y
 CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_NET_VENDOR_RDC=y
 CONFIG_NET_VENDOR_REALTEK=y
-CONFIG_NET_VENDOR_RDC=y
 CONFIG_NET_VENDOR_SEEQ=y
 CONFIG_NET_VENDOR_SILAN=y
 CONFIG_NET_VENDOR_SIS=y
@@ -1830,12 +1860,13 @@
 CONFIG_NET_VENDOR_STMICRO=y
 CONFIG_NET_VENDOR_SUN=y
 CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_NET_VENDOR_TI=y
 CONFIG_NET_VENDOR_TOSHIBA=y
-CONFIG_NET_VENDOR_TI=y
 CONFIG_NET_VENDOR_VIA=y
 CONFIG_NET_VENDOR_XILINX=y
 CONFIG_NET_VENDOR_XIRCOM=y
 CONFIG_NEW_LEDS=y
+# CONFIG_NFC is not set
 # CONFIG_NFC_DEVICES is not set
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_DEPRECATED is not set
@@ -1851,7 +1882,6 @@
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_V4_1 is not set
 # CONFIG_NFTL is not set
-# CONFIG_NFC is not set
 # CONFIG_NF_CONNTRACK is not set
 # CONFIG_NF_CONNTRACK_AMANDA is not set
 # CONFIG_NF_CONNTRACK_EVENTS is not set
@@ -1868,9 +1898,9 @@
 # CONFIG_NF_CONNTRACK_RTSP is not set
 # CONFIG_NF_CONNTRACK_SANE is not set
 # CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
 # CONFIG_NF_CONNTRACK_TFTP is not set
 # CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
 # CONFIG_NF_CONNTRACK_ZONES is not set
 # CONFIG_NF_CT_NETLINK is not set
 # CONFIG_NF_CT_PROTO_DCCP is not set
@@ -2100,19 +2130,20 @@
 # CONFIG_PLIP is not set
 # CONFIG_PLX_HERMES is not set
 # CONFIG_PM is not set
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_PM_RUNTIME is not set
 # CONFIG_PMBUS is not set
 # CONFIG_PMC_MSP is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_PMIC_ADP5520 is not set
 # CONFIG_PMIC_DA903X is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_PM_RUNTIME is not set
 # CONFIG_PNX8550_JBS is not set
 # CONFIG_PNX8550_STB810 is not set
 # CONFIG_POHMELFS is not set
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_POWERTV is not set
 # CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
 # CONFIG_PPC4xx_GPIO is not set
 # CONFIG_PPC_16K_PAGES is not set
 # CONFIG_PPC_256K_PAGES is not set
@@ -2138,9 +2169,9 @@
 CONFIG_PREEMPT_NONE=y
 # CONFIG_PREEMPT_VOLUNTARY is not set
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_PRINT_STACK_DEPTH=64
 CONFIG_PRINTK=y
 # CONFIG_PRINTK_TIME is not set
+CONFIG_PRINT_STACK_DEPTH=64
 # CONFIG_PRISM2_USB is not set
 # CONFIG_PRISM54 is not set
 # CONFIG_PROBE_INITRD_HEADER is not set
@@ -2148,9 +2179,12 @@
 # CONFIG_PROC_KCORE is not set
 # CONFIG_PROC_PAGE_MONITOR is not set
 CONFIG_PROC_SYSCTL=y
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
 # CONFIG_PROFILING is not set
 # CONFIG_PROVE_LOCKING is not set
 # CONFIG_PROVE_RCU is not set
+# CONFIG_PSB6970_PHY is not set
 # CONFIG_PSTORE is not set
 # CONFIG_QLA3XXX is not set
 # CONFIG_QLCNIC is not set
@@ -2158,15 +2192,13 @@
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_QSEMI_PHY is not set
 # CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
 # CONFIG_QUOTA_DEBUG is not set
 # CONFIG_R3964 is not set
 # CONFIG_R6040 is not set
 # CONFIG_R8169 is not set
 # CONFIG_R8187SE is not set
 # CONFIG_R8712U is not set
-# CONFIG_RTLLIB is not set
-# CONFIG_RTS5139 is not set
-# CONFIG_RTS_PSTOR is not set
 # CONFIG_RADIO_ADAPTERS is not set
 # CONFIG_RADIO_AZTECH is not set
 # CONFIG_RADIO_CADET is not set
@@ -2185,13 +2217,13 @@
 # CONFIG_RAPIDIO is not set
 # CONFIG_RAR_REGISTER is not set
 # CONFIG_RAW_DRIVER is not set
-# CONFIG_RC_CORE is not set
 CONFIG_RCU_CPU_STALL_TIMEOUT=60
 CONFIG_RCU_FANOUT=32
 # CONFIG_RCU_FANOUT_EXACT is not set
 # CONFIG_RCU_FAST_NO_HZ is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_RCU_TRACE is not set
+# CONFIG_RC_CORE is not set
 # CONFIG_RC_MAP is not set
 # CONFIG_RDS is not set
 # CONFIG_RD_BZIP2 is not set
@@ -2214,6 +2246,7 @@
 # CONFIG_RFD_FTL is not set
 # CONFIG_RFKILL is not set
 # CONFIG_RFKILL_INPUT is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
 # CONFIG_ROMFS_FS is not set
 # CONFIG_ROSE is not set
 # CONFIG_RPCSEC_GSS_KRB5 is not set
@@ -2257,6 +2290,7 @@
 # CONFIG_RTC_DRV_PL030 is not set
 # CONFIG_RTC_DRV_PL031 is not set
 # CONFIG_RTC_DRV_PS3 is not set
+# CONFIG_RTC_DRV_PT7C4338 is not set
 # CONFIG_RTC_DRV_R9701 is not set
 # CONFIG_RTC_DRV_RP5C01 is not set
 # CONFIG_RTC_DRV_RS5C348 is not set
@@ -2284,9 +2318,12 @@
 # CONFIG_RTL8306_PHY is not set
 # CONFIG_RTL8366RB_PHY is not set
 # CONFIG_RTL8366S_PHY is not set
-# CONFIG_RTL8366S_PHY_DEBUG_FS is not set
 # CONFIG_RTL8366_SMI is not set
+# CONFIG_RTL8366_SMI_DEBUG_FS is not set
+# CONFIG_RTL8367B_PHY is not set
 # CONFIG_RTL8367_PHY is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTS5139 is not set
 # CONFIG_RTS_PSTOR is not set
 CONFIG_RT_MUTEXES=y
 # CONFIG_RT_MUTEX_TESTER is not set
@@ -2294,6 +2331,7 @@
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_S2IO is not set
 # CONFIG_SAMPLES is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
 # CONFIG_SATA_ACARD_AHCI is not set
 # CONFIG_SATA_AHCI is not set
 # CONFIG_SATA_AHCI_PLATFORM is not set
@@ -2339,10 +2377,12 @@
 # CONFIG_SCSI_AIC94XX is not set
 # CONFIG_SCSI_ARCMSR is not set
 # CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
 # CONFIG_SCSI_BNX2_ISCSI is not set
-# CONFIG_SCSI_BNX2X_FCOE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -2402,6 +2442,7 @@
 # CONFIG_SCSI_U14_34F is not set
 # CONFIG_SCSI_ULTRASTOR is not set
 CONFIG_SCSI_WAIT_SCAN=m
+# CONFIG_SDIO_UART is not set
 # CONFIG_SECCOMP is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
@@ -2495,6 +2536,7 @@
 # CONFIG_SENSORS_PCF8591 is not set
 # CONFIG_SENSORS_SCH5627 is not set
 # CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
 # CONFIG_SENSORS_SHT15 is not set
 # CONFIG_SENSORS_SHT21 is not set
 # CONFIG_SENSORS_SIS5595 is not set
@@ -2552,8 +2594,14 @@
 # CONFIG_SERIAL_XILINX_PS_UART is not set
 # CONFIG_SERIO is not set
 # CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_LIBPS2 is not set
 # CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_SERPORT is not set
 # CONFIG_SFC is not set
 # CONFIG_SFI is not set
 # CONFIG_SGI_IOC4 is not set
@@ -2571,6 +2619,7 @@
 # CONFIG_SIBYTE_RHONE is not set
 # CONFIG_SIBYTE_SENTOSA is not set
 # CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIGMA is not set
 CONFIG_SIGNALFD=y
 # CONFIG_SIMPLE_GPIO is not set
 # CONFIG_SIS190 is not set
@@ -2716,8 +2765,8 @@
 # CONFIG_SND_SIS7019 is not set
 # CONFIG_SND_SOC is not set
 # CONFIG_SND_SOC_CACHE_LZO is not set
+# CONFIG_SND_SOC_MPC5200_AC97 is not set
 # CONFIG_SND_SOC_MPC5200_I2S is not set
-# CONFIG_SND_SOC_MPC5200_AC97 is not set
 # CONFIG_SND_SONICVIBES is not set
 # CONFIG_SND_SPI is not set
 # CONFIG_SND_SSCAPE is not set
@@ -2759,11 +2808,13 @@
 # CONFIG_SPI is not set
 # CONFIG_SPINLOCK_TEST is not set
 # CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
 # CONFIG_SPI_BUTTERFLY is not set
 # CONFIG_SPI_DEBUG is not set
 # CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_FSL_ESPI is not set
 # CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_FSL_ESPI is not set
+# CONFIG_SPI_GPIO is not set
 # CONFIG_SPI_GPIO_OLD is not set
 # CONFIG_SPI_LM70_LLP is not set
 # CONFIG_SPI_MASTER is not set
@@ -2838,7 +2889,7 @@
 # CONFIG_TCIC is not set
 CONFIG_TCP_CONG_ADVANCED=y
 # CONFIG_TCP_CONG_BIC is not set
-# CONFIG_TCP_CONG_CUBIC is not set
+CONFIG_TCP_CONG_CUBIC=y
 # CONFIG_TCP_CONG_HSTCP is not set
 # CONFIG_TCP_CONG_HTCP is not set
 # CONFIG_TCP_CONG_HYBLA is not set
@@ -2847,7 +2898,7 @@
 # CONFIG_TCP_CONG_SCALABLE is not set
 # CONFIG_TCP_CONG_VEGAS is not set
 # CONFIG_TCP_CONG_VENO is not set
-CONFIG_TCP_CONG_WESTWOOD=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
 # CONFIG_TCP_CONG_YEAH is not set
 # CONFIG_TCP_MD5SIG is not set
 # CONFIG_TEHUTI is not set
@@ -2874,8 +2925,8 @@
 # CONFIG_TLAN is not set
 # CONFIG_TMD_HERMES is not set
 CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 CONFIG_TMPFS_XATTR=y
-# CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_AD7879_I2C is not set
@@ -2930,9 +2981,9 @@
 # CONFIG_ULTRA is not set
 # CONFIG_ULTRIX_PARTITION is not set
 CONFIG_UNIX=y
-# CONFIG_UNIX_DIAG is not set
 CONFIG_UNIX98_PTYS=y
 # CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_UNIX_DIAG is not set
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_USB is not set
 # CONFIG_USBIP_CORE is not set
@@ -2951,6 +3002,7 @@
 CONFIG_USB_BELKIN=y
 # CONFIG_USB_C67X00_HCD is not set
 # CONFIG_USB_CATC is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
 # CONFIG_USB_CXACRU is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
@@ -2958,22 +3010,31 @@
 CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_DEVICE_CLASS is not set
 # CONFIG_USB_DSBR is not set
+# CONFIG_USB_DUMMY_HCD is not set
 # CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC_OTG_LPM is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_EHCI_HCD_PPC_OF is not set
 # CONFIG_USB_EHCI_MV is not set
-# CONFIG_USB_EHCI_HCD_PPC_OF is not set
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
 # CONFIG_USB_EMI26 is not set
 # CONFIG_USB_EMI62 is not set
 # CONFIG_USB_ENESTORAGE is not set
 # CONFIG_USB_EPSON2888 is not set
 # CONFIG_USB_ET61X251 is not set
 CONFIG_USB_EZUSB=y
+# CONFIG_USB_FILE_STORAGE is not set
 # CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FUSB300 is not set
 # CONFIG_USB_GADGET is not set
+# CONFIG_USB_GADGETFS is not set
 # CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
 CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_GADGET_VBUS_DRAW=2
 # CONFIG_USB_GL860 is not set
 # CONFIG_USB_GPIO_VBUS is not set
 # CONFIG_USB_GSPCA is not set
@@ -3021,8 +3082,13 @@
 # CONFIG_USB_GSPCA_XIRLINK_CIT is not set
 # CONFIG_USB_GSPCA_ZC3XX is not set
 # CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
 # CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_NCM is not set
 # CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
 # CONFIG_USB_G_WEBCAM is not set
 # CONFIG_USB_HID is not set
 # CONFIG_USB_HIDDEV is not set
@@ -3047,6 +3113,7 @@
 # CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LIBUSUAL is not set
 # CONFIG_USB_M5602 is not set
+# CONFIG_USB_M66592 is not set
 # CONFIG_USB_MASS_STORAGE is not set
 # CONFIG_USB_MDC800 is not set
 # CONFIG_USB_MICROTEK is not set
@@ -3054,6 +3121,8 @@
 # CONFIG_USB_MON is not set
 # CONFIG_USB_MOUSE is not set
 # CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_NET2272 is not set
 # CONFIG_USB_NET_AX8817X is not set
 # CONFIG_USB_NET_CDCETHER is not set
 # CONFIG_USB_NET_CDC_EEM is not set
@@ -3087,6 +3156,7 @@
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_PRINTER is not set
 # CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_R8A66597 is not set
 # CONFIG_USB_R8A66597_HCD is not set
 # CONFIG_USB_RENESAS_USBHS is not set
 # CONFIG_USB_RIO500 is not set
@@ -3204,6 +3274,7 @@
 # CONFIG_USB_XUSBATM is not set
 # CONFIG_USB_YUREX is not set
 # CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_ZERO is not set
 # CONFIG_USB_ZR364XX is not set
 # CONFIG_USE_GENERIC_SMP_HELPERS is not set
 # CONFIG_USE_OF is not set
@@ -3298,8 +3369,8 @@
 # CONFIG_VIRTIO_BALLOON is not set
 # CONFIG_VIRTIO_MMIO is not set
 # CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTUALIZATION is not set
 # CONFIG_VIRT_DRIVERS is not set
-# CONFIG_VIRTUALIZATION is not set
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_VITESSE_PHY is not set
 CONFIG_VLAN_8021Q=y
@@ -3310,9 +3381,9 @@
 # CONFIG_VMSPLIT_2G_OPT is not set
 CONFIG_VMSPLIT_3G=y
 # CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMWARE_PVSCSI is not set
 # CONFIG_VMXNET3 is not set
 # CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_VMWARE_PVSCSI is not set
 # CONFIG_VORTEX is not set
 # CONFIG_VT is not set
 # CONFIG_VT6655 is not set
@@ -3403,4 +3474,3 @@
 CONFIG_ZONE_DMA=y
 CONFIG_ZONE_DMA_FLAG=1
 # CONFIG_ZRAM is not set
-# CONFIG_SIGMA is not set
Index: target/linux/cns3xxx/Makefile
===================================================================
--- target/linux/cns3xxx/Makefile	(revision 31639)
+++ target/linux/cns3xxx/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -march=armv6k -mtune=mpcore -mfloat-abi=softfp -mfpu=vfp -fno-caller-saves
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=2.6.39.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/at91/Makefile
===================================================================
--- target/linux/at91/Makefile	(revision 31639)
+++ target/linux/at91/Makefile	(working copy)
@@ -14,7 +14,7 @@
 CFLAGS:=-Os -pipe -march=armv5te -mtune=arm926ej-s -fno-caller-saves
 SUBTARGETS:=9g20 9260 9263
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 DEVICE_TYPE=
 
 include $(INCLUDE_DIR)/target.mk
Index: target/linux/ppc40x/Makefile
===================================================================
--- target/linux/ppc40x/Makefile	(revision 31639)
+++ target/linux/ppc40x/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -fno-caller-saves -mcpu=405
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: target/linux/omap4/Makefile
===================================================================
--- target/linux/omap4/Makefile	(revision 31639)
+++ target/linux/omap4/Makefile	(working copy)
@@ -11,7 +11,7 @@
 BOARDNAME:=TI OMAP4
 FEATURES:=usb targz audio display
 
-LINUX_VERSION:=3.3.4
+LINUX_VERSION:=3.3.8
 
 CFLAGS:=-Os -pipe -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=softfp
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
Index: target/linux/omap24xx/Makefile
===================================================================
--- target/linux/omap24xx/Makefile	(revision 31639)
+++ target/linux/omap24xx/Makefile	(working copy)
@@ -12,7 +12,7 @@
 MAINTAINER:=Michael Buesch <m@bues.ch>
 FEATURES:=targz squashfs jffs2 usb usbgadget display gpio audio
 
-LINUX_VERSION:=3.1.10
+LINUX_VERSION:=3.3.8
 
 define Target/Description
 	TI OMAP-24xx
Index: target/linux/ppc44x/Makefile
===================================================================
--- target/linux/ppc44x/Makefile	(revision 31639)
+++ target/linux/ppc44x/Makefile	(working copy)
@@ -13,7 +13,7 @@
 CFLAGS:=-Os -pipe -fno-caller-saves -mcpu=440
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
-LINUX_VERSION:=3.2.16
+LINUX_VERSION:=3.3.8
 
 include $(INCLUDE_DIR)/target.mk
 
Index: include/kernel-version.mk
===================================================================
--- include/kernel-version.mk	(revision 31639)
+++ include/kernel-version.mk	(working copy)
@@ -38,8 +38,8 @@
 ifeq ($(LINUX_VERSION),3.2.16)
   LINUX_KERNEL_MD5SUM:=246e6bd28ea44c90ec66c7f8b56e4803
 endif
-ifeq ($(LINUX_VERSION),3.3.4)
-  LINUX_KERNEL_MD5SUM:=113baeccd2a3341ecc62ae5e73c2ed1d
+ifeq ($(LINUX_VERSION),3.3.8)
+  LINUX_KERNEL_MD5SUM:=21068f0fd262b9b3670947f7892e1d6b
 endif
 
 # disable the md5sum check for unknown kernel versions
